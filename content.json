{"pages":[{},{},{},{},{}],"posts":[{"title":"wordpress","date":"2017-09-04T09:37:59.348Z","path":"FE/wordpress.html","text":"1.&nbsp站点迁移2.&nbsp技巧2.1.&nbsp首页显示摘要1. 站点迁移 编辑配置文件，更改数据库设置 改变数据库中的相关链接：UPDATE wp_options SET option_value = replace( option_value, 'www.liqiune.xyz','blog.liqiune.xyz') WHERE option_name = 'home' OR option_name ='siteurl' ; UPDATE wp_posts SET post_content = replace( post_content, 'www.liqiune.xyz','blog.liqiune.xyz') ; UPDATE wp_comments SET comment_content = replace(comment_content, 'www.liqiune.xyz','blog.liqiune.xyz') ; UPDATE wp_comments SET comment_author_url = replace(comment_author_url, 'www.liqiune.xyz','blog.liqiune.xyz');如上所示，即是将域名www.liqiune.xyz迁移到blog.liqiune.xyz 2. 技巧2.1. 首页显示摘要 content.php &lt;?php the_content( __( 'Continue reading &lt;span&gt;→&lt;/span&gt;', 'twentyeleven' ) ); ?&gt; 将它修改为 &lt;?php if(!is_single()) { the_excerpt(); } else { the_content(__('(more…)')); } ?&gt;http://zhidao.baidu.com/link?url=aMq7xLOdcsAuQB11CeD8C2ujW9TwNKVIDaqWnIJt222mqD8ec8-9YEo-uZza2Cv5_jPbZp2Yw4SqDazBvdFjqq","excerpt":"wordpress"},{"title":"shadowsocks","date":"2017-09-04T09:37:59.344Z","path":"FE/shadowsocks.html","text":"1.&nbsp安装1.1.&nbsp包管理器安装1.2.&nbsp编译安装1.2.1.&nbsp安装git1.2.2.&nbsp安装编译工具1.2.3.&nbsp克隆shadowsocks-libev仓库1.2.4.&nbsp编译2.&nbsp创建配置文件3.&nbspUDP转发并运行服务4.&nbsp设定开机自动运行1. 安装1.1. 包管理器安装https://github.com/shadowsocks/shadowsocks-libev#debian--ubuntu sudo apt update sudo apt install shadowsocks-libev1.2. 编译安装1.2.1. 安装git见Ubuntu下安装github 1.2.2. 安装编译工具apt-get install build-essential autoconf libtool libssl-dev1.2.3. 克隆shadowsocks-libev仓库git clone https://github.com/madeye/shadowsocks-libev.git1.2.4. 编译./configure make make install2. 创建配置文件sudo vim /etc/shadowsocks-libev/config.json{ \"server\":\"0.0.0.0\", \"server_port\":port, \"local_address\": \"127.0.0.1\", \"local_port\":1080, \"password\":\"password\", \"timeout\":300, \"method\":\"aes-256-cfb\", \"fast_open\": false, \"workers\": 1 }port替换为任意设定的端口，不要和已有端口冲突，10000以下password替换为设定的密码，8位以上aes-256-cfb为加密方式，客户端上需要选择 3. UDP转发并运行服务找到ss-server位置 whereis ss-server得到位置如：/usr/bin/ss-server nohup /usr/bin/ss-server -c /etc/shadowsocks-libev/config.json -u &amp;运行后可以使用Ctrl+C回到命令行，服务会在后台运行 4. 设定开机自动运行vim /etc/rc.local加入： nohup /usr/bin/ss-server -c /etc/shadowsocks-libev/config.json -u &amp;","excerpt":"shadowsocks"},{"title":"win-shortcuts","date":"2017-09-04T09:37:59.344Z","path":"FE/win-shortcuts.html","text":"1.&nbspWin101.1.&nbsp虚拟桌面1. Win101.1. 虚拟桌面 贴靠窗口：Win +左/右&gt; Win +上/下&gt;窗口可以变为1/4大小放置在屏幕4个角落 切换窗口：Alt + Tab（不是新的，但任务切换界面改进） 任务视图：Win + Tab（松开键盘界面不会消失） 创建新的虚拟桌面：Win + Ctrl + D 关闭当前虚拟桌面：Win + Ctrl + F4 切换虚拟桌面：Win + Ctrl +左/右","excerpt":"win-shortcuts"},{"title":"win-cmd","date":"2017-09-04T09:37:59.344Z","path":"FE/win-cmd.html","text":"1.&nbspBCD命令2.&nbspnetstate2.1.&nbsp查找端口被占用程序3.&nbspstart3.1.&nbsp打开并运行命令1. BCD命令 Win7及以上禁用驱动强制签名,其中win8及8.1需要配合快速启动达到保持禁用强制签名的效果bcdedit -set loadoptions DDISABLE_INTEGRITY_CHECKS bcdedit -set TESTSIGNING ON 2. netstate2.1. 查找端口被占用程序如查看4000端口被占用情况：netstat -aon|findstr &quot;4000&quot; 3. start3.1. 打开并运行命令 打开新terminal：start cmd.exe /K &quot;SET NODE_ENV=dev&amp;&amp; npm run rollupwatch 打开网址： start http://localhost:4000 注意需要加上http(s)才能被认为是网址","excerpt":"win-cmd"},{"title":"build","date":"2017-09-04T09:37:59.344Z","path":"wiki/wiki.html","text":"该博客采用Hexo构建! 使用wiki-i18n主题。 1.&nbsp如何建立一个相同的Wiki1.1.&nbsp安装hexo1.2.&nbsp克隆该git项目或主题作者的git博客项目1.3.&nbsp建立自己的GitHub项目1.4.&nbsp去除修改原有信息1.5.&nbsp修改样式1.6.&nbsp生成并调试1.7.&nbsp提交部署1. 如何建立一个相同的Wiki1.1. 安装hexo$ npm install hexo-cli -g该命令安装hexo命令行，可以通过 $ hexo --help查看命令行帮助 1.2. 克隆该git项目或主题作者的git博客项目 运行命令： $ git clone git@github.com:goumang2010/ChuuneWiki.git或 $ git clone git@github.com:xcatliu/js-index.git 补全nodejs依赖包： $ npm install1.3. 建立自己的GitHub项目 在github上建立项目，并获得git地址，如：git@github.com:yourname/project.git(默认已添加SSH key) 修改.git/config或使用 ： $ git remote set-url origin git@github.com:yourname/project.git将远程url更改为自己github项目的地址. 将master分支推送至远程仓库: $ git checkout master $ git push origin master1.4. 去除修改原有信息 删除source/_posts/中所有的md文件； 更改_config.yml文件，将站点信息更改为你想要的：subtitle:description:author:author_link:然后更改部署信息：deploy:type: gitrepo: git@github.com:yourname/project.gitbranch: gh-pagesmessage:这样，运行hexo deploy后，可以自动把编译后的静态网站推送至项目的gh-pages分支，从而完成部署 更改source/CNAME文件使cname指向你自有的域名，注意域名本身需添加DNS解析，解析cname至yourname.github.io。 更改/themes/wiki-i18n/layout/_partial/jumbotron.ejs将其中的链接替换为本身项目的。 1.5. 修改样式结合浏览器调试工具，修改 themes/wiki-i18n/source/css/normalize.css，达到你想要的效果 1.6. 生成并调试$ npm run start在浏览器中打开http://localhost:4000 ,进行查看和迭代修改 1.7. 提交部署 将master分支上的更改进行提交 运行： $ npm run deploy项目即部署到github page中，通过cname上配置的域名即可查看（该主题不可通过yourname.github.io/project查看，有样式问题）","excerpt":"如何构建该Wiki。"},{"title":"vsftpd","date":"2017-09-04T09:37:59.344Z","path":"FE/vsftpd.html","text":"1.&nbsp安装2.&nbsp配置3.&nbsp添加用户4.&nbsp重启1. 安装apt-get install vsftpd2. 配置创建用于共享的FTP目录： mkdir /home/ftp/设置读写权限： chmod 777 /home/ftp/打开配置文件: vim /etc/vsftpd.conf配置文件设置注意如下 禁止IPV6jianting listen_ipv6=NO - 设置根目录，需要预先建立 local_root=/home/ftp - 允许FTP的被动模式，命令连接和数据连接都由客户端发起，这样就可以解决从服务器到客户端的数据端口的入方向连接被防火墙过滤掉的问题 pasv_promiscuous=YES - 允许写入 write_enable=YES3. 添加用户sudo useradd -d /home/ftp -M username sudo passwd username按照提示输入密码 4. 重启service vsftpd restart","excerpt":"vsftpd"},{"title":"vscode","date":"2017-09-04T09:37:59.344Z","path":"FE/vscode.html","text":"1.&nbsp链接2.&nbsp安装3.&nbsp卸载4.&nbsp其他1. 链接官网：https://code.visualstudio.com文档：https://code.visualstudio.com/docs 2. 安装apt-get install ubuntu-makeumake web visual-studio-codeln -s /root/tools/web/visual-studio-code/Code /usr/local/bin/code/root/tools/web/visual-studio-code/Code为Code执行文件的路径 3. 卸载umake web visual-studio-code --removerm /usr/local/bin/code4. 其他 VPS使用远程桌面连接xfce4无法启动","excerpt":"vscode"},{"title":"visualStudio","date":"2017-09-04T09:37:59.344Z","path":"FE/visualStudio.html","text":"1.&nbsp文本编辑2.&nbsp插件3.&nbspRaw1. 文本编辑 清除空行：^(?([^\\r\\n])\\s)*\\r?$\\r?\\n改正这表达式可匹配所有空行，将其替换为空字符即可。 Ctrl+M+M 可以对结构进行折叠和展开。 输入/后可自动补全为：```/ */``` 自动排版Ctrl+K+F 2. 插件Web Essential已将编译less sass功能模块分拆 https://visualstudiogallery.msdn.microsoft.com/ee6e6d8c-c837-41fb-886a-6b50ae2d06a2 Important! Web Essentials 2015 no longer contains features for bundling and minifying of JS, CSS and HTML files as well as compiling LESS, Scss and CoffeeScript files. Those features have been moved to their own separate extensions that improves the features greatly. Download them here: Bundler &amp; Minifier - for bundling and minifying JS, CSS and HTML files Web Compiler - for compiling LESS, Sass, Scss, (Iced)CoffeeScript and JSX files Image Optimizer - for lossless optimization of PNG, JPG and GIFs Web Analyzer - for static code analysis (linting) of JS, TS, CSS and JSX files Gulp Snippet Pack - for being more productive writing Gulp files3. Raw 在安装某些插件后，复制粘贴不能保持完全一致，最好的办法是直接进行文件复制粘贴","excerpt":"visualStudio"},{"title":"vim-command","date":"2017-09-04T09:37:59.344Z","path":"Linux/vim-command.html","text":"1.&nbsp配置2.&nbsp浏览操作3.&nbsp文本操作4.&nbsp查找替换5.&nbsp工具操作6.&nbsp格式化6.1.&nbsp缩进1. 配置配置文件位置：/usr/share/vim/vimrc，取消 syntax on注释后可高亮显示。 2. 浏览操作 将光标移动到文档开头gg 将光标移动到文档末尾G 光标移动到该行开头0 光标移动到该行末尾$ 匹配结束符号（括号）% 匹配下一个单词w 3. 文本操作 可视块选择Ctrl+V注意块选不会选择到换行符，所以在粘贴的时候，需要提前为整行留出位置，否则内容会追加至已有行的内容上。 行块选择Shift+V 复制y 复制一行yy 粘贴p 删除一行dd 删除所有:%d或ggdG 4. 查找替换 开始查找/ 查找下一个N 查找上一个n 5. 工具操作 撤销u 重复Ctrl+r 保存退出:wq6. 格式化6.1. 缩进 选中多行，或仅当前行，按&gt;或&lt;执行缩进。 n&lt;&lt;或n&gt;&gt;进行多行缩进。 输入==，进行自动格式化","excerpt":"vim-command"},{"title":"uwp","date":"2017-09-04T09:37:59.344Z","path":"Windows/uwp.html","text":"1.&nbsp迁移1. 迁移由wp7和wp8的silverlight应用，迁移至UWP，可使用mobiliz转化。注意，如果visualStudio的版本问为2015 update3，则需要在需要转化的项目文件(.csproj),修改VisualStudioVersion标签为12.0，若没有该标签。则自行添加&lt;VisualStudioVersion&gt;12.0&lt;/VisualStudioVersion&gt;，否则转化时会报错","excerpt":"uwp"},{"title":"typescript","date":"2017-09-04T09:37:59.344Z","path":"FE/typescript.html","text":"1.&nbsp参数默认值2.&nbsp类型库2.1.&nbsp链接2.2.&nbsptsd2.2.1.1.&nbsp安装管理器2.2.1.2.&nbsp查询包2.2.1.3.&nbsp安装包2.3.&nbsptypings1. 参数默认值function ShowQR(data,toa:boolean=true) { if (toa) { toaWin(\"成功\", \"请查看二维码及链接\") } }翻译为JavaScript为： function ShowQR(data, toa) { if (toa === void 0) { toa = true; } if (toa) { toaWin(\"成功\", \"请查看二维码及链接\"); } }2. 类型库2.1. 链接 Github： https://github.com/DefinitelyTyped/DefinitelyTyped 官网： http://definitelytyped.org/ 2.2. tsdtsd已停用，现在应迁移至typings 说明：https://github.com/Definitelytyped/tsd#readme 2.2.1.1. 安装管理器npm install tsd -g2.2.1.2. 查询包 通过类型库搜索： http://definitelytyped.org/tsd/ 命令：tsd query pkgnamepkgname替换为包的名称，可以使用*等通配符 2.2.1.3. 安装包以下命令为安装toastr.js的类型库，-s是表示记录于tsd.json tsd install toastr -s该命令会在当前目录下创建typings\\toastr,并将toastr.d.ts存放其中 2.3. typings将tsd迁移至typings：https://github.com/typings/typings/blob/master/docs/tsd.md","excerpt":"typescript"},{"title":"sublime","date":"2017-09-04T09:37:59.344Z","path":"FE/sublime.html","text":"1.&nbsp安装1.1.&nbspWindows1.2.&nbspDebian/Ubuntu==2.&nbsp插件2.1.&nbsp安装插件2.2.&nbsp删除空行3.&nbsp快捷键4.&nbsp自定义快捷键5.&nbsp技巧1. 安装1.1. Windows 下载Sublime3并安装http://www.sublimetext.com/3 1.2. Debian/Ubuntu==wget https://download.sublimetext.com/sublime-text_build-3103_amd64.deb sudo dpkg -i sublime-text_build-3103_amd64.deb subl==License参考：http://blog.csdn.net/kencaber/article/details/50651207 2. 插件2.1. 安装插件 安装package control，ctrl+`打开命令窗口，输入该网址指示的内容： https://packagecontrol.io/installation Ctrl+Shift+P打开命令框，输入 install Pakage即可安装拓展包 2.2. 删除空行DeleteBlankLinesCtrl+A选中所有Ctrl+Alt+Backspace –&gt; 删除所有空行Ctrl+Alt+Shift+Backspace–&gt; 删除多余空行 3. 快捷键打开命令框： Ctrl+Shift+P 4. 自定义快捷键Preferences–Key-Bindings user添加alt+1，alt+2为行注释/块注释 { \"keys\": [\"alt+1\"], \"command\": \"toggle_comment\", \"args\": { \"block\": false } }, { \"keys\": [\"alt+2\"], \"command\": \"toggle_comment\", \"args\": { \"block\": true } }5. 技巧https://www.zhihu.com/question/24896283","excerpt":"sublime"},{"title":"stars","date":"2017-09-04T09:37:59.344Z","path":"FE/stars.html","text":"1.&nbsp脚手架1. 脚手架 yeoman","excerpt":"stars"},{"title":"sitespeed","date":"2017-09-04T09:37:59.344Z","path":"FE/sitespeed.html","text":"基于coach/Yslow，github: github。运行后生成一个纯静态站点展示所有报告 1.&nbspv3.x2.&nbspv4.02.1.&nbsp源码分析2.1.1.&nbsp入口文件./bin/sitespeed.js2.1.2.&nbsp./lib/sitespeed.js2.1.3.&nbsp./support/queueHandler.js2.1.4.&nbsp插件2.1.4.1.&nbspbrowsertime2.1.4.2.&nbspcoach2.2.&nbspWindows安装测试方法:1. v3.x为目前的生产环境版本，使用YSlow和BrowserMobProxy 分析页面，官方文档即3.11.7版本文档.Windows下安装测试步骤： node环境及VS（C++编译器）环境，npm源添加淘宝镜像。 安装JAVA并确保加入环境变量path 下载解压slimerjs-0.9.6-win32.zip，并确保slimerjs.bat所在目录包含在环境变量path中。 下载解压phantomjs-2.1.1-windows.zip,并确保phantomjs.exe所在目录包含在环境变量path中。 下载解压chromedriver_win32.zip,并确保chromedriver.exe所在目录包含在环境变量path中。 运行npm install -g sitespeed.io 测试：sitespeed.io.cmd -u https://m.gomeplus.com --wptHost www.webpagetest.org --wptKey A.d8127398a99713f3083f549dec9641ef 2. v4.0为目前开发版本，采用coach，不需要java依赖和浏览器前置代理，速度更快。 2.1. 源码分析2.1.1. 入口文件./bin/sitespeed.js通过../lib/support/cli.js接受命令行传递的参数，cli.js使用yargs对参数处理，并导出options，options传入../lib/support/pluginLoader.js的parsePluginNames方法，处理后得到所有使用的插件名称，最后使用../lib/sitespeed.js的方法，传入插件名称和cli的options进行最后处理。 2.1.2. ./lib/sitespeed.js导出run(pluginNames, options){},该方法首先建立相关存储目录，然后调用./support/pluginLoader.js中的loadPlugins方法，该方法传入插件名，导出require各个插件后的模块对象，调用runOptionalFunction方法，执行各个模块定义的open，postOpen(如果存在)，再传入./support/queueHandler.js处理，对模块进行队列管理，调用模块的processMessage方法，出现错误会调用close方法。 2.1.3. ./support/queueHandler.js构造QueueHandler类，该类构造器传入plugins模块数组和用户输入的参数options，并调用createQueues构造执行队列。run方法传入url-source.js构建的对象，并执行findUrls方法，该方法会执行queueHandler.js中的postMessage方法，并传入参数{type=’url’,…},这回导致队列每个插件的参数都为’url’，当之后的startProcessingQueues时传入了处理函数plugin.processMessage(message, this)后，会执行自身的processMessage({type:’url,…}’,this)。再所有插件都执行完毕后，又一次调用processMessage，这会传入{type:’summarize’,…}进行结果输出。 2.1.4. 插件./lib/support/pluginLoader.js定义的默认插件为’browsertime’, ‘coach’, ‘domains’, ‘assets’, ‘html’, ‘analysisStorer’,’screenshot’，这些插件被queueHandler.js中的队列控制，按顺序加载调用。 2.1.4.1. browsertime在调用processMessage({type:’url,…}’,this)时，会先通过analyzer.js的analyzeUrl方法对url进行分析，该方法是执行主体，其中同时调用browsertime和coach模块，得到结果后通过队列的postMessage进而调用插件processMessage的type参数情况判断含有’browsertime.run’，’browsertime.pageSummary’，’browsertime.har’，’browsertime.screenshot’的插件的相应方法。这些情况都在html插件当中，即把结果输出给html。注意browsertime.har还会触发domains和coach相应的processMessage方法。 2.1.4.2. coachbrowsertime默认会通过其中的processCoachOutput触发type为coach.run的processMessage方法，该方法触发html插件的coach.pageSummary。 2.2. Windows安装测试方法: node环境及VS（C++编译器）环境，npm源添加淘宝镜像。 下载解压phantomjs-2.1.1-windows.zip,并确保phantomjs.exe所在目录包含在环境变量path中。 下载解压chromedriver_win32.zip,并确保chromedriver.exe所在目录包含在环境变量path中。 运行npm i -g sitespeed.io@canary 测试：sitespeed.io.cmd https://m.gomeplus.com --webpagetest.host www.webpagetest.org --webpagetest.key A.d8127398a99713f3083f549dec9641ef --mobile --html.showWaterfallSummary","excerpt":"sitespeed"},{"title":"Vue2","date":"2017-09-04T09:37:59.344Z","path":"FE/vue2.html","text":"1.&nbsp获取Vue2源码2.&nbsp文件结构3.&nbspentries3.1.&nbspweb-compiler.js3.2.&nbspweb-runtime.js3.3.&nbspweb-runtime-with-compiler.js3.4.&nbspweb-server-renderer.js4.&nbspplatforms - web4.1.&nbspcompiler4.1.1.&nbspcompile4.1.2.&nbspcompileToFunctions4.2.&nbsputil4.2.1.&nbspquery4.3.&nbspruntime4.3.1.&nbspdirectives4.3.1.1.&nbspmodel4.3.1.1.1.&nbspsetSelected5.&nbspcompiler导出真正进行模板编译的compile函数5.1.&nbspcodegen5.1.1.&nbspindex.js5.2.&nbspparser5.2.1.&nbspindex.js5.2.1.1.&nbspoptions.start5.2.1.1.1.&nbspprocessAttrs5.2.1.1.2.&nbspaddDirective5.2.1.1.3.&nbspaddHandler5.2.1.1.4.&nbspprocessFor5.2.1.1.5.&nbspprocessIf5.2.1.1.6.&nbspprocessOnce5.2.1.1.7.&nbspprocessKey5.2.1.1.8.&nbspprocessRef5.2.1.1.9.&nbspprocessSlot5.2.1.1.10.&nbspprocessComponent5.2.1.1.11.&nbspprocessRawAttrs5.2.1.1.12.&nbspprocessPre5.2.2.&nbsphtml-parser.js5.2.2.1.&nbspparseHTML5.2.2.1.1.&nbspparseStartTag5.2.2.1.2.&nbsphandleStartTag5.2.2.1.3.&nbspparseEndTag6.&nbspvm实例6.1.&nbsp$parent6.2.&nbsp$options7.&nbspcore7.1.&nbspindex.js7.2.&nbspconfig.js7.3.&nbspglobal-api7.3.1.&nbspextend.js7.3.1.1.&nbspinitExtend7.4.&nbspinstance7.4.1.&nbspindex.js7.4.2.&nbspinit.js7.4.2.1.&nbspinitMixin7.4.3.&nbspevents.js7.4.3.1.&nbspinitEvents7.4.4.&nbsplifecycle.js7.4.4.1.&nbspinitLifecycle7.4.4.2.&nbsplifecycleMixin7.4.4.3.&nbspcallHook7.4.5.&nbsprender.js7.4.5.1.&nbspinitRender7.4.5.2.&nbspresolveSlots7.4.5.3.&nbsprenderMixin7.4.6.&nbspstate.js7.4.6.1.&nbspinitState7.4.6.2.&nbspinitProps7.4.6.3.&nbspinitData7.4.6.4.&nbspinitComputed7.4.6.5.&nbspmakeComputedGetter7.4.6.6.&nbspinitMethods7.4.6.7.&nbspinitWatch7.4.6.8.&nbspVue.prototype.$watch7.5.&nbspobserver7.5.1.&nbsparray.js7.5.2.&nbspindex.js7.5.2.1.&nbspObserver类7.5.2.1.1.&nbsp实例属性7.5.2.1.2.&nbsp初始化7.5.2.2.&nbspobserve7.5.2.3.&nbspdefineReactive7.5.2.3.1.&nbspget7.5.2.3.2.&nbspset7.5.3.&nbspscheduler.js7.5.3.1.&nbspflushSchedulerQueue7.5.3.2.&nbspresetSchedulerState7.5.3.3.&nbspqueueWatcher7.5.4.&nbspwatcher.js7.5.4.1.&nbsp初始化7.5.4.2.&nbsp原型方法7.5.4.2.1.&nbspupdate7.5.4.2.2.&nbsprun7.5.4.2.3.&nbspget7.5.4.2.4.&nbspaddDep7.5.4.2.5.&nbspcleanupDeps7.5.4.2.6.&nbspdepend7.5.4.3.&nbspHelper7.5.4.3.1.&nbsptraverse7.5.5.&nbspdep.js7.5.5.1.&nbspDep.target7.5.6.&nbspaddSub7.5.7.&nbspremoveSub7.5.8.&nbspnotify7.5.9.&nbspdepend7.5.10.&nbsp静态属性方法7.5.10.1.&nbsppushTarget7.5.10.2.&nbsppushTarget7.6.&nbsputil工具类7.6.1.&nbspdebug.js7.6.1.1.&nbspformatComponentName7.6.1.2.&nbspformatLocation7.6.1.3.&nbspwarn7.6.2.&nbspshared/util.js7.6.2.1.&nbspbind7.6.2.2.&nbspisObject7.6.2.3.&nbspisPlainObject7.6.2.4.&nbspisPrimitive7.6.2.5.&nbspremove7.6.2.6.&nbsphasOwn7.6.2.7.&nbspcamelize7.6.2.8.&nbspcapitalize7.6.2.9.&nbsphyphenate7.6.2.10.&nbspcached7.6.3.&nbsplang.js7.6.3.1.&nbspparsePath7.6.3.2.&nbspdef7.6.4.&nbspenv.js7.6.4.1.&nbspnextTick7.6.4.2.&nbsphasProto7.6.5.&nbspoptions.js7.6.5.1.&nbspmergeOptions7.6.5.2.&nbspresolveAsset7.6.6.&nbspprops.js7.6.6.1.&nbspvalidateProp7.6.6.2.&nbspgetPropDefaultValue7.6.6.3.&nbspgetType7.6.6.4.&nbspassertProp7.7.&nbspvdom7.7.1.&nbspcreate-element.js7.7.1.1.&nbspcreateElement7.7.1.2.&nbsp_createElement7.7.2.&nbspcreate-component.js7.7.2.1.&nbspcreateComponent7.7.2.2.&nbspmergeHooks7.7.2.3.&nbspmergeHook7.7.2.4.&nbsphook.prepatch7.7.2.5.&nbsphook.init7.7.2.6.&nbspcreateComponentInstanceForVnode7.7.2.7.&nbspcreateFunctionalComponent7.7.2.8.&nbspextractProps7.7.3.&nbspcheckProp7.7.3.1.&nbspresolveAsyncComponent7.7.4.&nbsphelpers.js7.7.4.1.&nbspupdateListeners7.7.4.2.&nbsparrInvoker7.7.4.3.&nbspfnInvoker7.7.4.4.&nbspnormalizeChildren7.7.4.5.&nbspcreateTextVNode7.7.4.6.&nbspapplyNS7.7.5.&nbsppatch.js7.7.5.1.&nbsppatch7.7.5.2.&nbsppatchVnode7.7.5.3.&nbspupdateChildren7.7.5.4.&nbspaddVnodes7.7.5.5.&nbspsameVnode7.7.5.6.&nbspcreateElm7.7.5.7.&nbspinvokeCreateHooks7.7.5.8.&nbspcreateChildren7.7.5.9.&nbspsetScope7.7.5.10.&nbspinitComponent7.7.5.11.&nbspisPatchable7.7.6.&nbspvnode.js7.7.6.1.&nbspVNode类7.7.6.2.&nbspemptyVNode7.7.6.3.&nbspcloneVNodes7.7.6.4.&nbspcloneVNode8.&nbsp流程及测试1. 获取Vue2源码git clone git@github.com:vuejs/vue.git cd vue git checkout next2. 文件结构 ├── compiler │ ├── codegen │ │ ├── events.js │ │ └── index.js │ ├── directives │ │ ├── bind.js │ │ └── index.js │ ├── error-detector.js │ ├── helpers.js │ ├── index.js │ ├── optimizer.js │ └── parser │ ├── entity-decoder.js │ ├── filter-parser.js │ ├── html-parser.js │ ├── index.js │ └── text-parser.js ├── core │ ├── components │ │ ├── index.js │ │ └── keep-alive.js │ ├── config.js │ ├── global-api │ │ ├── assets.js │ │ ├── extend.js │ │ ├── index.js │ │ ├── mixin.js │ │ └── use.js │ ├── index.js │ ├── instance │ │ ├── events.js │ │ ├── index.js │ │ ├── init.js │ │ ├── lifecycle.js │ │ ├── proxy.js │ │ ├── render.js │ │ └── state.js │ ├── observer │ │ ├── array.js │ │ ├── dep.js │ │ ├── index.js │ │ ├── scheduler.js │ │ └── watcher.js │ ├── util │ │ ├── debug.js │ │ ├── env.js │ │ ├── index.js │ │ ├── lang.js │ │ ├── options.js │ │ └── props.js │ └── vdom │ ├── create-component.js │ ├── create-element.js │ ├── helpers.js │ ├── modules │ │ ├── directives.js │ │ ├── index.js │ │ └── ref.js │ ├── patch.js │ └── vnode.js ├── entries │ ├── web-compiler.js │ ├── web-runtime.js │ ├── web-runtime-with-compiler.js │ └── web-server-renderer.js ├── platforms │ └── web │ ├── compiler │ │ ├── directives │ │ │ ├── html.js │ │ │ ├── index.js │ │ │ ├── model.js │ │ │ └── text.js │ │ ├── index.js │ │ └── modules │ │ ├── class.js │ │ ├── index.js │ │ └── style.js │ ├── runtime │ │ ├── class-util.js │ │ ├── components │ │ │ ├── index.js │ │ │ ├── transition-group.js │ │ │ └── transition.js │ │ ├── directives │ │ │ ├── index.js │ │ │ ├── model.js │ │ │ └── show.js │ │ ├── modules │ │ │ ├── attrs.js │ │ │ ├── class.js │ │ │ ├── dom-props.js │ │ │ ├── events.js │ │ │ ├── index.js │ │ │ ├── style.js │ │ │ └── transition.js │ │ ├── node-ops.js │ │ ├── patch.js │ │ └── transition-util.js │ ├── server │ │ ├── directives │ │ │ ├── index.js │ │ │ └── show.js │ │ └── modules │ │ ├── attrs.js │ │ ├── class.js │ │ ├── dom-props.js │ │ ├── index.js │ │ └── style.js │ └── util │ ├── attrs.js │ ├── class.js │ ├── compat.js │ ├── element.js │ └── index.js ├── server │ ├── create-bundle-renderer.js │ ├── create-renderer.js │ ├── render.js │ ├── render-stream.js │ ├── run-in-vm.js │ └── write.js ├── sfc │ └── parser.js └── shared └── util.js 3. entries3.1. web-compiler.js默认导出compile函数，将模板编译成render函数。参数： template: string, options?: CompilerOptions注入modules和directives后调用/platforms/web/compiler/index.js中compile函数进行编译，而该compile函数仅仅将一些web平台的modules和directive及一些工具函数确保注入options后，调用/compiler/index.js中的compile函数，该函数是真正进行编译的函数。 3.2. web-runtime.js首先从’core/index’中获取Vue类 安装从web/util/index.js导出的web平台专有的工具函数。 安装平台运行时专有的指令和组件。分别从web/runtime/directives/和web/runtime/components/导出，组件就是web的过渡效果，指令为v-model和v-show，将它们分别加入Vue.options.components和Vue.options.directives。供patch生成DOM 安装平台patch函数，config._isServer不为true，安装’web/runtime/patch’导出的patch，该patch实际上是通过向createPatchFunction传入web/runtime/node-ops（dom基本操作），core/vdom/modules/index（基本指令）生成的. 构造Vue.prototype.$mount： 若非服务端，调用query加工el，这时el为Element，即DOM元素，然后调用_mount 使devtools发射init事件。devtools.emit(&#39;init&#39;, Vue) 经过以上修饰，导出Vue类 3.3. web-runtime-with-compiler.js闭包缓存query函数，返回el.innerHTML, 为idToTemplate。重构web-runtime已定义的Vue.prototype.$mount,加入编译模板template过程： 调用query加工el，取得el对应的DOM，若该DOM为document.body（body标签对应的元素）或document.documentElement（html标签对应的元素），则直接返回，在非生产环境下提示，不能将Vue挂载到html或body标签上。 实例$options上若不存在render函数，则取this.$options.template为template, 若template存在: template为字符串，且第一个字母为#，说明其为id选择器，调用idToTemplate，取其代表元素的innerHTML赋予template template.nodeType存在，说明其为DOM元素，直接取其innerHTML赋予template 若不是以上两种情况，非生产环境下提示：·invalid template option template不存在，但el存在，调用getOuterHTML并传入el，即是el.outerHTML,若该属性不存在，在el上建立个父节点（容器），然后取容器的innerHTML。 经过以上过程，template存在，则调用compileToFunctions编译template生成render函数和staticRenderFns，并统统挂到$options上 执行原定义的Vue.prototype.$mount。 3.4. web-server-renderer.js导出createRenderer和createBundleRenderer函数 4. platforms - web4.1. compiler4.1.1. compile将当前目录下的/modules和/directives合并至options，然后调用compiler/index.js中的complie函数进行模板编译。 4.1.2. compileToFunctions将模板编译为render函数 template: string, options?: CompilerOptions, vm?: Component不能使用构造函数来构建，提示错误 使用compile编译模板，通过makeFunction将编译后的render字符串转化为函数放至res.render 遍历编译后的staticRenderFns数组，将其转化为函数，重新构建数组挂在res上。 使用闭包变量cache进行缓存，并返回res。 4.2. util4.2.1. query传入el 若el不是string，直接返回el 调用document.querySelector(el), 若不存在，则提示无法找到，并创建一个div后返回。 将找到的dom返回。 4.3. runtime4.3.1. directives该目录中的内容将在web-runtime.js中加入到Vue.options.directives中，然后通过vdom处理。 4.3.1.1. model导出inserted及componentUpdated函数 inserted 若非生产环境，且vnode的tag属性不是input，select，textarea或组件时，提示v-model无法应用于除这些之外的元素 tag为select，则调用setSelected// TODO4.3.1.1.1. setSelected// TODO 5. compiler导出真正进行模板编译的compile函数 调用parse转化模板为ASTElement 调用optimize进行优化 调用generate根据ast树生成render函数代码并返回。 5.1. codegen5.1.1. index.js导出generate函数 5.2. parser5.2.1. index.js导出parse 生成Options，并调用parseHTML，转化DOM为ASTElement，同时也解析其中的指令。 5.2.1.1. options.start转化指令，构建AST 构建基本AST：const element: ASTElement = { type: 1, tag, attrsList: attrs, attrsMap: makeAttrsMap(attrs, options.isIE), parent: currentParent, children: [] } 执行导入的各个模块中的pre-transforms parse闭包内inVPre为false，执行processPre,若存在v-pre，置inVPre为true 如果tag为pre，置inPre为true inVPre为true，则执行processRawAttrs，否则 执行processFor，processIf，processOnce，processKey 执行processRef， processSlot， processComponent 执行引入模块中每个transforms函数 执行processAttrs 5.2.1.1.1. processAttrs 遍历el.attrsList,使用/^v-|^@|^:/匹配元素的name属性 若可匹配上 el.hasBindings = true,再使用/.[^.]+/g匹配，把如a.b.c转化为{a:true,b:true,c:true}，存为modifiers 若name可匹配v-bind，将name中已转化的路径去除。 modifiers中含有prop属性，则 isProp = true name转化为驼峰，并修正innerHtml为innerHTML。 若isProp为true或platformMustUseProp(name)，el.props加入{name, value}，否则el.attrs加入{name, value} 若name可匹配v-on，将name中的v-on代表的符号去除，仅剩路径，调用addHandler(el, name, value, modifiers) 以上都未匹配，说明为常规指令，使用/^v-|^@|^:/将name中代表指令的部分剔除，使用/:(.*)$/匹配参数arg，调用addDirective(el, name, value, arg, modifiers) 5.2.1.1.2. addDirective参数 el: ASTElement, name: string, value: string, arg: ?string, modifiers: ?{ [key: string]: true }向el.directives 中加入{ name, value, arg, modifiers } 5.2.1.1.3. addHandler参数 el: ASTElement, name: string, value: string, modifiers: ?{ [key: string]: true }, important: ?boolean modifiers.capture存在，删除modifiers.capture，name前置！ modifiers.native存在，events = el.nativeEvents,否则 events = el.events const newHandler = { value, modifiers };const handlers = events[name]; handlers为数组，important为true，handlers头部加入newHandler，否则尾部加入newHandler handlers不是数组，将其变为数组important ? [newHandler, handlers] : [handlers, newHandler] handlers不存在events[name] = newHandler 5.2.1.1.4. processFor 取出v-for属性为exp，通过正则，将要遍历的对象赋予el.for 遍历出的每个元素通过/\\(([^,]*),([^,]*)(?:,([^,]*))?\\/,匹配是否为括号中的元素。若不是，直接置为el.alias，否则，分别将括号中的元素赋予el.alias，el.iterator1，el.iterator2 5.2.1.1.5. processIf 取出v-if属性为exp，将其赋予el.if 取v-else，若存在，则el.else = true; 5.2.1.1.6. processOncefunction processOnce (el) { var once = getAndRemoveAttr(el, 'v-once'); if (once != null) { el.once = true; } }5.2.1.1.7. processKey 调用getBindingAttr取得v-bind:key或:key,赋予el.key 5.2.1.1.8. processRef 调用getBindingAttr取得v-bind:ref或:ref,赋予el.ref 调用checkInFor检查el是否在v-for中，将布尔值赋予el.refInFor 5.2.1.1.9. processSlot 如果el的tag本身为slot，调用getBindingAttr取得v-bind:name或:name,赋予el.slotName tag不是slot，调用getBindingAttr取得v-bind:slot或:slot,赋予el.slotTarget 5.2.1.1.10. processComponent 调用getBindingAttr取得v-bind:is或:is,赋予el.component el上如果存在inline-template属性，则el.inlineTemplate = true 5.2.1.1.11. processRawAttrs将el.attrsList元素分别取出，按照{name,value}存放至el.attrs 5.2.1.1.12. processPrefunction processPre (el) { if (getAndRemoveAttr(el, 'v-pre') != null) { el.pre = true; } }5.2.2. html-parser.js导出parseHTML函数，原型：http://erik.eae.net/simplehtmlparser/simplehtmlparser.js预定义各种匹配正则 attribute /^\\s*([^\\s&quot;&#39;&lt;&gt;\\/=]+)(?:\\s*((?:=))\\s*(?:&quot;([^&quot;]*)&quot;+|&#39;([^&#39;]*)&#39;+|([^\\s&quot;&#39;=&lt;&gt;`]+)))?/ svg{background-color:#fff}text,tspan{font:12px Arial}path{fill-opacity:0;stroke-width:2px;stroke:#000}circle{fill:#6b6659;stroke-width:2px;stroke:#000}.anchor text,.any-character text{fill:#fff}.anchor rect,.any-character rect{fill:#6b6659}.escape text,.charset-escape text,.literal text{fill:#000}.escape rect,.charset-escape rect{fill:#bada55}.literal rect{fill:#dae9e5}.charset .charset-box{fill:#cbcbba}.subexp .subexp-label tspan,.charset .charset-label tspan,.match-fragment .repeat-label tspan{font-size:10px}.repeat-label{cursor:help}.subexp .subexp-label tspan,.charset .charset-label tspan{dominant-baseline:text-after-edge}.subexp .subexp-box{stroke:#908c83;stroke-dasharray:6,2;stroke-width:2px;fill-opacity:0}.quote{fill:#908c83} Created with SnapStart of linewhite spacegroup #1None of:white space““”“‘”“&lt;”“&gt;”“/”“=”white spacegroup #2“=”white space““”group #3None of:““”““”“‘”group #4None of:“‘”“‘”group #5None of:white space““”“‘”“=”“&lt;”“&gt;”“`” startTagOpen /^&lt;((?:[a-zA-Z_][\\w\\-\\.]*\\:)?[a-zA-Z_][\\w\\-\\.]*)/ svg{background-color:#fff}text,tspan{font:12px Arial}path{fill-opacity:0;stroke-width:2px;stroke:#000}circle{fill:#6b6659;stroke-width:2px;stroke:#000}.anchor text,.any-character text{fill:#fff}.anchor rect,.any-character rect{fill:#6b6659}.escape text,.charset-escape text,.literal text{fill:#000}.escape rect,.charset-escape rect{fill:#bada55}.literal rect{fill:#dae9e5}.charset .charset-box{fill:#cbcbba}.subexp .subexp-label tspan,.charset .charset-label tspan,.match-fragment .repeat-label tspan{font-size:10px}.repeat-label{cursor:help}.subexp .subexp-label tspan,.charset .charset-label tspan{dominant-baseline:text-after-edge}.subexp .subexp-box{stroke:#908c83;stroke-dasharray:6,2;stroke-width:2px;fill-opacity:0}.quote{fill:#908c83} Created with SnapStart of line“&lt;”group #1One of:-“a”“z”-“A”“Z”“”One of:word“-”“.”“:”One of:-“a”“z”-“A”“Z”“”One of:word“-”“.” startTagClose /^\\s*(\\/?)&gt;/ endTag /^&lt;\\/((?:[a-zA-Z_][\\w\\-\\.]*\\:)?[a-zA-Z_][\\w\\-\\.]*)[^&gt;]*&gt;/ svg{background-color:#fff}text,tspan{font:12px Arial}path{fill-opacity:0;stroke-width:2px;stroke:#000}circle{fill:#6b6659;stroke-width:2px;stroke:#000}.anchor text,.any-character text{fill:#fff}.anchor rect,.any-character rect{fill:#6b6659}.escape text,.charset-escape text,.literal text{fill:#000}.escape rect,.charset-escape rect{fill:#bada55}.literal rect{fill:#dae9e5}.charset .charset-box{fill:#cbcbba}.subexp .subexp-label tspan,.charset .charset-label tspan,.match-fragment .repeat-label tspan{font-size:10px}.repeat-label{cursor:help}.subexp .subexp-label tspan,.charset .charset-label tspan{dominant-baseline:text-after-edge}.subexp .subexp-box{stroke:#908c83;stroke-dasharray:6,2;stroke-width:2px;fill-opacity:0}.quote{fill:#908c83} Created with SnapStart of line“&lt;/”group #1One of:-“a”“z”-“A”“Z”“”One of:word“-”“.”“:”One of:-“a”“z”-“A”“Z”“”One of:word“-”“.”None of:“&gt;”“&gt;” doctype /^&lt;!DOCTYPE [^&gt;]+&gt;/i 5.2.2.1. parseHTML const stack = []用于存放每个tag html为通过游标截取的模板字符串，const textEnd = html.indexOf(&#39;&lt;&#39;)textEnd为0（第一个字符是&lt;）,且lastTag不存在，即使存在，也不是script或style，则进行如下操作： 通过/^&lt;!--/判断是截取的html开头是否进入Comment，如果进入跳过（将游标commentEnd移到’–&gt;’后面，直接进入下个循环。 通过/^&lt;!\\[/判断html进入ie的条件注释下，进入则跳过它，直接进入下个循环。 通过正则doctype跳过Doctype，直接进入下个循环。 通过endTag匹配标签末尾，跳过这个末尾并且调用parseEndTag，即根据结尾符号进行标签转化，直接进入下个循环。 通过parseStartTag直接使用startTagOpen匹配标签开头，返回{tagName, attrs:[],start:index}，并使用handleStartTag处理，然后进入下个循环。 textEnd &gt;= 0：跳过’&lt;’之前的字符，使得&lt;成为第一个字符, 若textEnd&lt;0 , 说明剩余的字符串中已经没有’&lt;’，这时text = html;html = &#39;&#39;; lastTag存在，且为script或style ：直接匹配该标签的尾部，并使用parseEndTag处理。 5.2.2.1.1. parseStartTag5.2.2.1.2. handleStartTag5.2.2.1.3. parseEndTag tagName存在，在stack数组中搜索最近的开放标签 对stack数组中最近的开放标签与传入标签之间的所有标签执行options.end 通过设置stack数组的length属性移出执行过options.end的对象 stack数组中不存在最近的开放标签： 传入标签名称为br，调用options.start，只不过第3个参数unary设为true 传入的标签名称为p，分别调用options.start和options.end，unary设为false 6. vm实例入口为：/src/core/index.js导出的Vue类 6.1. $parent若$parent为undefined,则其为根实例。 6.2. $options 属性 处理文件 处理函数 说明 props b c —- propsData e f —- _propKeys h i —- 7. core7.1. index.js从instance/index.js导入Vue类，根据配置文件（process.env.VUE_ENV）设置vue原型上$isServer的get方法，设置Vue静态变量version，导出Vue类。 7.2. config.js各项设置开关 7.3. global-api7.3.1. extend.js7.3.1.1. initExtendVue.cid = 0 let cid = 1每个实例构造函数，包括Vue类本身，都有一个独一无二的cid。这使得我们可以通过原型继承来包装子级构造函数并缓存它们。 Vue.extend返回一个继承Vue类的构造函数。参数：extendOptions: Object 将this（this为基类本身，因为该方法是基类的属性，this不一定为Vue，因为Vue的子类因为Sub.extend = Super.extend也同样有该静态方法）置为Super，若Super.cid === 0，则说明现在构造的这个类是第一个继承Vue的，故置isFirstExtend为true。 若该类是第一个继承Vue的，并且extendOptions._Ctor存在，则直接返回extendOptions._Ctor。 let name = extendOptions.name || Super.options.name 非生产环境，使用正则判断，name应以字母开头，其后是单词或’-‘，否则提示’Invalid component name’ 创建继承类Sub，其构造函数内部与Vue一致，执行this._init(options) 设置原型Sub.prototype = Object.create(Super.prototype);Sub.prototype.constructor = Sub Sub.cid = cid++cid是initExtend闭包中的变量，从1开始，这样，类的静态属性cid就表示其创建顺序，Vue本身的cid为0 调用mergeOptions融合extendOptions和Super.options，置为Sub.options Sub.extend = Super.extend, 子类同样设置该静态方法。 在子类注册asset类型。 config._assetTypes.forEach(function (type) { Sub[type] = Super[type]}) 其实目前type只有component，directive，filter 若name存在，挂载自身从而可以循环查找。Sub.options.components[name] = Sub Sub.superOptions = Super.options 挂载superOptions，这样在实例化时可以检查父级option是否已经更新了 Sub.extendOptions = extendOptions isFirstExtend为true（根据第1步，能进行到这部，说明extendOptions上无_Ctor属性），extendOptions._Ctor = Sub 返回Sub 7.4. instance7.4.1. index.js定义Vue类，将instance文件夹中定义的各Mixin函数注入Vue类，并导出，该类将在实例初始化执行原型上的_init方法(init.js定义)。 initMixin(Vue) stateMixin(Vue) eventsMixin(Vue) lifecycleMixin(Vue) renderMixin(Vue) initMixin定义原型上_init方法，进行必要的初始化，并执行instance文件夹中个文件定义的初始化函数，将Vue实例（组件）this注入。 7.4.2. init.js7.4.2.1. initMixininitLifecycle(vm) initEvents(vm) callHook(vm, 'beforeCreate') initState(vm) callHook(vm, 'created') initRender(vm) initLifecycle initEvents callHook -beforeCreate通过callHook（lifecycle.js定义）执行beforeCreate钩子，即执行$options[‘beforeCreate’]数组中的每个handler，并发射’hook:beforeCreate’事件。 initState callHook -created通过callHook执行created钩子。 initRender 7.4.3. events.js7.4.3.1. initEvents vm._events置为无原型空对象 定义vm._updateListeners，通过updateListeners监听vm.$options._parentListeners，其中原型上的$on，$off（eventsMixin中定义）作为updateListeners的add和remove参数// init parent attached events const listeners = vm.$options._parentListeners const on = bind(vm.$on, vm) const off = bind(vm.$off, vm) vm._updateListeners = (listeners, oldListeners) =&gt; { updateListeners(listeners, oldListeners || {}, on, off) } if (listeners) { vm._updateListeners(listeners) } 7.4.4. lifecycle.js7.4.4.1. initLifecycle 从$options.parent开始，递归其上$options.abstract为true的$parent属性,找到第一个非abstract的parent parent.$children.push(vm) 初始化组件的生命周期变量，包括$parent，$root，$children，$refs，内部变量_watcher，_inactive，_isMounted，_isDestroyed，_isBeingDestroyed 7.4.4.2. lifecycleMixin定义Vue原型上的_mount，_update，_updateFromParent，$forceUpdate，$destroy方法 Vue.prototype._mount参数： el?: Element | void, hydrating?: boolean返回：Component const vm: Component = this vm.$el = el 若$options.render不存在，将$options.render置为emptyVNode（空节点），若非生产环境，且$options.template存在，则提示应使用render函数或预先编译template，$options.template不存在则提示装载组件错误 使用callHook执行beforeMount钩子。 vm._watcher = new Watcher(vm, () =&gt; { vm._update(vm._render(), hydrating) }, noop) ，vm._update(vm._render(), hydrating)会在该方法经过的观测者的dep捕获。因为在这个过程中会执行vm._render()，该方法会调用组件定义的render函数，render函数中包含对data或props的读取（如将会转化成render的createElement参数的某个属性值），这样因为其读取的所用到的data和props已转化getter，setter，故该watcher会被这些相关数据的dep捕获。但这些数据发生变化时，setter就会促发本watcher的get方法（vm._update(vm._render(), hydrating)，从而重新渲染）和回调noop(无用)。注意在此过程中，createElement会按照render函数的指示生成并返回vnode对象，经过vm._update渲染到$el上。 hydrating = false vm为根节点，使用callHook执行mounted钩子。 返回vm Vue.prototype._update 使用callHook执行beforeUpdate钩子。 const prevEl = vm.$el注意$el为在initRender传入Vue.prototype._mount中的vm.$options.el const prevActiveInstance = activeInstance;activeInstance = vm; activeInstance为lifecycle.js所定义的模块变量。 const prevVnode = vm._vnode;vm._vnode = vnode; prevVnode不存在，重新构建vm.$el = vm.__patch__(vm.$el, vnode, hydrating),否则在上个vnode基础上打补丁vm.$el = vm.__patch__(prevVnode, vnode),__patch__方法在src\\entries\\web-runtime.js加载，非服务端会调用patch方法，该步骤使用虚拟DOM算法来更新真实DOM或重新生成真实DOM。 恢复activeInstanceactiveInstance = prevActiveInstance 更新__vue__引用：prevEl存在，prevEl.__vue__ = null;vm.$el存在，·vm.$el.__vue__ = vm,将vm实例引用赋予vue属性。 父亲若为HOC，则也更新父亲的$el。HOC:Higher order components .一个向已存在的组件添加功能的函数。if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) { vm.$parent.$el = vm.$el} _isMounted若已为true(根节点在此之前即为true，子节点会在渲染的过程中变为true)，使用callHook执行updated钩子。 Vue.prototype._updateFromParent根据新的vnode传入的参数更新组件实例,在vnode的_update过程中，通过默认的prepatch钩子调用。参数： propsData: ?Object, // vnode.componentOptions.propsData listeners: ?Object, // vnode.componentOptions.listeners parentVnode: VNode, // vnode renderChildren: ?VNodeChildren //vnode.componentOptions.children const vm: Component = this;const hasChildren = !!(vm.$options._renderChildren || renderChildren) 更新option的_parentVnode和_renderChildren：vm.$options._parentVnode = parentVnode;vm.$options._renderChildren = renderChildren 更新props：propsData并且vm.$options.props存在，observerState.shouldConvert = false，从而在vm[key]赋值时，如果这个key上本来没有贯彻者，则不会再建立观测者。非生产环境下，observerState.isSettingProps = true// TODO 遍历vm.$options._propKeys ，调用validateProp生成新值并挂载到vm上。observerState.shouldConvert = true 非生产环境下，observerState.isSettingProps = false 新listeners存在，将新listeners赋予vm.$options._parentListeners，调用原型方法_updateListeners更新listeners hasChildren存在，调用resolveSlots，处理renderChildren，并挂载到vm.$slots。然后执行$forceUpdate，该操作会执行该组件的_update,从而和上层组件的_update形成递归，不断执行子组件实例的_update，注意子组件实例_update，render出的vnode是子组件的根vnode（tag名称是子组件模板最上层标签，如div），和上层组件vnode中的组件vnode（tag名称为vue-component…）已不是同一个组件,所以这并不是一个死循环，而是向后代组件的递归遍历。 Vue.prototype.$forceUpdate强制更新 Vue.prototype.$forceUpdate = function () { const vm: Component = this if (vm._watcher) { vm._watcher.update() } } Vue.prototype.$destroy 7.4.4.3. callHook执行$options上挂载的钩子数组中的所有handler。 export function callHook (vm: Component, hook: string) { const handlers = vm.$options[hook] if (handlers) { for (let i = 0, j = handlers.length; i &lt; j; i++) { handlers[i].call(vm) } } vm.$emit('hook:' + hook) }7.4.5. render.js7.4.5.1. initRender1. vm.$vnode = null // the placeholder node in parent tree vm._vnode = null // the root of the child tree vm._staticTrees = null vm._renderContext = vm.$options._parentVnode &amp;&amp; vm.$options._parentVnode.context 使用resolveSlots将$options._renderChildren按照slot分类并挂载到vm.$slots。 将公共createElement方法注入vm实例，并挂载到vm.$createElement $options.el存在，vm.$mount(vm.$options.el) $mount为封装的Vue.prototype._mount原型方法，定义在lifecycleMixin中。 7.4.5.2. resolveSlots参数： renderChildren: ?VNodeChildren, context: ?Component返回值：{ [key: string]: Array&lt;VNode&gt; }将renderChildren标准化处理后，按照slot分类，并返回分类对象。 const slots = {}，作为结果，在处理完成后返回slots。 const children = normalizeChildren(renderChildren) || [] 调用normalizeChildren将renderChildren转为vnode对象的数组，并存于children。 遍历children中每一个vnode对象child 若child的context属性和传入的context相同（context即是父组件预留的插槽名称），并且child的data属性、data属性的slot属性存在，则把slot属性值赋予name变量，搜索slots中对应name变量的属性值，若不存在，则置为空数组，该属性值引用设为slot，如果child的tag属性值为’template’，则将child的children压入slot，否则将child本身压入slot。 若不满足上面的条件，则将child压入defaultSlot 若defaultSlot中存在元素，且不是一个空白元素，slots.default = defaultSlot 7.4.5.3. renderMixin Vue.prototype._render const { render, staticRenderFns, _parentVnode } = vm.$options 解构$options取render，staticRenderFns，_parentVnode vm._isMounted为true，将$slots（initRender进行的初始化）中每一个属性进行通过cloneVNodes克隆，并重新挂载到$slots上面。 if (staticRenderFns &amp;&amp; !vm._staticTrees) { vm._staticTrees = [] } vm.$vnode = _parentVnode vnode = render.call(vm._renderProxy, vm.$createElement),将vm._renderProxy注入render函数作为this，$createElement（initRender中定义）作为参数，执行render函数。_renderProxy在initMixin中定义，若为生产环境，则其就是vm。 vnode不是VNode的实例，非生产环境下提示’Multiple root nodes returned from render function. Render function should return a single root node.’ vnode.parent = _parentVnode 返回vnode 7.4.6. state.js7.4.6.1. initStatestate.js定义，从observer文件夹中引入set,del,observe,defineReactive,observerState,重置_watchers属性为空数组，并执行Props,Data,Computed,Methods,Watch的初始化函数initPropsinitDatainitComputedinitMethodsinitWatch export function initState (vm: Component) { vm._watchers = [] initProps(vm) initData(vm) initComputed(vm) initMethods(vm) initWatch(vm) }7.4.6.2. initProps处理$options上传入的prop相关，使其加载到vm实例上。 在$options上取props、propsData。observerState.shouldConvert = isRoot如果不是根组件，该prop的值上就不建立观测者 const keys = vm.$options._propKeys = Object.keys(props) 遍历keys，生产环境：defineReactive(vm, key, validateProp(key, props, propsData, vm))，该属性添加观测者，其本身及后代都会转化为getter，setter 若非生产环境，且vm.$parent &amp;&amp; !observerState.isSettingProps(isSettingProps默认为false), 则通过传入defineReactive 的customSetter提示警告：不要改变prop的值，因为该组件有父组件, 父组件重新渲染会重写prop，所以应该是用该prop上的data和计算属性。 observerState.shouldConvert = true 7.4.6.3. initData 取$options.data为data，若为function，则绑定vm为this，执行后置为data，并绑定在vm._data。 data不是PlainObject，提示’data functions should return an object.’ const keys = Object.keys(data);const props = vm.$options.props,遍历keys，若props上已存在该key，则提示使用prop default value而不是data 若props上无该key，则使用proxy，定义vm[key]的get，set，在vm._data上存取该属性。 observe(data)为data设立观测者，data的属性及其后代则都会被转化getter，setter data.__ob__ &amp;&amp; data.__ob__.vmCount++使观测者vmCount+1 7.4.6.4. initComputed在模块内预定义： const computedSharedDefinition = { enumerable: true, configurable: true, get: noop, set: noop } 取$options.computed为computed computed存在，则遍历computed属性 若属性值的类型为function，调用makeComputedGetter传入该属性值，加工后作为get，set为noop（空函数） 若属性值的类型不是function：该值不存在get属性，则get和set都设为noop 若属性值的类型不是function：该值存在get：属性值上未声明cache为false，调用makeComputedGetter传入属性值的get返回getter，否则直接将vm注入get方法中，并返回新的函数作为get。若存在set属性，同样注入vm后作为新set，否则置为noop。 将修改后的computedSharedDefinition作为新的属性值绑定在vm上。 7.4.6.5. makeComputedGetter传入参数：getter: Function, owner: Component该函数加工getter，返回一个新的函数作为getter 在该属性上建立watcher钩子const watcher = new Watcher(owner, getter, noop, {lazy: true}) 新getter函数内：watcher.dirty为true，则执行watcher.evaluate(),该watcher因为定义时传入lazy:true,所以dirty默认为true,在执行evaluate后会置为false。 新getter函数内：若Dep.target存在，即是某个watcher在初始化或运行时需要读取该computed值，则调用watcher.depend()，使第1步建立的闭包watcher收集的所有deps对象（evaluate时通过遍历后代触发getter收集的）都监听该watcher（Dep.target也会收集到该闭包watcher的deps）。从而deps中的对象notify时（原getter指向的vm中data或props某个属性变化时），会同时执行该watcher及闭包watcher。 返回watcher.value，watcher.value在evaluate时，被赋予原始getter的执行结果。 7.4.6.6. initMethods const methods = vm.$options.methods methods存在，则遍历它的属性值，不为null，则直接注入vm为this，把返回的新的函数，使用原key绑定在vm上function initMethods (vm: Component) { const methods = vm.$options.methods if (methods) { for (const key in methods) { if (methods[key] != null) { vm[key] = bind(methods[key], vm) } else if (process.env.NODE_ENV !== 'production') { warn(`Method \"${key}\" is undefined in options.`, vm) } } } } 7.4.6.7. initWatch const watch = vm.$options.watch 遍历watch的每个属性，若为数组，则展开，分别传入createWatcher函数function createWatcher (vm: Component, key: string, handler: any) { let options if (isPlainObject(handler)) { options = handler handler = handler.handler } if (typeof handler === 'string') { handler = vm[handler] } vm.$watch(key, handler, options) } 7.4.6.8. Vue.prototype.$watch使用传入的expOrFn和cb建立一个闭包watcher对象，若options.immediate为true，则立即执行回调 Vue.prototype.$watch = function ( expOrFn: string | Function, cb: Function, options?: Object ): Function { const vm: Component = this options = options || {} options.user = true const watcher = new Watcher(vm, expOrFn, cb, options) if (options.immediate) { cb.call(vm, watcher.value) } return function unwatchFn () { watcher.teardown() } }7.5. observer7.5.1. array.js预先准备arrayMethods对象，根据Array原型重定义push、unshift、splice方法，当这些方法造成元素增减时，通过第1步定义的__ob__属性取得observer对象并调用observeArray方法，该原型方法将对数组中每个元素执行observe函数，若元素上没有观测者对象，则会递归建立（防止新增元素没有对应的observer对象），然后执行ob.dep.notify()，触发dep的subs中每个watcher对象的update方法。 7.5.2. index.js7.5.2.1. Observer类在传入value上面建立观测者对象 7.5.2.1.1. 实例属性保存其附加到的value，内部保存一个dep对象，这样调用dep.notify()，则可触发dep对象subs数组中所有watcher对象的update方法，从而完成回调。 this.value = value this.dep = new Dep() this.vmCount = 07.5.2.1.2. 初始化 将observer对象作为value的__ob__属性。 若value为数组：取得在array.js中导出的arrayMethods对象，在模块内而后通过hasProto方法检查value的proto属性是否存在，若存在，则将arrayMethods对象直接赋为value的proto，否则，将arrayMethods的属性复制到value上，从而实现数组增减的监听。然后调用observeArray方法，对数组中每个元素执行observe函数，若元素上没有观测者对象，则会递归建立。 若value不是数组，则执行walk方法，对value上的每个属性都执行defineReactive函数， 这样将由defineReactive为入口形成递归，无论初始的value为数组还是对象，只要其属性或子元素是object，都会执行defineReactive，从而添加监听的getter，setter 7.5.2.2. observe尝试为一个值建立一个observer实例或是或者直接返回一个已经存在的observer。注意该函数将会在传入值上通过new Observer递归建立观测者，在其属性及属性后代上使用getter，setter监听。传入值value若不是object则直接返回，若value存在__ob__属性并且__ob__为Observer实例，则返回__ob__。否则判断value是否合法，合法则返回new Observer(value)。判断value是否合法： observerState.shouldConvert为true config._isServer为false value为数组或plainObject Object.isExtensible(value)为true value不是vue实例（通过value._isVue判断） 7.5.2.3. defineReactive传入参数： obj: Object, key: string, val: any, customSetter?: Function内部新建dep对象内部通过observe得到val的observer对象childOb通过Object.getOwnPropertyDescriptor得到参数对象obj上该属性的描述，如果configurable为false则直接return重定义对象obj上的属性的get,set方法 7.5.2.3.1. get 若存在原始的get方法，则执行get方法得到value，否则直接把原始的val赋为value。 如果存在Dep.target， 则执行dep.depend()。如果同时childOb存在，则执行childOb.dep.depend()，主要作用是将Dep.target加入dep对象的subs数组中。若同时value为数组，则触发其每个元素observer对象的depend方法。在每个watcher对象初始化时会将自己置为Dep.target，然后通过get调用这步，从而使得闭包dep的subs中包含该watcher对象。 返回value。 7.5.2.3.2. set 若存在原始的get方法，则执行get方法得到value，否则直接把原始的val赋为value，比较value和newVal，相同则直接返回。 若非生产环境， customSetter存在则执行customSetter 原始setter存在则执行原始setter 对新值newVal建立观测者对象childOb = observe(newVal) 执行闭包中dep的notify方法，触发其中的watcher update，从而执行回调。这样就实现了，该属性值变化时，执行预先加入dep中的watcher 7.5.3. scheduler.jsconst queue: Array&lt;Watcher&gt; = [] let has: { [key: number]: ?true } = {} let circular: { [key: number]: number } = {} let waiting = false let flushing = false let index = 0该模块定义静态watcher对象数组queue ，waiting作为flag，控制是否将flushSchedulerQueue加入异步调度，flushing则判断是否queue正在执行，has记录已加入队列但尚未执行的watcher，circular记录每个watcher 运行的次数 7.5.3.1. flushSchedulerQueue置flushing为true，开始处理队列 对queue中的watcher对象按照id从小到大排序，这样组件会从父到子更新，用户watcher先于render watcher，父组件watcher运行时将子组件销毁，则子组件watcher可被跳过。 将queue中的watcher对象执行watcher.run()，注意每次循环会重取queue.length，从而执行新加入的对象 若非生产环境，则使用circular[id]记录每个watcher 运行的次数，若执行次数过多，大于（config._maxUpdateCount），且在执行时不断加入队列（has判断）,则提示检查是否为死循环。 执行resetSchedulerState 7.5.3.2. resetSchedulerState清空queue，has,circular,置waiting及flushing为false 7.5.3.3. queueWatcher通过flushing判断，如果flushSchedulerQueue正在处理queue，则将watcher对象插入queue的已排序位置，否则直接压入最后，因为flushSchedulerQueue自然会进行排序。如果waiting为false，表示尚未将flushSchedulerQueue加入异步调度，则使用nextTick将其加入。 7.5.4. watcher.js定义Watcher类，转化表达式，集合依赖，当表达式的值变化时，则执行回调构造函数传入： vm: Component, expOrFn: string | Function, cb: Function, options?: Object = {}expOrFn为指向被监视对象的路径或是函数，但都是表示找到被监视对象的方法。被监视对象必须为已转化getter，setter的对象（props或data），这样执行get方法时，才能将当前watcher加入到其闭包dep的监听数组中，从而实现调用setter时执行cb。注意无需把监视对象返回，只要expOrFn中读取了该对象，即会被该对象的闭包dep捕获（lazy为true时不会被在初始化阶段捕获） 7.5.4.1. 初始化以下剖析watcher对象上的各属性的初始化： this.getter若expOrFn为函数，则将其直接赋为实例的getter，否则通过parsePath得到一个获取对象路径的函数赋与this.getter，如果表达式中包含.$或不是字符串，则getter的赋值将失败，此时将getter赋为空函数，并且若process.env.NODE_ENV不是production，则提示警告：Failed watching path: &quot;${expOrFn}&quot; Watcher only accepts simple dot-delimited paths. or full control, use a function instead.该方法执行时会触发defineReactive定义的参数obj属性路径path下的get方法，这样该属性绑定的闭包dep、属性val的__ob__.dep、若是数组则包含数组元素的dep,都将执行depend方法，监听本watcher，本watcher也将收集这些dep对象存于deps。这样，当按照expOrFnobj得到的属性val变动时，将触发闭包dep的notify方法，从而执行本watcher对象的update。 this.value this.value = this.lazy ? undefined : this.get()lazy为false或未定义，则会执行this.get()，这个方法将触发this.getter，达到监听属性变化的目的。 7.5.4.2. 原型方法7.5.4.2.1. update在dep实例的notify方法中会触发subs数组中watcher对象的update方法 if (this.lazy) { this.dirty = true } else if (this.sync) { this.run() } else { queueWatcher(this) }queueWatcher会将watcher对象加入异步队列，延迟调用run方法。 7.5.4.2.2. runthis.active为true方可执行该方法。 通过this.get()取得value value !== this.value ||isObject(value) || this.deep为true则继续执行 执行回调this.cb.call(this.vm, value, oldValue) 7.5.4.2.3. get 通过pushTarget将watcher对象设为Dep.target 调用this.getter，this绑定当前实例，并传入当前实例作为参数 如果deep为true，执行traverse(value) 通过popTarget，将压入targetStack中的旧watcher对象取出，并恢复为Dep.target 执行this.cleanupDeps() 返回2中得到的value 7.5.4.2.4. addDep当本watcher对象变为Dep.target时，将由dep对象的depend方法触发。共有4个实例属性与此相关： deps: Array&lt;Dep&gt;; // 旧依赖数组 newDeps: Array&lt;Dep&gt;; // 新依赖数组 depIds: Set; // 旧依赖Ids newDepIds: Set; // 新依赖Ids该方法传入1个Dep实例dep，如果newDepIds无此id，则实例压入newDeps，id压入newDepIds，若旧ids中无此id，则执行dep.addSub(this)，将watcher对象加入dep的subs数组中 7.5.4.2.5. cleanupDeps 遍历deps中每个dep 的id，若this.newDepIds不复存在id，则执行dep.removeSub(this),这样dep再notify时将不会执行本watcher的callback。 将newDeps及newDepIds分别赋与deps及depIds，然后置空newDeps及newDepIds。 这样由update/run/get触发的traverse方法收集到的dep对象全部转入deps，并清除了旧deps内的dep对象对本watcher的引用（移出subs数组） 7.5.4.2.6. dependdepend () { let i = this.deps.length while (i--) { this.deps[i].depend() } }7.5.4.3. Helper7.5.4.3.1. traverse传入val，读取val.__ob__.dep.id，并保存于模块定义 的seenObjects中（Set，非重复），递归读取val的每个属性或数组元素，执行同样操作。由于存在__ob__,在读取val属性的时候会执行defineReactive定义的get方法，进而执行：defineReactive函数闭包中的dep对象、val.ob.dep，若val为数组，则还有数组元素__ob__的dep，以上dep对象的depend方法，确保Dep.target(watcher对象)在subs数组中，dep对象出现在watcher对象的newDeps数组中。这样，当任何这些属性变化时，将触发对应闭包的dep对象的notify方法，执行当前watcher的update。 7.5.5. dep.js定义Dep类，初始化时this.id为模块保存的uid+1，this.subs为watcher对象的数组，初始化时置为空数组。 7.5.5.1. Dep.targetDep.target的类型为Watcher，默认为null，只有dep.js中pushTarget可以设置该值，pushTarget函数仅被watcher对象的get方法调用。而get方法设置Dep.target的目的是为了deep为true时，可以在属性及属性的后代上递归建立observer并通过get，set监听后代变化，后代变化时即可调用该watcher。 Dep.target为某个watcher对象时仅限以下场景： 某个非lazy的watcher初始化时 watcher对象执行run方法（准备执行回调钩子时） lazy watcher执行evaluate时。 用到Dep.target的场景： dep.depend -&gt; Dep.target.addDep,而调用dep.depend()即为以上Dep.target存在值的场景 以上场景中读取了computed属性，则Dep.target会被加入到computed属性getter闭包中watcher对象所收集的Dep对象的监听数组（subs）中。也就是说，某个watcher执行时需要读取某个computed属性，那么这个watcher会在computed属性改变时一同执行。 7.5.6. addSubaddSub (sub: Watcher) { this.subs.push(sub) }7.5.7. removeSubremoveSub (sub: Watcher) { remove(this.subs, sub) }remove 7.5.8. notify将this.subs中每个watcher对象执行update方法 7.5.9. depend如果Dep.target(watcher对象)存在，调用target的addDep方法，并将Dep实例this传入,该方法将会确保dep对象出现在watcher对象的newDeps数组中，dep id在newDepIds中，且watcher对象在subs数组中。 7.5.10. 静态属性方法Dep类的静态属性target为watcher对象，开始置为null。此外该模块还设置const targetStack = [] 7.5.10.1. pushTarget传入watcher对象_target if (Dep.target) targetStack.push(Dep.target) Dep.target = _target7.5.10.2. pushTarget Dep.target = targetStack.pop()7.6. util工具类7.6.1. debug.js7.6.1.1. formatComponentName获取vm实例的名字，如果$root属性等于自身，则返回’root instance’，否则按以下顺序取名字：$options.name，$options._componentTag，name，’anonymous component’ 7.6.1.2. formatLocation如果名字为’anonymous component’，则提示- use the &quot;name&quot; option for better debugging messages. 7.6.1.3. warn如果console存在并且没有设置silent模式，则打印传入的警告信息及vm实例的位置 7.6.2. shared/util.js7.6.2.1. bind仅用于返回一个新函数并绑定传入的this，通过判断参数数量，从而比原生的快 7.6.2.2. isObjectexport function isObject (obj: mixed): boolean { return obj !== null &amp;&amp; typeof obj === 'object' }7.6.2.3. isPlainObjectconst toString = Object.prototype.toString const OBJECT_STRING = '[object Object]' export function isPlainObject (obj: any): boolean { return toString.call(obj) === OBJECT_STRING }7.6.2.4. isPrimitiveexport function isPrimitive (value: any): boolean { return typeof value === 'string' || typeof value === 'number' }7.6.2.5. removeexport function remove (arr: Array&lt;any&gt;, item: any): Array&lt;any&gt; | void { if (arr.length) { const index = arr.indexOf(item) if (index &gt; -1) { return arr.splice(index, 1) } } }7.6.2.6. hasOwnconst hasOwnProperty = Object.prototype.hasOwnProperty export function hasOwn (obj: Object, key: string): boolean { return hasOwnProperty.call(obj, key) }7.6.2.7. camelize将连字符变为驼峰形式 const camelizeRE = /-(\\w)/g export const camelize = cached((str: string): string =&gt; { return str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : '') })7.6.2.8. capitalize将字符串的首字母大写 export const capitalize = cached((str: string): string =&gt; { return str.charAt(0).toUpperCase() + str.slice(1) })7.6.2.9. hyphenate将驼峰转化为连字符,最多接受两个驼峰 const hyphenateRE = /([^-])([A-Z])/g export const hyphenate = cached((str: string): string =&gt; { return str .replace(hyphenateRE, '$1-$2') .replace(hyphenateRE, '$1-$2') .toLowerCase() })7.6.2.10. cached闭包缓存 export function cached (fn: Function): Function { const cache = Object.create(null) return function cachedFn (str: string): any { const hit = cache[str] return hit || (cache[str] = fn(str)) } }7.6.3. lang.js7.6.3.1. parsePath传入路径path，若其中包含*.$则直接返回，否则返回一个函数，传入obj，返回obj根据path路径得到的值 const bailRE = /[^\\w\\.\\$]/ export function parsePath (path: string): any { if (bailRE.test(path)) { return } else { const segments = path.split('.') return function (obj) { for (let i = 0; i &lt; segments.length; i++) { if (!obj) return obj = obj[segments[i]] } return obj } } }7.6.3.2. defexport function def (obj: Object, key: string, val: any, enumerable?: boolean) { Object.defineProperty(obj, key, { value: val, enumerable: !!enumerable, writable: true, configurable: true }) }7.6.4. env.js7.6.4.1. nextTick 定义nextTickHandler，执行内部callbacks中的所有任务。 定义timerFunc，若Promise存在使用Promise.resolve().then(nextTickHandler). 否则使用MutationObserver 否则使用setTimeout使用pending作为flag，若true，则直接把任务加入callbacks即可，因为正在执行，否则触发timerFunc 7.6.4.2. hasProto// can we use __proto__? export const hasProto = '__proto__' in {}7.6.5. options.js7.6.5.1. mergeOptions参数： parent: Object, child: Object, vm?: Component7.6.5.2. resolveAsset处理assets，assets包括directives，components，transitions，filters该函数仅仅是从传入的options中按照type和id取得asset并返回参数： options: Object, type: string, id: string, warnMissing?: boolean 判断options[type][id]是否存在，若不存在,将id使用camelize变为驼峰形式，再次尝试 若仍未找到，使用capitalize将驼峰形式id首字母大写，再次尝试寻找。 找到返回。未找到且在非生产环境，提示：Failed to resolve …. 7.6.6. props.js7.6.6.1. validateProp参数： key: string, propOptions: Object, propsData: Object, vm?: ComponentpropOptions: $options.props 一般形式： { key1 : { type: Number, default: 100 } }注意type为构造函数而非字符串 const prop = propOptions[key];const absent = !hasOwn(propsData, key);let value = propsData[key] 检查getType(prop.type)，若为Boolean：若propsData无此key，且prop无该key的默认值(default属性)，则value = false;若value为’’或value为key的连字符形式，则value = true value仍为undefined，value = getPropDefaultValue(vm, prop, key)因为默认值是函数，value为函数计算的结果，所以是一个新值，所以暂时置observerState.shouldConvert为true，然后observe(value),为这个新值添加观测者,它的属性都会转化getter，setter。observe 如果非生产环境，执行assertProp // TODO 返回value。 7.6.6.2. getPropDefaultValue参数：vm: ?Component, prop: PropOptions, name: string prop没有default属性，直接返回undefined def = prop.default为object，且在非生产环境下，警告不要使用Object/Array，而要使用一个工厂函数返回默认值。 若prop.default为function，判断prop.type，为Function直接返回默认值，不是则返回def.call(vm) 7.6.6.3. getTypefunction getType (fn) { const match = fn &amp;&amp; fn.toString().match(/^\\s*function (\\w+)/) return match &amp;&amp; match[1] }7.6.6.4. assertProp7.7. vdom7.7.1. create-element.js7.7.1.1. createElement检查data，调用_createElement并返回结果，返回结果为vnode对象 7.7.1.2. _createElement参数： context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: VNodeChildren | void 传入的data上有__ob__属性，非生产环境下提示：Avoid using observed data object as vnode data Always create fresh vnode data objects in each render!，并直接返回。 tag不存在，返回空节点emptyVNode。 tag若为字符串: const ns = config.getTagNamespace(tag)getTagNamespace仅仅识别MathML和svg元素，若是一般元素，则返回undefined tag若是保留标签（html或svg标签）return new VNode(tag, data, normalizeChildren(children, ns),undefined, undefined, ns,context) 若tag不是保留标签，调用resolveAsset,尝试寻找$options.components[tag],即寻找该tag所代表的组件asset，赋予Ctor，然后调用createComponent返回createComponent(Ctor, data, context, children, tag)。 若tag既不是保留标签，也找不到对应的组件的asset，则有可能是未知命名空间的奇怪元素，同第2步，直接构造VNode返回，在运行时再尝试解析 tag不为字符串，直接构造组件，调用createComponent(tag, data, context, children)并返回。 7.7.2. create-component.js7.7.2.1. createComponent参数： Ctor: Class&lt;Component&gt; | Function | Object | void, data?: VNodeData, context: Component, children?: VNodeChildren, tag?: string 不存在Ctor，直接返回。 Ctor为对象，调用Vue.extend（在initExtend中定义），以Ctor为extendOption创建Vue的子类，并覆盖Ctor 经过以上两步，Ctor的类型只可能是function，即组件类或异步组件的工厂函数，若类型不是function，在非生产环境下提示’Invalid Component definition’ 如果Ctor.cid不存在，说明其为异步组件，若其resolved属性存在，Ctor = Ctor.resolved,否则，调用resolveAsyncComponent 调用extractProps提取props，存于propsData，为构建vnode准备。 如果该子组件为函数式组件（Ctor.options.functional为true），调用createFunctionalComponent并返回。参照：https://github.com/vuejs/vue/releases/tag/v2.0.0-alpha.5 const listeners = data.on;data.on = data.nativeOn // TODO Ctor.options.abstract为true，则组件为抽象组件，除了props &amp; listeners外都不保，所以data = {} mergeHooks(data) 调用mergeHooks,补充可能缺少的钩子 构造vnode： tag：vue-component-${Ctor.cid}${name ?-${name}: &#39;&#39;} data: data children: undefined text: undefined elm： undefined ns： undefined context： context componentOptions：{ Ctor, propsData, listeners, tag, children } 返回构造的vnode 7.7.2.2. mergeHooks参数： data: VNodeData data.hook不存在，则置为{} 在create-component.js模块已预先定义const hooks = { init, prepatch, insert, destroy } const hooksToMerge = Object.keys(hooks)init, prepatch, insert, destroy为已经定义好的钩子。遍历hooksToMerge，键值为(key,ours) data.hook[key]存在，调用mergeHook，传入ours, fromParent，得到的函数赋予data.hook[key]； 否则直接把模块中预定义的ours赋予data.hook[key]。 7.7.2.3. mergeHookfunction mergeHook (a: Function, b: Function): Function { // since all hooks have at most two args, use fixed args // to avoid having to use fn.apply(). return (_, __) =&gt; { a(_, __) b(_, __) } }7.7.2.4. hook.prepatch参数： oldVnode: MountedComponentVNode, vnode: MountedComponentVNode 先将旧vnode的组件实例赋予新的vnode：const child = vnode.child = oldVnode.child 调用child的原型方法_updateFromParent，传入vnode.componentOptions相关参数，这样就更新了组件实例。 7.7.2.5. hook.init参数： vnode: VNodeWithData, hydrating: boolean 调用createComponentInstanceForVnode生成组件vm实例并挂载至vnode.child child.$mount(hydrating ? vnode.elm : undefined, hydrating) 这个会调用子组件的_mount,形成递归，完成子组件的后代组件的渲染和监控。 这个钩子在patch -&gt; createElm中的调用，所以一个vm实例中的组件是在其patch的时候才会递归渲染，在render函数执行后，子组件的vnode只是一个空壳，其生成实例后，才会挂载到vnode.child，注意实例内部也有自己的根vnode，和上层子组件的vnode并不是一个。 7.7.2.6. createComponentInstanceForVnode在init钩子中调用，通过vnode构造组件参数： vnode: any, // we know it's MountedComponentVNode but flow doesn't parent: any // activeInstance in lifecycle state 处理options const vnodeComponentOptions = vnode.componentOptions const options: InternalComponentOptions = { \\_isComponent: true, parent, propsData: vnodeComponentOptions.propsData, \\_componentTag: vnodeComponentOptions.tag, \\_parentVnode: vnode, \\_parentListeners: vnodeComponentOptions.listeners, \\_renderChildren: vnodeComponentOptions.children } // check inline-template render functions const inlineTemplate = vnode.data.inlineTemplate if (inlineTemplate) { options.render = inlineTemplate.render options.staticRenderFns = inlineTemplate.staticRenderFns } 通过组件类来构造组件return new vnodeComponentOptions.Ctor(options) 7.7.2.7. createFunctionalComponent参数： Ctor: Class&lt;Component&gt;, propsData: ?Object, data: VNodeData, context: Component, children?: VNodeChildren返回：VNode | void 遍历Ctor.options.props，调用validateProp验证每个prop，并转每个prop属性的getter setter 执行Ctor.options.render，this绑定null，传入的参数createElement为绑定this为Object.create(context)的createElement，render的第二个参数为：{ props, data, parent: context, children: normalizeChildren(children), slots: () =&gt; resolveSlots(children, context)} 返回render执行后得到的vnode 7.7.2.8. extractProps遍历子组件类的props，按照其中的key，从父组件vnode中提取数据并返回。注意这里仅仅是提取数据，默认值处理及数据验证将在子组件自己那里进行。参数： data: VNodeData, Ctor: Class&lt;Component&gt; 取Ctor.options.props为propOptions，不存在则直接返回。 将data解构为attrs, props, domProps，如果三者中有任何一个存在，则遍历propOptions。 调用checkProp, 按照props，attrs，domProps顺序将propOptions中对应的key提取，并组成对象res 返回res 7.7.3. checkProp参数： res: Object, hash: ?Object, key: string, altKey: string, preserve?: boolean返回：boolean if (hash) { if (hasOwn(hash, key)) { res[key] = hash[key] if (!preserve) { delete hash[key] } return true } else if (hasOwn(hash, altKey)) { res[key] = hash[altKey] if (!preserve) { delete hash[altKey] } return true } } return false7.7.3.1. resolveAsyncComponent处理异步组件。参数： factory: Function, cb: Function返回Class&lt;Component&gt;// TODO 7.7.4. helpers.js7.7.4.1. updateListeners 共传入4个参数: on: Object, // 新的监听键值对 oldOn: Object, // 旧的监听键值对 add: Function, // 添加事件监听的方法 remove: Function // 移除事件监听的方法 on及oldOn的一般形式： 'event_name': { fn: handler invoker: (...args) =&gt; { handler.apply(null,args)} } } 或 { 'event_name': [...handlers] } 或 { 'event_name': handler } 遍历on中的所有name，cur = on[name];old = oldOn[name]，若cur不存在，且在非生产环境下，则Handler for event &quot;${name}&quot; is undefined. old不存在，即原监听事件不存在：capture = name.charAt(0) === &#39;!&#39;;event = capture ? name.slice(1) : name。 若cur为数组，即如上例中第二种形式，则调用arrInvoker，合并handler，挂载到cur.invoker，并执行add。add(event, (cur.invoker = arrInvoker(cur)), capture) cur不是数组，但其上invoker属性不存在,则其为上例中第三种形式，这时fn = cur;cur = on[name] = {};cur.fn = fn;cur.invoker = fnInvoker(cur),fnInvoker仅仅是包装一层，判断参数数量，优化速度。 old存在，且cur !== old，使用cur覆盖old中存在的任何东西，而后on[name] = old 检测oldOn中存在，但on中已经不存在的name, 调用remove。 7.7.4.2. arrInvoker 接受一个handler组成的数组：arr: Array&lt;Function&gt; 返回一个新的handler函数，该函数接受事件ev，遍历arr中的所有handler，若ev只有一个，则arr[i](ev) 否则 arr[i].apply(null, arguments),即是合并handlers后返回一个新的handler 7.7.4.3. fnInvoker 接受一个handler：o: { fn: Function } return function (ev) { const single = arguments.length === 1 single ? o.fn(ev) : o.fn.apply(null, arguments) }7.7.4.4. normalizeChildren参数： children: any, ns: string | void, nestedIndex: number | void返回值：Array&lt;VNode&gt; | void if (isPrimitive(children)) { return [createTextVNode(children)] } isPrimitive判断children是否为基本类型（number和string），返回[createTextVNode(children)] 若children为数组，遍历它每个元素，在此之前创建空数组res保存处理结果，在进行如下处理后，将res返回。 若元素val仍为数组，则递归调用normalizeChildren。 否则，若val为基本类型，则检测res最后一个元素，若其存在，并且有text属性（为文本节点），则直接把val转化为字符串并追加到text属性后面。最后一个元素不存在，或不是文本节点，则使用createTextVNode创建文本节点并加入到res中。 若元素val为VNode对象， 先判断它是否为文本节点，若其实文本节点，且res中最后一个也是文本节点，则把它合并到res最后一个元素上。 若val非文本节点，进行如下操作后，将其加入res中: 检查第二个参数ns是否存在，若存在，则使用applyNS设置命名空间 设置默认key // default key for nested array children (likely generated by v-for) if (c.tag && c.key == null && nestedIndex != null) { c.key = `__vlist_${nestedIndex}_${i}__` } 7.7.4.5. createTextVNode接受一个字符串，包装为vnode对象并返回。 function createTextVNode (val) { return new VNode(undefined, undefined, undefined, String(val)) }7.7.4.6. applyNS若节点不存在命名空间，则把它及它的所有子节点的命名空间置为传入的ns。 function applyNS (vnode, ns) { if (vnode.tag &amp;&amp; !vnode.ns) { vnode.ns = ns if (vnode.children) { for (let i = 0, l = vnode.children.length; i &lt; l; i++) { applyNS(vnode.children[i], ns) } } } }7.7.5. patch.js通过工厂createPatchFunction构建并返回patch函数cbs为闭包变量，一般形式为 { create: [function updateAttrs(oldVnode,vnode){…}, function updateClass (){…} …], update: […], postpatch: […], remove: […], destroy: […] } 这些数组中的函数，若是浏览器端，则取自/platforms/web/runtime/modules 因为服务器渲染和web渲染并不相同 7.7.5.1. patchconst insertedVnodeQueue = []参数：oldVnode, vnode, hydrating, removeOnly oldVnode不存在，调用createElm渲染新的根元素createElm(vnode, insertedVnodeQueue) oldVnode存在： 判断oldVnode.nodeType是否存在，nodeType存在表示为真实元素（Vnode上无nodeType属性） 不是真实元素(为虚拟元素)，并调用sameVnode判断Vnode是相同的（除了data可能不同）：调用patchVnode处理//TODO 7.7.5.2. patchVnode 参数： oldVnode, vnode, insertedVnodeQueue, removeOnly oldVnode === vnode，引用地址都相同，还更新个啥，直接返回 新旧vnode都是静态的，且key相同，新vnode的isCloned为true，则无需渲染，直接vnode.elm = oldVnode.elm 如果vnode.data.hook.prepatch存在（正常情况下，会在第一次渲染时采用create-component.js中的prepatch,执行完后，组件实例和组件实例的后代都会被递归更新） const elm = vnode.elm = oldVnode.elm 直接把旧vnode上已渲染好的DOM赋予vnode.elm vnode.data存在并且vnode可修补（调用isPatchable检查），则遍历cbs.update，（cbs为闭包变量，直接操作DOM）。执行cbs.update中的每个回调，vnode.data.hook.update存在，则也执行这个钩子。至此真实DOM通过cbs.update更新完成。 const oldCh = oldVnode.children;const ch = vnode.children vnode.text不存在，说明其不是文本节点： oldCh和ch都存在，且不相同，调用updateChildren递归更新子节点 ch存在，oldCh不存在，调用addVnodes插入子级DOM 7.7.5.3. updateChildren定义各种flag： let oldStartIdx = 0 let newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx, idxInOld, elmToMove, beforepaichuoldStartIdx -&gt; oldEndIdx newStartIdx -&gt; newEndIdx 这四个flag，各自不断向中间接近，直到重合，分别取有值的位置为oldStartVnode， oldEndVnode， newStartVnode， newEndVnode： sameVnode(oldStartVnode, newStartVnode) -&gt; patchVnode递归更新 oldStartVnode, newStartVnode已不再相同：sameVnode(oldEndVnode, newEndVnode) -&gt; patchVnode递归更新 两个头部和尾部都已不是相同类型vnode：但sameVnode(oldStartVnode, newEndVnode)，这时说明是oldStartVnode的这个vnode向右移动了位置，同样调用patchVnode递归更新,然后nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)),这样直接操作DOM实施这一过程。 以上情况都排除，但sameVnode(oldEndVnode, newStartVnode) 说明oldEndVnode左移了，同样调用patchVnode递归更新,然后nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)操作该vnode对应的DOM左移 以上情况都排除：通过比较key来找出已乱序的children，注意key若非在render函数中声明，则是在[normalizeChildren](#normalizeChildren中定义的，格式为：\\_\\_vlist${nestedIndex}\\_${i}\\_\\_ newStartVnode.key在剩余old队列vnode中不存在，则说明是新值的元素，直接建立并插入到oldStartVnode.elm前面。 newStartVnode.key在剩余old队列vnode中存在，tag不相同，则视为新元素，直接建立并插入到oldStartVnode.elm前面。（同上） tag相同，调用patchVnode递归更新，并将newStartVnode.elm插入oldStartVnode.elm之前，置oldCh[idxInOld] = undefined 在以上循环结束后，进行修正。若oldStartIdx &gt; oldEndIdx，表示旧队列先结束，调用addVnodes插入newCh中剩余的元素。若新队列先结束，则说明有元素被删除，调用removeVnodes进行删除。 7.7.5.4. addVnodesfunction addVnodes (parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) { for (; startIdx &lt;= endIdx; ++startIdx) { nodeOps.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before) } }7.7.5.5. sameVnodereturn ( vnode1.key === vnode2.key &amp;&amp; vnode1.tag === vnode2.tag &amp;&amp; vnode1.isComment === vnode2.isComment &amp;&amp; !vnode1.data === !vnode2.data )若这些相同，则可判断其为相同的vnode，但数据可能不一样，可以运用patchVnode处理。 7.7.5.6. createElm参数：vnode, insertedVnodeQueue, nested const data = vnode.data data及相关属性若不为null，执行data.hook.init(vnode), 这个钩子会直接调用Vue.$mount构造这个vnode代表的子组件。 data.hook.init存在并执行后，如果vnode是一个子组件，那么它肯定已经有一个子实例（vnode.child存在，表示它的组件实例），并mount上去了，子组件也已放置在vnode.elm，调用initComponent，把vnode.elm返回。 const children = vnode.children;const tag = vnode.tag; tag存在，则调用createElement（document.createElement）或createElementNS（document.createElementNS）生成DOM，并挂载到vnode.elm上。 createChildren(vnode, vnode.children, insertedVnodeQueue)递归创建子节点DOM并附加到vnode.elm上。 vnode.data存在，调用invokeCreateHooks，填充DOM的样式、属性事件等。 tag不存在：vnode.isComment为true，调用dom方法createComment，根据vnode.text生成注释节点，赋予vnode.elm，否则调用createTextNode生成文本节点。 返回vnode.elm 7.7.5.7. invokeCreateHooks cbs为上层的createPatchFunction定义并的闭包变量。参见cbs cbs.create[i](emptyNode, vnode) 填充DOM的样式、属性、事件、过渡效果等 vnode.data.hook存在：create钩子存在，i.create(emptyNode, vnode);insert钩子存在，insertedVnodeQueue.push(vnode) 7.7.5.8. createChildren参数：vnode, children, insertedVnodeQueue children为数组，则遍历它们，递归调用createElm生成DOM，并使用appendChild加入到vnode.elm中。 vnode.text存在（文本或数值），调用createTextNode将其包装成文本节点，加入到vnode.elm中。 7.7.5.9. setScope在vnode.elm上添加scopeId属性，从而使scoped CSS能正常施加。参数：vnode vnode.context.$options._scopeId存在，setAttribute(vnode.elm, vnode.context.$options._scopeId, &#39;&#39;) activeInstance.$options._scopeId存在，且activeInstance与vnode.context不同，setAttribute(vnode.elm, activeInstance.$options._scopeId, &#39;&#39;),把父级的scopeId属性也加上 setScope(vnode) 调用setScope 在dom上添加scopedId属性 createChildren(vnode, children, insertedVnodeQueue) 7.7.5.10. initComponent参数：vnode, insertedVnodeQueue vnode.data.pendingInsert存在，将其压入insertedVnodeQueue vnode.elm = vnode.child.$el 调用isPatchable检查vnode是否可通过修补更新，若可以，调用invokeCreateHooks 不可修补： 调用registerRef 7.7.5.11. isPatchable 不断的查找vnode.child._vnode.child，_vnode属性在vm._update中赋值，child存在表示vnode曾经已经渲染并mount过，所以_vnode表示当时的vnode状态，这样不断取child，直到child不存在，就追溯到了最开始的状态，这时若vnode的tag属性存在（有构造函数或vue类配置object），这样可通过这个构造函数来生成组件，则说明可修补，之所以要追溯到最原始的vnode，是应为，一旦渲染过一次，vnode的tag就会变成’vue-component-….’这种字符串（在createComponent中处理的）。 若vnode并不是组件，则其也没有child属性，但它的tag一定存在，所以一定也可修补。 function isPatchable (vnode) { while (vnode.child) { vnode = vnode.child._vnode } return isDef(vnode.tag) }7.7.6. vnode.js7.7.6.1. VNode类虚拟DOM对象的类。 tag: string | void; data: VNodeData | void; children: Array&lt;VNode&gt; | void; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope key: string | number | void; componentOptions: VNodeComponentOptions | void; child: Component | void; // component instance parent: VNode | void; // compoennt placeholder node raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? 标记是否为克隆节点初始化： this.tag = tag this.data = data this.children = children this.text = text this.elm = elm this.ns = ns this.context = context this.key = data &amp;&amp; data.key this.componentOptions = componentOptions this.child = undefined this.parent = undefined this.raw = false this.isStatic = false this.isRootInsert = true this.isComment = false this.isCloned = false该类仅保存这些信息，没有原型方法。 7.7.6.2. emptyVNode返回一个空节点 export const emptyVNode = () =&gt; { const node = new VNode() node.text = '' node.isComment = true return node }7.7.6.3. cloneVNodes调用cloneVNode克隆vnode数组 export function cloneVNodes (vnodes: Array&lt;VNode&gt;): Array&lt;VNode&gt; { const res = new Array(vnodes.length) for (let i = 0; i &lt; vnodes.length; i++) { res[i] = cloneVNode(vnodes[i]) } return res }7.7.6.4. cloneVNode暴力浅克隆，仅适用于静态节点 // optimized shallow clone // used for static nodes and slot nodes because they may be reused across // multiple renders, cloning them avoids errors when DOM manipulations rely // on their elm reference. export function cloneVNode (vnode: VNode): VNode { const cloned = new VNode( vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.ns, vnode.context, vnode.componentOptions ) cloned.isStatic = vnode.isStatic cloned.key = vnode.key cloned.isCloned = true return cloned }8. 流程及测试import Vue from 'vue' describe('dataChange', () =&gt; { it('should force update', done =&gt; { const vm = new Vue({ data: { a: {}, ok: true }, template: '&lt;div&gt; &lt;test v-if=\"ok\"&gt; &lt;p&gt;test1slottt&lt;/p&gt; &lt;/test&gt; &lt;p&gt;{{ a.b }}&lt;/p&gt; &lt;/div&gt;', components: { test: { template: '&lt;em&gt;&lt;a&gt;&lt;/a&gt;&lt;test2&gt;&lt;p&gt;test1111inner&lt;/p&gt;&lt;/test2&gt; t11111&lt;slot&gt;&lt;/slot&gt;&lt;/em&gt;', data: {testdata: 'test2-slot'}, components : { test2 :{ template: '&lt;b&gt;&lt;slot&gt;&lt;/slot&gt;{{testdata}}&lt;/b&gt;' } } } } }).$mount() // expect(vm.$el.textContent).toBe('') vm.a.b = 'foo' console.log('render completed-------------------------'); // console.log(vm.$el); waitForUpdate(() =&gt; { // should not work because adding new property // expect(vm.$el.textContent).toBe('') vm.$forceUpdate() }).then(() =&gt; { // expect(vm.$el.textContent).toBe('foo') }).then(done) }) }) 结果及流程： LOG: 'creatingElement:p;children:test1slottt' LOG: 'creatingElement:test;children:[object Object]' LOG: 'creatingComponent:vue-component-1-test;children:[object Object]' LOG: 'creatingElement:p;children:' LOG: 'creatingElement:div;children:[object Object],[object Object]' LOG: 'render complete:div' LOG: 'updating:div' LOG: 'patch:div' LOG: 'render and update by watcher' LOG: 'render function:function anonymous() { with(this){return _h('em',[_m(0),_h('test2',[_m(1)]),\" t11111\",_t(\"default\")])} }' LOG: 'creatingElement:a;children:undefined' LOG: 'creatingElement:p;children:test1111inner' LOG: 'creatingElement:test2;children:[object Object]' LOG: 'creatingComponent:vue-component-2-test2;children:[object Object]' LOG: 'creatingElement:em;children:[object Object],[object Object], t11111,[object Object]' LOG: 'render complete:em' LOG: 'updating:em' LOG: 'patch:em' LOG: 'render and update by watcher' LOG: 'render function:function anonymous() { with(this){return _h('b',[_t(\"default\"),_s(testdata)])} }' LOG: 'creatingElement:b;children:[object Object],' LOG: 'render complete:b' LOG: 'updating:b' LOG: 'patch:b' LOG: 'render completed-------------------------' LOG: '$forceUpdate:undefined' LOG: 'render and update by watcher' LOG: 'render function:function anonymous() { with(this){return _h('div',[(ok)?_h('test',[_m(0)]):_e(),_h('p',[_s(a.b)])])} }' LOG: 'creatingElement:test;children:[object Object]' LOG: 'creatingComponent:vue-component-1-test;children:[object Object]' LOG: 'creatingElement:p;children:foo' LOG: 'creatingElement:div;children:[object Object],[object Object]' LOG: 'render complete:div' LOG: 'updating:div' LOG: 'patch:div' LOG: 'patchVnode:div;data:undefined' LOG: 'patchVnode:vue-component-1-test;data:[object Object]' LOG: 'prepatch:vue-component-1-test' LOG: '_updateFromParent:vue-component-1-test' LOG: '$forceUpdate:[object Object]' LOG: 'patchVnode:p;data:undefined' LOG: 'render and update by watcher' LOG: 'render function:function anonymous() { with(this){return _h('em',[_m(0),_h('test2',[_m(1)]),\" t11111\",_t(\"default\")])} }' LOG: 'creatingElement:test2;children:[object Object]' LOG: 'creatingComponent:vue-component-2-test2;children:[object Object]' LOG: 'creatingElement:em;children:[object Object],[object Object], t11111,[object Object]' LOG: 'render complete:em' LOG: 'updating:em' LOG: 'patch:em' LOG: 'patchVnode:em;data:undefined' LOG: 'patchVnode:a;data:undefined' LOG: 'patchVnode:vue-component-2-test2;data:[object Object]' LOG: 'prepatch:vue-component-2-test2' LOG: '_updateFromParent:vue-component-2-test2' LOG: '$forceUpdate:[object Object]' LOG: 'patchVnode:undefined;data:undefined' LOG: 'patchVnode:p;data:undefined' LOG: 'render and update by watcher' LOG: 'render function:function anonymous() { with(this){return _h('b',[_t(\"default\"),_s(testdata)])} }' LOG: 'creatingElement:b;children:[object Object],' LOG: 'render complete:b' LOG: 'updating:b' LOG: 'patch:b' LOG: 'patchVnode:b;data:undefined' LOG: 'patchVnode:p;data:undefined'","excerpt":"Vue2源码梳理，各个函数注释及Q&A"},{"title":"regex","date":"2017-09-04T09:37:59.344Z","path":"FE/regex.html","text":"http://www.w3school.com.cn/jsref/jsref_obj_regexp.asphttps://regexper.com 1.1.&nbsp练习1.1. 练习/^[a-zA-z]\\w{3,15}$//^1\\d{10}$//^(\\w-*\\.*)+@(\\w-?)+(\\.\\w{2,})+$/","excerpt":"regex"},{"title":"node-cmd","date":"2017-09-04T09:37:59.340Z","path":"FE/node-cmd.html","text":"1.&nbspspawn1.1.&nbsptips1. spawn1.1. tips 保持颜色 spawn(&quot;path to executable&quot;, [&quot;params&quot;], {stdio: &quot;inherit&quot;}); http://stackoverflow.com/questions/7725809/preserve-color-when-executing-child-process-spawnhttp://stackoverflow.com/questions/18825493/retaining-output-colors-when-shelling-out-to-node","excerpt":"node操作命令行"},{"title":"mac","date":"2017-09-04T09:37:59.340Z","path":"FE/mac.html","text":"1.&nbsp快捷键1. 快捷键http://jingyan.baidu.com/article/08b6a591aac09614a909224f.html https://www.zhihu.com/question/24757023","excerpt":"mac"},{"title":"mobile-view","date":"2017-09-04T09:37:59.340Z","path":"FE/mobile-view.html","text":"使用location.hash设置锚点在一些浏览器中容易失效，故正确的做法是： var t = $(\"#anchor\").offset().top; $(window).scrollTop(t); textarea或input在使用.text()或innerText等进行取值容易失效，故取得输入的值应使用.val()","excerpt":"mobile-view"},{"title":"mongoDB","date":"2017-09-04T09:37:59.340Z","path":"FE/mongoDB.html","text":"1.&nbspWindows下mongoDB安装1.1.&nbsp下载安装包1.2.&nbsp建立配置文件及数据库目录1.3.&nbsp将mongoDB安装为服务1.4.&nbsp测试1.5.&nbsp参考2.&nbspLinux下mongoDB安装3.&nbsp基本命令3.1.&nbsp登陆退出3.2.&nbsp数据库3.3.&nbspcollection3.4.&nbsp查询操作3.5.&nbsp备份恢复3.5.1.1.&nbspmongostore1. Windows下mongoDB安装1.1. 下载安装包 进入官网：https://www.mongodb.org/ 下载相应的安装包 点击进行安装 记录安装后mongo程序所在位置，如:D:\\Program Files\\MongoDB\\Server\\3.2\\bin 1.2. 建立配置文件及数据库目录建立配置文件D:\\Programming\\MongoDB\\mongo.config,内容如下： dbpath=D:\\Programming\\MongoDB\\data\\db ##数据库路径 logpath=D:\\Programming\\MongoDB\\log\\mongo.log ##日志输出文件路径 logappend=true ##错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件，而不是从新创建一个新文件 journal=true ##启用日志文件，默认启用 quiet=true ##这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false port=27017 ##端口号 默认为27017以上配置文件所涉及的路径及文件均需手动一一建立 1.3. 将mongoDB安装为服务管理员模式下进入cmd命令行,并进入程序所在目录，如: cd D:\\Program Files\\MongoDB\\Server\\3.2\\bin输入命令： mongod --config D:\\Programming\\MongoDB\\mongo.config --install启动服务： net start MongoDB1.4. 测试进入程序所在目录，直接输入mongo进行连接 1.5. 参考http://www.cnblogs.com/lzrabbit/p/3682510.html 2. Linux下mongoDB安装 安装:apt-get install mongodb 客户端登陆：mongo 3. 基本命令3.1. 登陆退出Linux直接输入命令，Windows需在cmd下进入mongoDB的安装目录，如输入cd C:\\Program Files\\MongoDB\\Server\\3.2\\bin无密码登陆：mongo退出：quit() 3.2. 数据库 查看所有数据库(与MySQL相同): show databases 创建并使用数据库: use netnote（netnote为数据库名字） 查看所有集合：show collections 删除数据库:use xxx db.dropDatabase() 3.3. collection 删除coll：db.coll.drop() 3.4. 查询操作查看所有记录： db.notes.find()记录数量： db.notes.find().count()清除所有记录： db.notes.remove({})3.5. 备份恢复这些命令在shell下使用 3.5.1.1. mongostorehttps://docs.mongodb.org/manual/reference/program/mongorestore/ mongorestore -d dss_dev /Users/lizh/OneDrive/backup/dev0323dss_dev为数据库名称，/Users/lizh/OneDrive/backup/dev0323为已备份的文件夹","excerpt":"mongoDB"},{"title":"mySQL","date":"2017-09-04T09:37:59.340Z","path":"FE/mySQL.html","text":"1.&nbsp安装2.&nbsp命令2.1.&nbsp解锁2.2.&nbsp引擎3.&nbsp表批量操作4.&nbsp配置优化4.1.&nbsp文件结构4.2.&nbsp文件优化5.&nbsp参考1. 安装apt-get install mysql-server2. 命令重启： /etc/init.d/mysql restart2.1. 解锁 查看所有进程： show full processlist; kill 进程id; 2.2. 引擎查看系统支持的存储引擎: show engines;查看默认引擎： show variables like '%storage_engine%';查看单个表引擎： show table status from db_name where name='table_name';查看数据库中所有表引擎： select table_name,ENGINE from information_schema.tables WHERE table_schema = 'dbname'修改引擎：ALTER TABLE my_table ENGINE=InnoDB; 3. 表批量操作select * from information_schema.tables WHERE table_schema = 'dbname'4. 配置优化4.1. 文件结构数据文件默认存放于：/var/lib/mysql/ 配置文件： /etc/mysql/my.cnf 4.2. 文件优化若要在其他主机上进行远程登陆mysql，需在my.cnf中添加： [mysqld] bind-address=\"0.0.0.0\"注意双引号设置utf8默认字符,在mysqld后： character_set_server=utf8 init_connect='SET NAMES utf8'Mysql5.5配置文件如下： # - !includedir /etc/mysql/conf.d/ - !includedir /etc/mysql/mysql.conf.d/ [mysqld] bind-address=\"0.0.0.0\" sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES back_log = 600 max_connections = 1000 max_connect_errors = 6000 open_files_limit = 65535 table_open_cache = 128 max_allowed_packet = 4M binlog_cache_size = 1M max_heap_table_size = 8M tmp_table_size = 16M read_buffer_size = 2M read_rnd_buffer_size = 8M sort_buffer_size = 8M join_buffer_size = 8M thread_cache_size = 6 query_cache_size = 8M query_cache_limit = 2M key_buffer_size = 4M ft_min_word_len = 4 - 分词词汇最小长度，默认4 log_bin = mysql-bin binlog_format = mixed expire_logs_days = 30 #超过30天的binlog删除 slow_query_log = 1 bulk_insert_buffer_size = 8M myisam_max_sort_file_size = 10G myisam_repair_threads = 1 interactive_timeout = 18800 wait_timeout = 18800 character_set_server=utf8 init_connect='SET NAMES utf8' default-storage-engine = InnoDB innodb_lock_wait_timeout = 120 innodb_max_dirty_pages_pct = 90 innodb_flush_log_at_trx_commit = 2 innodb_purge_threads = 1 [mysql] default_character_set=utf8 [client] port = 33065. 参考https://blog.linuxeye.com/379.html http://www.jb51.net/article/33569.htm","excerpt":"mySQL"},{"title":"nginx","date":"2017-09-04T09:37:59.340Z","path":"FE/nginx.html","text":"1.&nbsp安装配置1.1.&nbspnginx配置1.2.&nbspphp.ini1.3.&nbspphp-fpm2.&nbsp重启3.&nbspMediawiki4.&nbsp参考1. 安装配置1.1. nginx配置 http编辑文件：vim /etc/nginx/nginx.conf 监听配置文件：vim /etc/nginx/sites-available/default 重写：rewrite ^/(.*) [http://node.chuune.top](http://node.chuune.top):3000$uri last;将任意字符不区分大小写重写为：http://node.chuune.top:3000加上相对路径($uri),参数会自动添加 反向代理： 将所有包转发给http://localhost:3000 proxy_pass http://localhost:3000; 将原始地址(及经过的其他代理)写入header的X-Forwarded-For中，以此在后端可以读取该参数获得前端的实际IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 1.2. php.ini修改一下文件： /etc/php5/cgi/php.ini /etc/php5/cli/php.ini /etc/php5/fpm/php.ini 去掉cgi.fix-pathinfo=1 的注释 1.3. php-fpm php-fpm配置文件vim /etc/php5/fpm/php-fpm.conf对于小内存：pm=dynamic pm.max_children=20 pm.start_servers=5 pm.min_spare_servers=5 pm.max_spare_servers=20 '进程执行xxx后重启释放内存避免内存泄漏 pm.max_requests = 4096 '进程超时时间 request_terminate_timeout = 100 2. 重启重启php5-fpm： /etc/init.d/php5-fpm restart重启nginx： /etc/init.d/nginx restart查看状态： nginx -t3. Mediawikiserver { listen 80; server_name wiki.chuune.top; root /var/www/html/wiki; index index.php; client_max_body_size 5m; client_body_timeout 60; location / { try_files $uri $uri/ @rewrite; } location @rewrite { rewrite ^/(.*)$ /index.php?title=$1&amp;$args; } location ^~ /maintenance/ { return 403; } location ~ \\.php$ { include snippets/fastcgi-php.conf; # # # With php5-cgi alone: # fastcgi_pass 127.0.0.1:9000; # # With php5-fpm: fastcgi_pass unix:/var/run/php5-fpm.sock; } location ~* \\.(js|css|png|jpg|jpeg|gif|ico)$ { try_files $uri /index.php; expires max; log_not_found off; } location = /_.gif { expires max; empty_gif; } location ^~ /cache/ { deny all; } location /dumps { root /var/www/mediawiki/local; autoindex on; } }设置参考：https://www.nginx.com/resources/wiki/start/topics/recipes/mediawiki/?highlight=mediawiki# https://www.mediawiki.org/wiki/Manual:Short_URL/wiki/Pagetitle–_nginx_rewrite–root_access 4. 参考http://blog.csdn.net/rainysia/article/details/12972975","excerpt":"nginx"},{"title":"mediaWiki","date":"2017-09-04T09:37:59.340Z","path":"FE/mediaWiki.html","text":"使用对MediaWiki符号进行非转义 1.&nbsp配置2.&nbsp皮肤1. 配置修改LocalSettings.phpMediawiki采用的数据库不可禁用MyISAM，因为SearchIndex将会使用，故把默认的引擎都改为InnoDB后，不可禁用MyISAM,参见： https://www.mediawiki.org/wiki/Manual_talk:Searchindex_table &lt;?php # Protect against web entry // // // // if ( !defined( 'mediawiki' ) ) { // // // // exit; // // // // } ## Uncomment this to disable output compression # $wgDisableOutputCompression = true; $wgSitename = \"ChuuneWiki\"; $wgScriptPath = \"\"; #需要与nginx中设置的php监视后缀一致 $wgScriptExtension = \".php\"; #使用wiki/.../模式来显示url $wgUsePathInfo = true; $wgArticlePath = \"/wiki/$1\"; $wgServer = \"http://wiki.chuune.top\"; $wgStylePath = \"$wgScriptPath/skins\"; $wgResourceBasePath = $wgScriptPath; $wgLogo = \"/logo/wiki_logo.jpg\"; $wgEnableEmail = false; $wgEnableUserEmail = true; # UPO $wgEmergencyContact = \"ngnix@localhost\"; $wgPasswordSender = \"ngnix@localhost\"; $wgEnotifUserTalk = false; # UPO $wgEnotifWatchlist = false; # UPO $wgEmailAuthentication = true; #$wgGroupPermissions = array(); $wgGroupPermissions['*']['createaccount'] = true; $wgGroupPermissions['*']['read'] = true; $wgGroupPermissions['*']['edit'] = false; ## Database settings $wgDBtype = \"mysql\"; $wgDBserver = \"***\"; $wgDBname = \"***\"; $wgDBuser = \"***\"; $wgDBpassword = \"***\"; $wgDBprefix = \"\"; # MySQL table options to use during installation or update #数据库引擎及字符 $wgDBTableOptions = \"ENGINE=MyISAM, DEFAULT CHARSET=utf8\"; # Experimental charset support for MySQL 5.0. $wgDBmysql5 = false; ## Shared memory settings $wgMainCacheType = CACHE_NONE; $wgMemCachedServers = array(); $wgEnableUploads = false; #$wgUseImageMagick = true; #$wgImageMagickConvertCommand = \"/usr/bin/convert\"; $wgUseInstantCommons = false; $wgShellLocale = \"en_US.utf8\"; #$wgHashedUploadDirectory = false; $wgCacheDirectory = \"$IP/cache\"; # Site language code, should be one of the list in ./languages/Names.php $wgLanguageCode = \"zh-hans\"; $wgSecretKey = \"78bcf7f529d864e46b87a0f75a19bcb325eb66540ac49f201fde3d8a67ce0ede\"; # Site upgrade key. Must be set to a string (default provided) to turn on the # web installer while LocalSettings.php is in place $wgUpgradeKey = \"31d77b8f4d6d6cfb\"; ## For attaching licensing metadata to pages, and displaying an ## appropriate copyright notice / icon. GNU Free Documentation ## License and Creative Commons licenses are supported so far. $wgRightsPage = \"\"; # Set to the title of a wiki page that describes your license/copyright $wgRightsUrl = \"\"; $wgRightsText = \"\"; $wgRightsIcon = \"\"; # Path to the GNU diff3 utility. Used for conflict resolution. $wgDiff3 = \"\"; ## Default skin: you can change the default skin. Use the internal symbolic ## names, ie 'vector', 'monobook': $wgDefaultSkin = \"Metrolook\"; $wgMetrolookFeatures = array( 'collapsiblenav' =&gt; array( 'global' =&gt; true, 'user' =&gt; true ) ); $wgMetrolookUploadButton = false; # Enabled skins. # The following skins were automatically enabled: #加载皮肤 wfLoadSkin( 'CologneBlue' ); wfLoadSkin( 'Modern' ); wfLoadSkin( 'MonoBook' ); wfLoadSkin( 'Vector' ); wfLoadSkin( 'Metrolook' ); # Enabled Extensions. Most extensions are enabled by including the base extension file here # but check specific extension documentation for more details # The following extensions were automatically enabled: wfLoadExtension( 'WikiEditor' ); # End of automatically generated settings. # Add more configuration options below.2. 皮肤所有的皮肤：https://www.mediawiki.org/wiki/Category:All_skins 皮肤排行：https://wikiapiary.com/wiki/Skin:Skins 当前使用：https://www.mediawiki.org/wiki/Skin:MetrolookGithub:https://github.com/paladox/Metrolook","excerpt":"mediaWiki"},{"title":"npm","date":"2017-09-04T09:37:59.340Z","path":"FE/npm.html","text":"1.&nbsp设置1.1.&nbsp设置淘宝源1. 设置1.1. 设置淘宝源npm config set registry=https://registry.npm.taobao.org 也可使用cnpm，参照：http://npm.taobao.org/","excerpt":"npm"},{"title":"performance","date":"2017-09-04T09:37:59.340Z","path":"FE/performance.html","text":"1.&nbsp基础知识2.&nbsp监控指标及规则2.1.&nbsp具体指标参考2.2.&nbsp页面检查及建议3.&nbsp技术案例3.1.&nbsphar文件及浏览器工具3.2.&nbsppsi3.3.&nbspWebPageTest3.4.&nbspSiteSpeed3.5.&nbspbonree3.6.&nbspWeb服务器/转发服务器直接优化4.&nbsp解决方案4.1.&nbsp与现有解决方案相比的特色5.&nbspWebPageTest6.&nbsp平台搭建7.&nbspSiteSpeed1. 基础知识 HAR ​standard Navigation_timing_API yslow coach PageSpeed psi wikipedia-Website_monitoring wikipedia-Web_analytics 2. 监控指标及规则 页面优化情况（Yahoo的23条规则） 接口请求并发数及数据返回时间 静态资源的请求并发数及返回时间 缓存使用情况及优化空间 关于接口的压力测试 与主流站点间的指标比较 站点相关日志分析 2.1. 具体指标参考总体分数 平均组合性能表现, 是 Coach中综合可用性与最佳实践的分数. 如果该分数为100表示完美，不需要再进行修改。性能分数coach计算页面与性能最佳实践的接近程度 查看全部&nbsp;建议列表.可用性分数确保所有人可以进入并使用你的站点. 参考以下链接了解更多&nbsp;help out&nbsp;. 通过以下链接了解如何提高可用性&nbsp;here.Web最佳实践分数与Web最佳实践接近程度. 确保页面能被搜索引擎索引, 有良好的url结构。 阅读全部&nbsp;the advice.计时后端用时服务器生成页面及网络传输页面所用时间.通过导航计时API中的定义计算: responseStart - navigationStart前端用时浏览器解析及创建页面所用的时间. 通过导航计时API中的定义计算: loadEventStart - responseEndDOM内容加载计时解析文档、 执行延迟和被解析插入的脚本所耗时间，包括从用户位置到服务器的网络时间. 通过导航计时API中的定义计算: domContentLoadedEventStart - navigationStartDOM交互时间浏览器解析文档所用的时间, 包括从用户位置到服务器的网络时间. 通过导航计时API中的定义计算: domInteractive - navigationStart域名解析计时DNS查询所用的时间. 通过导航计时API中的定义计算: domainLookupEnd - domainLookupStart页面下载计时下载页面所用时间 ( HTML). 通过导航计时API中的定义计算: responseEnd - responseStart页面加载计时页面加载所用时间, 从页面视图初始化 (e.g., 点击页面链接)到在浏览器中加载完成. 注意: 这仅仅和某些页面相关, 取决于页面如何构建. 通过导航计时API中的定义计算: loadEventStart - navigationStart重定向计时重定向所用时间. 通过导航计时API中的定义计算: fetchStart - navigationStart服务器连接计时连接服务器所用时间. 通过导航计时API中的定义计算: connectEnd - connectStart首次绘制发生在屏幕上首次绘制的时候. 如果浏览器支持这项指标 (现在只有Chrome支持), 则使用它.完整加载所有资源都已下载的时候. 通过资源计时API计算 API.速度指数速度指数是页面可见部分被展示的平均时间. 以毫秒表示并且与视口大小相关 。它由 Pat Meenan 创建 可通过以下连接查看完整文档&nbsp;here.RUM-速度指数 Pat Meenan 创建的一个浏览器版本， 使用资源计时来进行速度指数测量计算 。它和速度指数一样并不完美，但是是一个好的开始. 2.2. 页面检查及建议参见coach 3. 技术案例 3.1. har文件及浏览器工具 3.2. psi调用google API，需使用vpn翻墙,github 3.3. WebPageTest 3.4. SiteSpeed 3.5. bonree 3.6. Web服务器/转发服务器直接优化 nginx/apache 中间件 eg:https://github.com/pagespeed/ngx_pagespeed url rewrite进行静态化 4. 解决方案 页面优化情况检查接口 参照sitespeed,grunt-yslow,psi 制作页面性能综合测试接口。 页面加载响应时间测试监控（首页加载时间、各链接响应时间） 各地域测试（使用已购买的接口或购买新接口） 压力测试 数据的处理和比较 定期扫描主流站点，根据测试结果形成标准并定期更新 定期运行分析，记录站点当前的性能状态 制作相应的数据模型并存入数据库（Mongo/MySQL） 统计数据的可视化，建立展示站点，开发相应展示功能（Vue/Echart） 预警推送功能（邮件/APP） 4.1. 与现有解决方案相比的特色 增加页面优化分析和建议项 定制重要指标，简化操作 预警推送有的放矢 5. WebPageTest6. 平台搭建目前WebPageTest私有实例只能搭建在Windows平台上，搭建步骤如下： 下载已编译的WebPageTest实例：webpagetest_2.19.zip 目前最新版本2.19 在windows上部署apache/nginx+php环境，可采用xampp安装，注意2003及XP需使用旧版1.8.2的版本。并且在此之前，需安装VC环境 将webpagetest_2.19.zip解压，www文件夹中的文件移动至apache站点的根目录（或将apche配置文件中的文档根目录指定至解压后的文件夹）。测试http://127.0.0.1/,应已可显示Web UI。 查看网站中settings文件夹，参考.sample文件,创建相应的.ini文件，测试时仅需创建locations.ini，保证在UI中location可以选择。 打开webpagetest_2.19.zip中的agent文件夹，把所有sample文件转为ini文件，修改wptdriver.ini，将其中的各浏览器对应的地址转为本地正确的地址 安装dummynet，在网络连接中安装服务，从agent\\dummynet\\64bit或32bit中选择安装 启动wptdriver.exe ，正常状态应该是Waiting for work，若在下载文件中卡住，应把wptdriver.ini所涉及的下载文件都在当前目录下建立相应空文件，并把ini涉及的地址改为本地 在浏览器中打开http://127.0.0.1/,输入测试网址，选择Location为Test及浏览器Chrome，运行后应该能正常生成报告 若未能成功安装dummynet，则无法使用连接速度控制功能，这时应在UI里高级选项中将从Connection下所有数值置为0，否则会报错。 WinXP目前不能使用2.19版本，只能使用旧版。 该php站点并未绑定域名，故可通过所有站点IP/域名来访问。其他事项参考官方文档 7. SiteSpeed参见： sitespeed","excerpt":"前端页面性能测试"},{"title":"polyfill","date":"2017-09-04T09:37:59.340Z","path":"FE/polyfill.html","text":"1.&nbspArray1.1.&nbspfind2.&nbspFunction2.1.&nbspbind1. Array1.1. find if (!Array.prototype.find) { Array.prototype.find = function(predicate) { if (this == null) { throw new TypeError('Array.prototype.find called on null or undefined'); } if (typeof predicate !== 'function') { throw new TypeError('predicate must be a function'); } var list = Object(this); var length = list.length &gt;&gt;&gt; 0; var thisArg = arguments[1]; var value; for (var i = 0; i &lt; length; i++) { value = list[i]; if (predicate.call(thisArg, value, i, list)) { return value; } } return undefined; }; }2. Function2.1. bindif (!Function.prototype.bind) { Function.prototype.bind = function (oThis) { if (typeof this !== \"function\") { // closest thing possible to the ECMAScript 5 // internal IsCallable function throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\"); } var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () {}, = function () { // 这些是在fBound执行时才会生效， 若fBound作为构造函数，则this instanceof fNOP return fToBind.apply(this instanceof fNOP ? this : oThis || this, aArgs.concat(Array.prototype.slice.call(arguments))); }; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; }; }","excerpt":"record polyfill"},{"title":"quiz","date":"2017-09-04T09:37:59.340Z","path":"FE/quiz.html","text":"1.&nbsp试题1.1.&nbspHTML1.1.1.&nbsp名词1.1.2.&nbsp试题1.1.3.&nbsp链接1.2.&nbspCSS1.2.1.&nbsp名词1.2.2.&nbsp试题1.3.&nbspJS1.3.1.&nbsp概念1.3.2.&nbsp试题2.&nbsp答案2.1.&nbspHTML2.1.1.&nbsp名词2.1.2.&nbsp试题2.1.3.&nbsp链接2.2.&nbspCSS2.2.1.&nbsp名词2.2.2.&nbsp试题2.3.&nbspJS2.3.1.&nbsp概念2.3.2.&nbsp试题2.4.&nbspnode1. 试题1.1. HTML1.1.1. 名词 DOCTYPE SGML SGML(Standard Generalized Markup Language,即标准通用标记语言)SGML是国际上定义电子文档和内容描述的标准。HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）； 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 1.1.2. 试题 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 浏览器的内核分别是什么? 常见兼容性问题？ html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？ 语义化的理解？ HTML5的离线储存？ iframe有那些缺点？ HTML5的form如何关闭自动完成功能？ 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ 如何实现浏览器内多个标签页之间的通信? webSocket如何兼容低浏览器? 1.1.3. 链接https://segmentfault.com/a/1190000000465431 1.2. CSS1.2.1. 名词 justify单词两端对齐text-align:justify text-transformh1 {text-transform:uppercase} h2 {text-transform:capitalize} p {text-transform:lowercase}capitalize每个单词以大写开头 1.2.2. 试题 介绍一下CSS的盒子模型？ CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？ 如何居中div？如何居中一个浮动元素？ 列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？ CSS3有哪些新特性？ 一个满屏品字布局 如何设计? 经常遇到的CSS的兼容性有哪些？原因，解决方法是什么？ 为什么要初始化CSS样式。 absolute的containing block计算方式跟正常流有什么不同？https://www.zhihu.com/question/20086234 position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？ 对BFC规范的理解？http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html css定义的权重 解释下浮动和它的工作原理？清除浮动的技巧 用过媒体查询，针对移动端的布局吗？ 使用 CSS 预处理器吗？喜欢那个？ 如果需要手动写动画，你认为最小时间间隔是多久，为什么？ display:inline-block 什么时候会显示间隙？ 1.3. JS1.3.1. 概念 AMD CMD 1.3.2. 试题 对象和引用的概念var a = {n:1}; var b = a; // 持有a，以回查 a.x = a = {n:2}; alert(a.x);// --&gt; undefined alert(b.x);// --&gt; {n:2} JavaScript原型，原型链 ? 有什么特点？ 说几条写JavaScript的基本规范？ eval是做什么的？ null，undefined 的区别？ 写一个通用的事件侦听器函数 Node.js的适用场景？ 介绍js的基本数据类型。 Javascript如何实现继承？ [“1”, “2”, “3”].map(parseInt) 答案是多少？ 如何创建一个对象? （画出此对象的内存图） 谈谈This对象的理解。 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 什么是闭包（closure），为什么要用它？ “use strict”;是什么意思 ? 使用它的好处和坏处分别是什么？ 如何判断一个对象是否属于某个类？ new操作符具体干了什么呢? Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？ JSON 的了解？ js延迟加载的方式有哪些？ ajax 是什么? 同步和异步的区别? 如何解决跨域问题? 模块化怎么做？ AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ 异步加载的方式有哪些？ .call() 和 .apply() 的区别？ Jquery与jQuery UI 有啥区别？ JQuery的源码看过吗？能不能简单说一下它的实现原理？ jquery 中如何将数组转化为json字符串，然后再转化回来？ 针对 jQuery 的优化方法？ JavaScript中的作用域与变量声明提升？ 如何编写高性能的Javascript？ 那些操作会造成内存泄漏？ JQuery一个对象可以同时绑定多个事件，这是如何实现的？ 如何判断当前脚本运行在浏览器还是node环境中？ 2. 答案2.1. HTML2.1.1. 名词 DOCTYPE SGML SGML(Standard Generalized Markup Language,即标准通用标记语言)SGML是国际上定义电子文档和内容描述的标准。HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）； 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 2.1.2. 试题 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素：a b img span strong 块级元素：div ol ul dl li h1 h2 h3 p 空元素：br hr img input link meta 浏览器的内核分别是什么?IE-Trident FF-Gecko Chrome-Blink Opera-Blink Edge-改进Trident 常见兼容性问题？ 内外边距初始值不同： *{margin:0;padding:0;} IE6中后面的一块被顶到下一行，加入 display:inline;将其转化为行内属性 设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug；在display:block;后面加入display:inline;display:table; 图片默认有间距；使用float属性为img布局 最低高度设置min-height不兼容；如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;} html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？新特性：更丰富的标签，如video audio；语义标签:对标题进行组合：hgroup绘图标签：canvas 可选数据的列表：datalist,与input配合使用 移除了仅表现元素（交给CSS），如big center font 语义化的理解？ HTML5的离线储存？ iframe有那些缺点？ HTML5的form如何关闭自动完成功能？ 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ 如何实现浏览器内多个标签页之间的通信? webSocket如何兼容低浏览器? 2.1.3. 链接https://segmentfault.com/a/1190000000465431 2.2. CSS2.2.1. 名词 justify单词两端对齐text-align:justify text-transformh1 {text-transform:uppercase} h2 {text-transform:capitalize} p {text-transform:lowercase}capitalize每个单词以大写开头 2.2.2. 试题 介绍一下CSS的盒子模型？ CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？ 如何居中div？如何居中一个浮动元素？ 列出display的值，说明他们的作用。position的值， relative和absolute定位原点是？ CSS3有哪些新特性？ 一个满屏品字布局 如何设计? 经常遇到的CSS的兼容性有哪些？原因，解决方法是什么？ 为什么要初始化CSS样式。 absolute的containing block计算方式跟正常流有什么不同？https://www.zhihu.com/question/20086234 position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？ 对BFC规范的理解？http://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html css定义的权重 解释下浮动和它的工作原理？清除浮动的技巧 用过媒体查询，针对移动端的布局吗？ 使用 CSS 预处理器吗？喜欢那个？ 如果需要手动写动画，你认为最小时间间隔是多久，为什么？ display:inline-block 什么时候会显示间隙？ 实现轮播效果：https://codepen.io/goumang2010/pen/MopOYd 2.3. JS2.3.1. 概念 AMD CMD 2.3.2. 试题 对象和引用的概念var a = {n:1}; var b = a; a.x = a = {n:2}; // .运算符优先级最高，所以优先开辟x属性 alert(a.x);// --&gt; undefined alert(b.x);// --&gt; {n:2} JavaScript原型，原型链 ? 有什么特点？ 说几条写JavaScript的基本规范？ eval是做什么的？ null，undefined 的区别？ 写一个通用的事件侦听器函数 Node.js的适用场景？ 介绍js的基本数据类型。 Javascript如何实现继承？ [“1”, “2”, “3”].map(parseInt) 答案是多少？ [1, NaN, NaN] 因为1进制和2进制根本无法表示2或3 如何创建一个对象? （画出此对象的内存图） 谈谈This对象的理解。 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 什么是闭包（closure），为什么要用它？ “use strict”;是什么意思 ? 使用它的好处和坏处分别是什么？ 如何判断一个对象是否属于某个类？ new操作符具体干了什么呢? Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？ JSON 的了解？ js延迟加载的方式有哪些？ ajax 是什么? 同步和异步的区别? 如何解决跨域问题? 模块化怎么做？ AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ 异步加载的方式有哪些？ .call() 和 .apply() 的区别？ Jquery与jQuery UI 有啥区别？ JQuery的源码看过吗？能不能简单说一下它的实现原理？ jquery 中如何将数组转化为json字符串，然后再转化回来？ 针对 jQuery 的优化方法？ JavaScript中的作用域与变量声明提升？ 如何编写高性能的Javascript？ 那些操作会造成内存泄漏？ JQuery一个对象可以同时绑定多个事件，这是如何实现的？ 如何判断当前脚本运行在浏览器还是node环境中？ 2.4. node async的使用 异步解决方案 多线程方案 node源码及文档 Websocket express原理","excerpt":"quiz"},{"title":"react-redux","date":"2017-09-04T09:37:59.340Z","path":"FE/react-redux.html","text":"1.&nbspcomponents1.1.&nbspProvider1.2.&nbspconnectAdvanced1.2.1.&nbspwrapWithConnect1.2.1.1.&nbspsetWrappedInstance1.2.1.2.&nbspinitSelector1.2.1.3.&nbspinitSubscription1.2.1.3.1.&nbsponStateChange1.2.1.4.&nbspaddExtraProps1.2.1.5.&nbsprender2.&nbsputils2.1.&nbspSubscription.js2.1.1.&nbspcreateListenerCollection2.1.1.1.&nbspclear2.1.1.2.&nbspnotify2.1.1.3.&nbspsubscribe2.1.2.&nbspSubscription类2.1.2.1.&nbspconstructor2.1.2.2.&nbspaddNestedSub2.1.2.3.&nbspnotifyNestedSubs2.1.2.4.&nbspisSubscribed2.1.2.5.&nbsptrySubscribe2.1.2.6.&nbsptryUnsubscribe2.1.3.&nbsppureFinalPropsSelectorFactory2.1.3.1.&nbsphandleFirstCall2.1.3.2.&nbsphandleSubsequentCalls2.1.3.2.1.&nbsphandleNewPropsAndNewState2.1.3.2.2.&nbsphandleNewProps2.1.3.2.3.&nbsphandleNewState2.2.&nbspwrapMapToProps2.2.1.&nbspwrapMapToPropsConstant2.2.2.&nbspgetDependsOnOwnProps2.2.3.&nbspwrapMapToPropsFunc2.2.3.1.&nbspdetectFactoryAndVerify1. components1.1. Provider导出Provider组件类 重写构造函数，将props.store赋予实例属性this.store 重写getChildContext，返回{ store: this.store, storeSubscription: null } 重写render，返回 children 中仅有的子级。否则抛出异常。 1.2. connectAdvanced传入selectorFactory和options，返回connect的高阶组件。 const subscriptionKey = storeKey + &#39;Subscription&#39; storeKey为options中的属性 const version = hotReloadingVersion++ hotReloadingVersion为模块中的变量 定义contextTypes和childContextTypes，进行类型检查。 传入WrappedComponent，返回wrapWithConnect函数，该函数即是构造connect组件的高阶组件。 1.2.1. wrapWithConnect参数：WrappedComponent 构建selectorFactory的option 构建Connect组件： this.version = version this.state = {} this.store = this.props[storeKey] || this.context[storeKey] context由最上级的provider组件提供 this.parentSub = props[subscriptionKey] || context[subscriptionKey] this.setWrappedInstance = this.setWrappedInstance.bind(this) 确保setWrappedInstance的this绑定当前实例，从而wrappedInstance可以被正确设置 this.getState = this.store.getState.bind(this.store); 确保getState被正确的绑定在store上 执行initSelector和initSubscription 设置Connect的静态属性 ``` Connect.WrappedComponent = WrappedComponent Connect.displayName = displayName Connect.childContextTypes = childContextTypes Connect.contextTypes = contextTypes Connect.propTypes = contextTypes ``` process.env.NODE_ENV不为production，则处理热更新.即定义componentWillUpdate方法,如果version与实例this.version不同，则执行initSelector,如果订阅者this.subscription存在,执行this.subscription.tryUnsubscribe(),然后重新订阅this.initSubscription(),shouldHandleStateChanges为true，执行订阅者的订阅this.subscription.trySubscribe()，从而让父级的订阅器收集到当前container的onStateChange return hoistStatics(Connect, WrappedComponent) 将WrappedComponent中的非react静态属性复制给Connect, 并返回Connect组件 1.2.1.1. setWrappedInstance传入引用refthis.wrappedInstance = ref 1.2.1.2. initSelector 构建selector： const { dispatch } = this.store;const { getState } = this;const sourceSelector = selectorFactory(dispatch, selectorFactoryOptions) 将selector包装成对象，从而检查run后的结果 shouldComponentUpdate: true props: sourceSelector(getState(), this.props) 初始props run方法，传入props，通过sourceSelector计算出nextProps，若出错则记录错误，并置shouldComponentUpdate为true，否则，若上次执行有错误，或是nextProps已与上次props不同，则selector.props = nextProps ,并清空错误，shouldComponentUpdate置true 1.2.1.3. initSubscriptionshouldHandleStateChanges（connectAdvanced的参数options中的属性，指示HOC是否应监听store变化，默认为true）为true时方执行。 const subscription = this.subscription = new Subscription(this.store, this.parentSub) ,创建监听实例。 建立subscription实例的onStateChange属性，并绑定当前connect组件的this。 1.2.1.3.1. onStateChange this.selector.run(this.props)，传入当前props，根据state设置新的props。 如果selector.shouldComponentUpdate为false，即表示渲染完成，直接执行subscription.notifyNestedSubs，将收集的子级lisener（一般是子级的onStateChange）执行（子级的onStateChange会递归执行所有后代的onStateChange） 如果selector.shouldComponentUpdate为true，则定义组件componentDidUpdate，在渲染完毕后执行subscription.notifyNestedSubs,然后清除componentDidUpdate 通过react组件的setState刷新UI 1.2.1.4. addExtraProps if (!withRef &amp;&amp; !renderCountProp) return props 若既不需要使用getWrappedInstance暴露WrappedComponent，或是renderCountProp也是默认值，直接返回传入的props withRef为true，浅复制props，将props的ref属性设为this.setWrappedInstance renderCountProp存在，props的renderCountProp属性置为this.renderCount++（初始为0） 1.2.1.5. render 置selector.shouldComponentUpdate为false 若selector.error存在，抛出错误 return createElement(WrappedComponent, this.addExtraProps(selector.props))注意是使用的createElement的一种重载。 2. utils2.1. Subscription.js2.1.1. createListenerCollection建立listener集合 设置current和next两个数组 返回对象，该对象属性包括： 2.1.1.1. clear清空next和current 2.1.1.2. notify将next赋予current，并执行其中每个成员。 2.1.1.3. subscribe传入listener 设置闭包flag isSubscribed为true 如果current和next指向的对象相同，则复制current对象并赋予next，并在next中加入传进来的listener， 返回unsubscribe函数。isSubscribed为false或current为null直接返回。若否，置isSubscribed为false，next和current指向不同，并把listener从next中移除。 2.1.2. Subscription类2.1.2.1. constructor传入store, parentSub，并置为实例属性。this.unsubscribe = null;this.listeners = nullListeners nullListeners为{ notify() {} } 2.1.2.2. addNestedSub传入listener 执行trySubscribe，确保this.unsubscribe和this.listeners存在。 return this.listeners.subscribe(listener) 将listener加入listeners集合中 2.1.2.3. notifyNestedSubsthis.listeners.notify() 将收集的lisenter统统执行。 2.1.2.4. isSubscribedreturn Boolean(this.unsubscribe) 2.1.2.5. trySubscribeunsubscribe不存在，若parentSub存在 ，将unsubscribe置为this.parentSub.addNestedSub(this.onStateChange),注意onStateChange是在connectAdvanced.initSubscription()设置。若parentSub不存在，置为this.store.subscribe(this.onStateChange) 这样，子级的onStateChange就可以被父级的订阅器subscription收集，当父级订阅器notifyNestedSubs时，就会执行子级的onStateChange 调用createListenerCollection创建监听器集合作为实例属性listeners 2.1.2.6. tryUnsubscribe```if (this.unsubscribe) { this.unsubscribe() this.unsubscribe = null this.listeners.clear() this.listeners = nullListeners } # connect ## connect ### createConnect 传入 connectHOC = connectAdvanced, mapStateToPropsFactories = defaultMapStateToPropsFactories, mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories, mergePropsFactories = defaultMergePropsFactories, selectorFactory = defaultSelectorFactory 构建connect函数 ## selectorFactory 返回selector工厂函数，参数： { initMapStateToProps, initMapDispatchToProps, initMergeProps, …options} 1. 将对象中的各函数都传入dispatch、options，保存为mapStateToProps，mapDispatchToProps,mergeProps 2. 通过options.pure选择， pureFinalPropsSelectorFactory还是impureFinalPropsSelectorFactory作为selectorFactory。pure为true，返回的selector函数将记住结果，并允许connectAdvanced的shouldComponentUpdate返回false，否则永远返回新的对象，并且shouldComponentUpdate总是返回true。 3. selectorFactory传入mapStateToProps，mapDispatchToProps，mergeProps，dispatch，options， 构建出选择函数(nextState: any, nextOwnProps: any) =&gt; any ### impureFinalPropsSelectorFactory 1. 接收mapStateToProps，mapDispatchToProps，mergeProps，dispatch。 2. 构建并返回不纯净的属性选择器:(state, ownProps) =&gt; mergeProps( mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps ) ```2.1.3. pureFinalPropsSelectorFactory 接收参数 mapStateToProps, mapDispatchToProps, mergeProps, dispatch, { areStatesEqual, areOwnPropsEqual, areStatePropsEqual 设置hasRunAtLeastOnce作为指示是否初始化的flag 2.1.3.1. handleFirstCall 传入firstState, firstOwnProps，赋予state，ownProps 执行mapStateToProps，mapDispatchToProps，mergeProps。 设置hasRunAtLeastOnce为true，返回mergeProps执行的结果（合并后的props） 2.1.3.2. handleSubsequentCalls 传入nextState, nextOwnProps 调用areOwnPropsEqual，areStatesEqual比较state，nextState和ownProps，nextOwnProps，从而设置propsChanged，stateChanged 将nextState, nextOwnProps赋予state，ownProps。 如果propsChanged和stateChanged都为true，表示都改变了，返回handleNewPropsAndNewState()。 仅propsChanged为true，返回handleNewProps() 仅stateChanged为true，返回handleNewState() 两者皆为false，表示状态和属性都没有变化，返回mergedProps（在上一次调用pureFinalPropsSelectorFactory时存储的mergedProps） 2.1.3.2.1. handleNewPropsAndNewState 执行mapStateToProps mapDispatchToProps.dependsOnOwnProps为true，则执行mapDispatchToProps 执行mergeProps并返回结果 2.1.3.2.2. handleNewProps mapStateToProps.dependsOnOwnProps为true，则执行mapStateToProps mapDispatchToProps.dependsOnOwnProps为true，则执行mapDispatchToProps 执行mergeProps并返回结果 2.1.3.2.3. handleNewState 执行mapStateToProps，结果存为nextStateProps 通过areStatePropsEqual比较nextStateProps和stateProps，并设置statePropsChanged stateProps = nextStateProps statePropsChanged为true，则执行mergeProps，结果赋予mergedProps（有些state变化并未引起state改变） 返回mergedProps 2.2. wrapMapToProps2.2.1. wrapMapToPropsConstant2.2.2. getDependsOnOwnProps2.2.3. wrapMapToPropsFunc参数：mapToProps, methodName返回代理选择器函数initProxySelector (dispatch: any, {displayName}: { displayName: any; }) =&gt; (stateOrDispatch: any, ownProps: any) =&gt; any 定义proxy return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch) proxy.dependsOnOwnProps通过调用getDependsOnOwnProps生成。 定义detectFactoryAndVerify函数作为proxy.mapToProps，在proxy执行时调用 返回proxy。proxy执行后即是返回计算后的props，无论传入mapToProps是多少阶的高阶函数。 2.2.3.1. detectFactoryAndVerify proxy.mapToProps = mapToProps let props = proxy(stateOrDispatch, ownProps) 此处即是执行了mapToProps(stateOrDispatch, ownProps)或mapToProps(stateOrDispatch) 如果结果props仍为函数,将props赋予proxy.mapToProps，递归执行proxy(stateOrDispatch, ownProps),在此步后, props必然已不是函数 非生产环境下，通过verifyPlainObject验证props 返回props","excerpt":"react-redux"},{"title":"redux","date":"2017-09-04T09:37:59.340Z","path":"FE/redux.html","text":"1.&nbspcreateStore1.1.&nbspensureCanMutateNextListeners1.2.&nbspgetState1.3.&nbspsubscribe1.4.&nbspdispatch1.5.&nbspreplaceReducer1.6.&nbspobservable1.6.1.&nbspsubscribe2.&nbspcombineReducers2.1.&nbspassertReducerSanity3.&nbspapplyMiddleware3.1.&nbspcompose4.&nbspbindActionCreators4.1.&nbspbindActionCreator1. createStore参数 reducer, preloadedState, enhancer 若preloadedState为函数，并且enhancer未传入,将preloadedState赋予enhancer，preloadedState置空。也就是两个参数时，第二个参数是enhancer。 若传入的enhancer不是函数，则提示enhancer应该是函数。 enhancer不为空，enhancer(createStore)(reducer, preloadedState)，则是将本身传入enhancer，enhancer的形式为next =&gt; (reducer, preloadedState) =&gt; store，这样实际将原生createStore置为最后工序。 reducer不是函数，提示reducer应该为函数。 将reducer和preloadedState使用currentReducer，currentState保存。isDispatching标识是否正在分发，默认为false。 分发{ type: ActionTypes.INIT }的action 返回对象： { dispatch, subscribe, getState, replaceReducer, [$$observable]: observable }1.1. ensureCanMutateNextListeners确保nextListeners可改变。若nextListeners和currentListeners是同一数组，使用slice复制currentListeners并赋予nextListeners 1.2. getState返回currentState 1.3. subscribe参数： listener, listener将在每次dispatch时调用。 listener不是函数，提示listener应该是函数。 建立isSubscribed为flag默认为true 调用ensureCanMutateNextListeners，确保nextListeners和currentListeners是不同数组。 将listener加入nextListeners中。 返回unsubscribe函数,改函数置isSubscribed为false，并将listener从nextListeners去除。 1.4. dispatch action不是plain object,提示actions必须为plain object, 需要使用中间件才能使用异步action。 isDispatching为true，标识正在分发其他actions, 抛出错误，reducer现在不能进行分发。 置isDispatching为true，并执行currentReducer(currentState, action),得到的结果赋予currentState，并将isDispatching置回false 将nextListeners置为currentListeners，并执行其中每个listener 返回action 1.5. replaceReducer参数：nextReducer 如果nextReducer不是函数, 提示nextReducer应该为函数。 nextReducer赋予currentReducer 分发dispatch({ type: ActionTypes.INIT }) 1.6. observable该函数作为[$$observable]的方法返回 将subscribe函数引用存储于outerSubscribe 返回对象，包括subscribe方法，[$$observable]方法，返回自身. 调用方法：store$$observable.subscribe({next: (currentState) =&gt; {dosometing…}}) 从而实现根据state的监视。 1.6.1. subscribe参数：observer一个必须含有next方法的对象 observer不是对象，则提示observer应该是个对象。 定义并调用observeState，该函数将当前state传入observer.next 将observeState作为listener，传入outerSubscribe，并作为unsubscribe返回。在这步中，由于outerSubscribe即是外层的subscribe函数，从而将observeState加入到nextListeners中，在下次dispatch时将会被执行。 2. combineReducers传入reducers，导出combineReducers函数，合并reduces，返回一个reducer const reducerKeys = Object.keys(reducers) 遍历reducerKeys，筛选出合法的reducer，存入finalReducers。 const finalReducerKeys = Object.keys(finalReducers) 使用assertReducerSanit校验finalReducers。 返回新的combination reducer，首先抛出校验错误。 遍历finalReducers，更新每个state[key]，合并为nextState并返回。 2.1. assertReducerSanity 遍历传入的reducers const initialState = reducer(undefined, { type: ActionTypes.INIT }) 如果得到的初始状态initialState为undefined，则警告Reducer初始化返回undefined，如果不想给reducer设值，可以返回null而不是undefined 将type为个随机值的action传入reducer，若返回的为undefined，则提示，若传入的action是个未知的action，应该返回未更改的当前状态。 // TODO 3. applyMiddleware参数： ...middlewares，每个中间件形式为({ getState, dispatch }) =&gt; next =&gt; action 返回根据中间件包装createStore的函数。 执行createStore，结果为store，取得原始dispatch = store.dispatch 复制store中的getState，dispatch构成middlewareAPI 将传入的每个中间件对middlewareAPI进行应用，从而都变为next =&gt; action 使用compose进行串联， 最后的next传入原始的store.dispatch，从而实现了所有中间件对原始store.dispatch的包裹。 使用包装后的dispatch代替原store.dispatch，并返回这个修饰后的store。 3.1. compose使用累加器不断包裹串联函数效果 return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args))) 4. bindActionCreators参数： actionCreators, dispatch actionCreators为函数，直接调用bindActionCreator包装后返回新的函数。 actionCreators既不是函数，也不是对象，则发出警告。 actionCreators为对象，将其每个属性使用bindActionCreator包装，并重组成对象，返回。 4.1. bindActionCreator使用dispatch包装actionCreator，使其可以直接dispatch生成的action","excerpt":"redux"},{"title":"linux-desktop","date":"2017-09-04T09:37:59.336Z","path":"Linux/linux-desktop.html","text":"1.&nbsp安装2.&nbsp远程桌面3.&nbsp安装Chrome4.&nbsp远程桌面4.1.&nbsp安装vnc server4.2.&nbsp安装xrdp4.3.&nbsp安装xfce4桌面4.4.&nbsp配置文件4.5.&nbsp重启服务1. 安装apt-get install ubuntu-desktop2. 远程桌面http://www.xuebuyuan.com/1791546.html 3. 安装Chromewget [https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb](https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb) sudo dpkg -i google-chrome-stable_current_amd64.deb以root运行：http://blog.sina.com.cn/s/blog_633763a2010137i3.html 1 进入 /opt/google/chrome 文件夹 2 找到 ‘google-chrome’ 文件 3 用 TextViewer打开或者VI编辑 4 将最后一行。 exec -a \"$0\" \"$HERE/chrome\" \"$@\" 替换为 exec -a \"$0\" \"$HERE/chrome\" \"$@\" --user-data-dir $HOME 5 保存，即可。4. 远程桌面4.1. 安装vnc server这步必须在安装xrdp之前，否则连接时会出现错误 apt-get install tightvncserver4.2. 安装xrdpapt-get install xrdp4.3. 安装xfce4桌面apt-get install xfce44.4. 配置文件将使用xfce4桌面写入配置文件 echo \"xfce4-session\" &gt;~/.xsession4.5. 重启服务sudo service xrdp restart","excerpt":"linux-desktop"},{"title":"linux-email","date":"2017-09-04T09:37:59.336Z","path":"FE/linux-email.html","text":"1.&nbspmutt/msmtp1.1.&nbsp安装1.2.&nbsp配置msmtp1.3.&nbsp配置mutt1.4.&nbsp测试1. mutt/msmtpmsmtp作为发送邮件的客户端，mutt作为邮件收发的通用工具 1.1. 安装apt-get install mutt msmtp1.2. 配置msmtp在根目录中建立.msmtprc文件，会自动做为配置文件 vi /root/.msmtprc编辑文件，以QQ邮箱为例，详细说明参见手册：http://msmtp.sourceforge.net/doc/msmtp.pdf host smtp.qq.com #smtp服务器 tls on#开启ssl tls_starttls off tls_trust_file /usr/lib/ssl/certs/ca-certificates.crt #需安装openssl以取得证书文件 auth plain from goumang2010@qq.com user goumang2010@qq.com password XXXX#密码 现qq邮箱已改为授权码[http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;no=1001256&amp;&amp;id=28](http://service.mail.qq.com/cgi-bin/help?subtype=1&amp;&amp;no=1001256&amp;&amp;id=28)1.3. 配置muttvi .muttrc或拷贝默认的配置文件： cp /etc/Muttrc /root/.muttrc在配置文件中加入msmtp信息 set sendmail=\"/usr/bin/msmtp\" set use_from=yes set from=goumang2010@qq.com set envelope_from=yes1.4. 测试向409567414@qq.com发一封测试邮件 echo \"Test\" | mutt -s \"Title\" 409567414@qq.com添加附件 echo \"Test\" | mutt 409567414@qq.com -a webpagetest_2.19.zip -s \"Title\"","excerpt":"linux-email"},{"title":"design-pattern","date":"2017-09-04T09:37:59.336Z","path":"FE/design-pattern.html","text":"摘自：曾探. JavaScript设计模式与开发实践 (图灵原创) . 人民邮电出版社. Kindle 版本. 1.1.&nbsp单例模式1.2.&nbsp策略模式1.3.&nbsp代理模式1.3.1.&nbsp图片加载1.3.2.&nbsp缓存1.4.&nbsp观察者模式（发布-订阅）1.5.&nbsp命令模式1.6.&nbsp组合模式1.7.&nbsp职责链模式1.8.&nbsp中介者模式1.1. 单例模式var Singleton = function(name) { this.name = name; this.instance = null; }; Singleton.prototype.getName = function() { alert(this.name); }; // 惰性单例 Singleton.getInstance = (function() { var instance = null; return function(name) { if (!instance) { instance = new Singleton(name); } return instance; } })(); var a = Singleton.getInstance('sven1'); var b = Singleton.getInstance('sven2'); alert(a === b); // true1.2. 策略模式将行为封装成函数https://codepen.io/goumang2010/pen/weJQvm 1.3. 代理模式1.3.1. 图片加载var myImage = (function() { var imgNode = document.createElement('img'); document.body.appendChild(imgNode); return { setSrc: function(src) { imgNode.src = src; } } })(); var proxyImage = (function() { var img = new Image; img.onload = function() { myImage.setSrc(this.src); } return { setSrc: function(src) { myImage.setSrc('loading.gif'); img.src = src; } } })(); proxyImage.setSrc('realImage.jpg');1.3.2. 缓存var createProxyFactory = function(fn) { var cache = {}; return function() { var args = Array.prototype.join.call(arguments, ','); if (args in cache) { return cache[args]; } return cache[args] = fn.apply(this, arguments); } };1.4. 观察者模式（发布-订阅）https://codepen.io/goumang2010/pen/NgpEXe 1.5. 命令模式将行为抽象封装成指令，要求行为都有相似的结构 https://codepen.io/goumang2010/pen/gRmQzK 1.6. 组合模式把指令组合成树形结构 既可以执行单独命令，也可以执行组合后的命令，因为无论是单独命令还是组合命令，都部署了同样的执行接口 https://codepen.io/goumang2010/pen/zzZMyK 1.7. 职责链模式将分支流程的各个步骤拆分出函数 var order500 = function(orderType, pay, stock) { if (orderType === 1 &amp;&amp; pay === true) { console.log('500 元定金预购， 得到100优惠券'); } else { return 'nextSuccessor'; } }; var order200 = function(orderType, pay, stock) { if (orderType === 2 &amp;&amp; pay === true) { console.log('200 元定金预购， 得到50优惠券'); } else { return 'nextSuccessor'; } }; var orderNormal = function(orderType, pay, stock) { if (stock &gt; 0) { console.log('普通 购买， 无优惠券'); } else { console.log('手机库存不足'); } }; // Chain. prototype. setNextSuccessor 指定 在 链 中的 下一个 节点 // Chain. prototype. passRequest 传递 请求 给 某个 节点 var Chain = function(fn) { this.fn = fn; this.successor = null; }; Chain.prototype.setNextSuccessor = function(successor) { return this.successor = successor; }; Chain.prototype.passRequest = function() { var ret = this.fn.apply(this, arguments); if (ret === 'nextSuccessor') { return this.successor &amp;&amp; this.successor.passRequest.apply(this.successor, arguments); } return ret; }; var chainOrder500 = new Chain(order500); var chainOrder200 = new Chain(order200); var chainOrderNormal = new Chain(orderNormal); chainOrder500.setNextSuccessor(chainOrder200); chainOrder200.setNextSuccessor(chainOrderNormal); chainOrder500.passRequest(1, true, 500); // 输出： 500 元定金预购， 得到100优惠券 chainOrder500.passRequest(2, true, 500); // 输出： 200 元定金预购， 得到50优惠 券 chainOrder500.passRequest(3, true, 500); // 输出： 普通购买， 无优惠券 chainOrder500.passRequest(1, false, 0); // 输出： 手机库存不足1.8. 中介者模式充当指挥者和调度者，解耦客户对象间的关系","excerpt":""},{"title":"domain","date":"2017-09-04T09:37:59.336Z","path":"FE/domain.html","text":"1.&nbsp域名解析1.1.&nbsp使用DNSpod进行域名解析2.&nbsp域名配置2.1.&nbsp子域名映射2.2.&nbsp端口及域名映射1. 域名解析1.1. 使用DNSpod进行域名解析 进入域名商的管理页面，万网入口：http://dc.aliyun.com/basic/ 输入DNSpod的解析服务器的地址，参照：https://support.dnspod.cn/Kb/showarticle/tsid/40/ 在DNSPod的管理页面中添加域名解析：https://www.dnspod.cn/console/dns 2. 域名配置修改配置文件参见：Apache部署##Apache配置 2.1. 子域名映射将wiki.liqiune.xyz映射至/var/www/html/wiki的网站 &lt;VirtualHost *:80&gt; DocumentRoot /var/www/html/wiki ServerName wiki.liqiune.xyz ServerAlias wiki.liqiune.xyz ErrorLog \"/var/www/html/wiki/logs/error.log\" CustomLog \"/var/www/html/wiki/logs/access.log\" combined &lt;/VirtualHost&gt;注意”/var/www/html/wiki/logs/error.log”及”/var/www/html/wiki/logs/access.log”需要事先建立 之后重启Apache：Apache部署##Apache重启 2.2. 端口及域名映射放弃使用不安全的Proxy，转用rewrite作为跳转 &lt;VirtualHost *:80&gt; ServerName note.liqiune.xyz ServerAlias note.liqiune.xyz RewriteEngine on RewriteRule \"^/(.*)\" \"[http://note.liqiune.xyz](http://note.liqiune.xyz):3000\" [R,L] &lt;/VirtualHost&gt;参考：http://segmentfault.com/q/1010000000095724注意：当未安装Proxy模块时，服务器将不能正常启动。通过journalctl -xe 查看，会提示：Invalid command ‘ProxyPass’, perhaps misspelled or defined by a module …这时需要进入/etc/apache2/mods-available 目录，启用代理模块： a2enmod proxy之后重启Apache：Apache部署##Apache重启 参考：http://wiki.ubuntu.org.cn/Apache%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E6%8C%87%E5%8D%97","excerpt":"domain"},{"title":"foreverjs","date":"2017-09-04T09:37:59.336Z","path":"FE/forever.html","text":"参照：https://cnodejs.org/topic/5021c2cff767cc9a51e684e3 github：https://github.com/foreverjs/forever 全局安装forevernpm install forever -g 启动（文件变化自动重启,同时监视文件及文件夹)forever start app.js --watchDirectory --watch-w慎用，见：https://github.com/foreverjs/forever/issues/235 列出所有运行的脚本forever list 注意：当增加npm模块后，需要在布置的机器上运行npm install","excerpt":"foreverjs"},{"title":"git","date":"2017-09-04T09:37:59.336Z","path":"FE/git.html","text":"1.&nbsp安装1.1.&nbsp安装ssh1.2.&nbsp安装git1.3.&nbsp生成ssh密钥1.4.&nbsp在github上配置密钥2.&nbsp命令2.1.&nbsp克隆拉取2.2.&nbsp添加提交2.3.&nbsp远程推送2.4.&nbsppull request2.5.&nbsp合并2.5.1.&nbsp单个文件2.5.2.&nbsp强制合并2.5.2.1.&nbsp保留当前2.5.2.2.&nbsp保留远程2.5.3.&nbsp撤销合并2.6.&nbsp清理2.6.1.&nbsp清理未跟踪的文件3.&nbsp分支3.1.&nbsp删除分支4.&nbsp子模块4.1.&nbspsubtree1. 安装1.1. 安装ssh安装：apt-get install openssh-server openssh-client重启服务： /etc/init.d/ssh restart 1.2. 安装gitapt-get install git-core 1.3. 生成ssh密钥 输入命令： ssh-keygen -C ‘goumang2010@live.com’ -t rsa（’goumang2010@live.com’ 是我的github邮箱）-C为提供注释 -t rsa表示生成的类型为rsa一路回车即可 1.4. 在github上配置密钥 获取密钥文件，把该文件拷贝至ftp目录： cp ~/.ssh/id_rsa.pub /home/ftp/data 使用编辑器打开该文件，打开Github，点击自己图标=&gt;Settings，在左侧点击 SSH Keys，然后点击Add SSH key，title随便起，在Key处把id_rsa.pub文件的’’’全部内容’’’复制进去，然后点击Add Key，输入自己的Github密码后保存。 在Ubuntu中键入ssh -v git@github.com进行测试 出现Exit status 1表示成功，测试后，github上该key的绿灯也会亮起来 2. 命令2.1. 克隆拉取 将项目克隆至本地：git clone git@github.com:goumang2010/NetClipBoard.git （goumang2010为用户名，NetClipBoard为项目名称） 拉取commit并与本地同步（首先需进入git仓库所在目录：cd /home/ftp/data/NetClipBoard/） ： git pull 2.2. 添加提交 添加所有文件及修改：git add -A 提交git commit -m \"your message\" 2.3. 远程推送参照：https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/ 设置远程目录： git remote add origin git@github.com:xxx.git 推送至远程目录 git push origin master 修改远程目录 git remote set-url origin https://github.com/USERNAME/OTHERREPOSITORY.git 参考：https://help.github.com/articles/adding-an-existing-project-to-github-using-the-command-line/ 2.4. pull request fork原项目 新建分支并切换至该分支 git branch newbranchname git checkout newbranchname 推送分支到远程 git push --set-upstream origin newbranchname 在github界面上发起pull request参考:http://blog.csdn.net/zhangdaiscott/article/details/17438153 2.5. 合并2.5.1. 单个文件git checkout A git checkout --patch B fhttp://stackoverflow.com/questions/10784523/how-do-i-merge-changes-to-a-single-file-rather-than-merging-commits 2.5.2. 强制合并2.5.2.1. 保留当前git merge -s recursive -X ours branchB git pull类似： git pull -s recursive -X ours 注意： 如果使用： git pull -s ours 将忽略传入方的所有历史 2.5.2.2. 保留远程git merge -s recursive -X theirs branchB git pull类似：git pull -s recursive -X theirs 如果连递归也不用，遇到不同直接采用他方的： git merge -X theirs branchB http://stackoverflow.com/questions/173919/is-there-a-theirs-version-of-git-merge-s-ours 2.5.3. 撤销合并撤销上次合并并保留工作区修改： git reset --merge ORIG_HEAD http://stackoverflow.com/questions/2389361/undo-a-git-merge-that-hasnt-been-pushed-yet 2.6. 清理2.6.1. 清理未跟踪的文件git clean -fd http://stackoverflow.com/questions/61212/how-to-remove-local-untracked-files-from-the-current-git-branch 3. 分支3.1. 删除分支git push origin --delete &lt;branch_name&gt; git branch -d &lt;branch_name&gt;4. 子模块4.1. subtree 建立subtree, 注意folderpath不应该存在，但其上级必须存在：git subtree add -P folderpath repourl branch 将branch中的更改拉取到文件夹中，在add时会自动执行这项，注意两者的历史必须一致，否则将覆盖根目录，删除出subtree外的其他东西：git subtree pull -P folderpath repourl branch make some changes and commit them 修改推送回远程分支git subtree push -P folderpath repourl branch","excerpt":"git"},{"title":"html","date":"2017-09-04T09:37:59.336Z","path":"FE/html.html","text":"https://github.com/slashhuang/translation/blob/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6 http://domenicodefelice.blogspot.sg/2015/08/how-browsers-work.html 1.&nbsp原理1.1.&nbsp两个模块1.2.&nbsp四个阶段1.2.1.&nbsp解析dom和cssom1.2.2.&nbsp渲染render tree1.2.3.&nbsplayout(flow/reflow)阶段1.2.4.&nbsppaint阶段1.3.&nbspreflow和repaint优化1.3.1.&nbsp是什么触发了reflow和repaint？1.3.2.&nbspreflow和repaint哪个性能开销更大？1.3.3.&nbsp如何优化css和html以减少reflow？1.3.4.&nbsp优化javascript1.3.5.&nbsp同步布局与布局垃圾1.3.6.&nbsprequestAnimationFrame1.3.7.&nbsp虚拟dom库2.&nbsphtml parser2.1.&nbsphttp2.2.&nbspcss1. 原理1.1. 两个模块浏览器的两个主模块 rendering engine 渲染引擎或者称为布局引擎(layout engine) javascript解析器 火狐使用Gecko(由mozilla发明)，Safari和谷歌的chrome都使用webkit引擎。谷歌的chrome在版本27之后使用Blink引擎。 1.2. 四个阶段渲染引擎的工作:从基本的html css js 开始渲染整个屏幕的网页，粗浅的经过四个阶段 解析html为dom树，解析css为cssom。 把dom和cssom结合起来生成渲染树render tree 布局render tree，计算几何形状 把render tree展示到屏幕上 以上四步同时并多次执行 由于浏览器会尝试尽快展示内容，所以内容有时会在样式还没有加载的时候展示出来。这就是经常发生的FOCU(flash of unstyled content)问题。 1.2.1. 解析dom和cssom 在这个阶段，引擎html parser开始解析html，解析出来的结果会成为一棵dom树。html和dom并不是1:1的关系，dom树的根节点是元素 dom树的目的至少有2个：1. 作为下个阶段render tree的输入。 2. 成为网页和脚本的接口。(如 getElementById) 当所有的html解析完成，整个document被标记可交互的，它的状态显示为完成。 defer脚本会被执行 load event会被执行 1.2.2. 渲染render treedom节点和cssom会合并渲染新的树状图。它的结构和dom树类似，但不是完全一样:只有可见元素才会在这棵树中(以下称为tree);例如head，script标签都不会在树中，所有拥有display:none样式的节点也不会在树中。整个结构是按照它们的渲染顺序可视化的树状图，每个节点都存储着应用在它上面的css属性。这些节点在不同的浏览器中被称为不同的: webkit称它为renderers firefox称它为frames 有些时候节点也直接称为boxes。 1.2.3. layout(flow/reflow)阶段一个节点的图形位置和尺寸，有时在css样式表中规定，有时不在。不管如何，它们都必须被计算，以便所有的节点能正确的渲染。浏览器会从根节点遍历render tree, 进行图形计算，这时相关的在css中使用的单元都转化成pixels。 1.2.4. paint阶段这个阶段也被称为”绘制”(painting)或repainting，所有的节点被遍历，从root开始，调用paint的方法。 1.3. reflow和repaint优化有重要的两点： 整个过程很耗费性能(阻塞式) 它们可以重新被触发 reflows和repaints不可避免，但是降低它们的频率可以提升我们网站的加载速度 1.3.1. 是什么触发了reflow和repaint？ javascript操作页面 dom操作(增加或者移除dom) 样式表操作(增加或者移除样式规则) 用户操作(例如): a标签的鼠标悬浮效果 滚动页面 input标签中输入文字 resize窗口 浏览器会尽可能少的对改变做出响应，因此reflow及repaint可以是全局的，也可以是增量的。reflow和repaint不必同时发生，例如: 如果只是改变元素的颜色，那么只会触发repaint 如果改变一个元素的位置，将会触发reflow和repaint 1.3.2. reflow和repaint哪个性能开销更大？我们必须考虑到浏览器将会使用大量缓存来避免重新计算。 一个repaint需要浏览器遍历元素来决定哪些是可见的，哪些事必须展示的 一个reflow重新计算元素的几何状态(geometry)，会递归的(recursively)reflow它的子元素，有时还包括它的相邻元素(siblings) 一个reflow将会触发repaint来更新网页 1.3.3. 如何优化css和html以减少reflow？ css越是简洁，reflow越快 dom的层级越多，reflow的性能开销越大 有些元素的display模式比其他的性能开销更大 行内样式会产生一个更深层次的reflow(further reflow) 有自动的单元宽度的\\性能开销大，因为浏览器需要更多的步骤计算单元格的尺寸 使用flexbox布局性能开销大，因为flex元素的图形能在解析的时候发生改变 1.3.4. 优化javascript优化优化css和html的重要程度不如javascript， 如下例所示： var foo = document.getElementById('foobar'); foo.style.color = 'blue'; var margin = parseInt(foo.style.marginTop); foo.style.marginTop = (margin + 10) + 'px';由于reflow和repaint在性能开销上很大，浏览器会累积你在同一个时间片段(timeframe)里的所有的dom操作，进入队列(queue)，批量处理它们，我们来分析上面那段代码: 在改变颜色属性后，这个操作被放在累积队列里面(accumulating queue),然后我们寻找元素的style。这个操作会强制一个提前的repaint。当我们改变dom的元素的时候，元素被标记为脏的(dirty)，有时它的children也会被标记为脏的(dirty)，意味着至少它的一个子元素要reflow。interval之后，所有的被标记为脏的元素会重新reflow和repaint。请求一个标记为脏的元素的属性，会触发浏览器的提前reflow。 1.3.5. 同步布局与布局垃圾针对dom的交替读写操作会引发布局垃圾=—性能杀手我们如何避免垃圾？ 重新组合对dom读写的命令 缓存已计算的样式 不要使用style来改变样式，选择用css 在dom之外操作元素， document fragments 尽可能将有动画的元素position设置为fixed或者absolute，这样更新这些元素的geometry的时候不会影响其他元素 只在有必要的时候将元素展示出来 使用window.requestAnimationFrame() 使用虚拟dom库 1.3.6. requestAnimationFramewindow.requestAnimationFrame()允许我们在下一次reflow的时候执行代码（每个元素读取属性不会单独触发reflow），这个很有用，因为它允许我们交叉读写，同时以最优顺序执行它们，eg: function doubleHeight(element) { var currentHeight = element.clientHeight; element.style.height = (currentHeight * 2) + 'px'; } all_my_elements.forEach(doubleHeight);function doubleHeight(element) { var currentHeight = element.clientHeight; window.requestAnimationFrame(function () { element.style.height = (currentHeight * 2) + 'px'; }); } all_my_elements.forEach(doubleHeight);使用settimeout(fn,0)粗略的获得相同的结果，因为settimeout通常会在下次reflow的时候执行 1.3.7. 虚拟dom库优势： - 聚集操作 - 应用启发式方法 - 缓存值 - 在合适的时候操作DOM， 避免布局垃圾2. html parser html解析器是个可重入的解析器(这意味着它可接受动态输入)，这让第一阶段的解析更加的复杂。 为何html解析器是可重入的？ 当浏览器解析到script标签的时候，js代码是立刻执行的 js可以修改html，例如通过(document.write) html解析是同步的(synchronous)，当解析器到达script标签的时候： html解析器停止解析（非async defer） 如果是外部脚本，就从外部网络获取脚本代码 将控制权交给js引擎，执行js代码 恢复html解析器的解析 这也是script标签移到页面底部的原因 在Gecko和webkit,当引擎被获取和执行脚本所阻塞的时候，会开启第二个进程(thread)开始解析文档(document)寻找外部的资源进行加载，它不会修改dom,但是会开始获取外部的资源。 css是阻塞的, 因为： js有可能会寻求未被解析的css信息 浏览器会保持渲染进程直到cssom建立起来 所以： script脚本放在页面底部 将样式表按照media type和media query区分，这样有助于我们将css资源标记成非阻塞渲染的资源，非阻塞的资源还是会被浏览器下载，只是优先级较低。 2.1. http很多浏览器能够同时下载超过2个的资源，在2014 RFC2616发布的http/1.1 中移除了2个连接的限制。根据browserscope.org的测试，现在主流的浏览器基本能达到同时发送6个http请求，ie11能够达到13个。若是http2， 则没有必要优化连接数 2.2. css所有的样式表都会被解析成cssom对象模型(就和dom树一样展现结构)。每一个页面element都会被许多css规则匹配， 匹配顺序：origin =&gt; weight =&gt; specificity=&gt; order of definition origin: 作者自定义 浏览器使用者定义 userAgent 定义 weight normal weight !important weight specificity，即是css选择器的权重(a,b,c,d)的规则决定。 a : 值为1(当样式放在style属性中的时候)，0为其它情况 b : id在样式规则中出现的次数 eg:#slide #hello p的值就是2 c : class，伪类，和属性在样式中出现的次数 eg:input[type=email]值就是2 d : 标签个数(tag names)和伪类元素出现的次数 css规则会根据特定的选择器，分别加入对应的hash表中，当浏览器试图寻找哪个样式表加载到元素上的时候，它没必要查看所有的规则，而只需要查看哈希表。实际上，写css只需匹配最右边的(rightmost)的选择器，这个选择器称为主选择器(key selector)。由于浏览器是由右向左解析，所以以下例子中选择#container2 a时，将会先选择所有a元素，再筛选父级中含有#container2的元素。 &lt;div id=”container1”&gt; … thousands of &lt;a&gt; elements here … &lt;a&gt; … &lt;/a&gt; … thousands of &lt;a&gt; elements here … &lt;/div&gt; &lt;div id=”container2”&gt; &lt;a class=”a-class”&gt;...&lt;/a&gt; &lt;/div&gt;所以改为#container2 .a-class或.a-class更有效率。将$(‘#container .class-name’)改为$(‘.class-name’, ‘#container’)可以很好的性能。前者会先去寻找.class-name然后再沿着dom树寻找#container元素,后者会先找到#container，然后再沿着子树寻找.class-name的元素。","excerpt":"html"},{"title":"http","date":"2017-09-04T09:37:59.336Z","path":"FE/http.html","text":"1.&nbsp报文1.1.&nbsp格式1.2.&nbsp状态码1.2.1.&nbspexamples1.3.&nbspexamples1.3.1.&nbsp一个客户端的post请求报文1.3.2.&nbsp显示请求报文2.&nbsp缓存2.1.&nbsp缓存存储策略2.2.&nbsp缓存过期策略2.2.1.&nbsp没有max-age或Expires时的策略2.3.&nbsp缓存对比策略2.3.1.&nbsp为何使用Etag2.4.&nbspexamples2.4.1.&nbspno cache server2.4.2.&nbsp公共缓存一年1. 报文1.1. 格式 1.2. 状态码 code 状态信息 含义 100 Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新） 101 Switching Protocols 服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新） 200 OK 一切正常，对GET和POST请求的应答文档跟在后面。 201 Created 服务器已经创建了文档，Location头给出了它的URL。 202 Accepted 已经接受请求，但处理尚未完成。 203 Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。 204 No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。 205 Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。 206 Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。 300 Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。 301 Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。 302 Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求http://host/~user（缺少了后面的斜杠），有的服务器 返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。 303 See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。 304 Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告 诉客户，原来缓冲的文档还可以继续使用。 305 Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。 307 Temporary Redirect 和302 （Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定 向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只 能跟随对GET请求的重定向。（HTTP 1.1新） 400 Bad Request 请求出现语法错误。 401 Unauthorized 客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填 写合适的Authorization头后再次发出请求。 403 Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。 404 Not Found 无法找到指定位置的资源。这也是一个常用的应答。 405 Method Not Allowed 请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新） 406 Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。 407 Proxy Authentication Required 类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新） 408 Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新） 409 Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新） 410 Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而 404表示由于未知的原因文档不可用。（HTTP 1.1新） 411 Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新） 412 Precondition Failed 请求头中指定的一些前提条件失败（HTTP 1.1新）。 413 Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。 414 Request URI Too Long URI太长（HTTP 1.1新）。 416 Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新） 500 Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。 501 Not Implemented 服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。 502 Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 503 Service Unavailable 服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。 504 Gateway Timeout 由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新） 505 HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新） 1.2.1. exampleshttps://nodejs.org/docs/latest/api/http.html#http_http_status_codes const http = require('http'); console.log(JSON.stringify(http.STATUS_CODES, null, 4));1.3. examples1.3.1. 一个客户端的post请求报文POST/servlet/default.jsp HTTP/1.1 !--- 这是一个POST方法请求行，指出了所附加的消息的URL和所用的HTTP版本为1.1 Accept-Language:zh-cn,zh !--- 指定客户端可以接受的语言 Accept-Charset:GB2312,utf-8 !--- 指定客户端可以接受的字符集为GB2312和utf-8 Accept:text/html,application/xhtml+xml,application/xml !--- 指定客户端浏览器支持的MIME类型分别是text/html、application/xhtml+xml、application/xml Accept-Encoding:gzip,deflate !--- 指定客户端浏览器支持的压缩编码格式为gzip和deflate User-Agent:Mozilla/5.0 !--- 指定客户端使用的浏览器为Mozilla 5.0版本 Host:www.51cto.com !--- 指定客户端要访问的服务器域名为www.51cto.com Connection:Keep-Alive !--- 指定采用持续连接方式 （这里有一个空行） user=winda＆pwd=1234 !--- 此行为向服务器提交的用户账户为winda，密码为12341.3.2. 显示请求报文const http = require('http'); const testServer = http.createServer(function(req, res) { res.end('just a test'); }).listen(3000); testServer.on('connection', function(socket) { socket.pipe(process.stdout); });使用curl 请求 curl -d \"param1=value1&amp;param2=value2\" \"http://localhost:3000/\"显示： POST / HTTP/1.1 User-Agent: curl/7.35.0 Host: localhost:3000 Accept: */* Content-Length: 27 Content-Type: application/x-www-form-urlencode2. 缓存http://www.tuicool.com/articles/zUZnUrehttps://my.oschina.net/leejun2005/blog/369148 2.1. 缓存存储策略Cache-Control 头里的 Public、Private、no-cache、max-age 、no-store 他们都是用来指明响应内容是否可以被客户端存储的，其中前4个都会缓存文件数据（关于 no-cache 应理解为“不建议使用本地缓存”，其仍然会缓存数据到本地），后者 no-store 则不会在客户端缓存任何响应数据。 2.2. 缓存过期策略max-age决定， no-cache视为Cache-Control：max-age=0 ，Cache-Control中的maxAge等同Expires：当前客户端时间 + maxAge， 但Expires和Cache-Control中的max-age同时存在时，以Cache-Control为准。缓存过期后，请求发出时会请求服务器，服务器会根据情况返回200或304。 2.2.1. 没有max-age或Expires时的策略以Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期 2.3. 缓存对比策略If-Modified-Since（由之前服务端设置的Last-Modified决定）、If-None-Match（由之前服务端设置的Etag决定） 2.3.1. 为何使用EtagLast-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形 2.4. examples2.4.1. no cache serverconst http = require('http'); const testServer = http.createServer(function(req, res) { res.writeHead(200, { 'Content-Type': 'text/plain', 'Cache-Control': 'private, no-cache, no-store, must-revalidate', 'Expires': '-1', 'Pragma': 'no-cache' // for http1.0 equivalent to Cache-Control }); res.end('just test'); }).listen(3000);使用express： const express = require('express'); const app = express(); app.use(function(req, res, next) { res.header('Cache-Control', 'private, no-cache, no-store, must-revalidate'); res.header('Expires', '-1'); res.header('Pragma', 'no-cache'); next(); }) app.all('/', function(req, res, next) { res.end('just test') }) const server = app.listen(3000);2.4.2. 公共缓存一年const http = require('http'); const testServer = http.createServer(function(req, res) { res.writeHead(200, { 'Content-Type': 'text/plain', 'Cache-Control': 'public, max-age=31557600' }); res.end('just test'); }).listen(3000);","excerpt":"http"},{"title":"https","date":"2017-09-04T09:37:59.336Z","path":"FE/https.html","text":"1.&nbsp握手原理1.1.&nbsp验证数字证书2.&nbspdemo2.1.&nbsphttps服务1. 握手原理http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html 客户端请求，发送client random 及支持的cipher，比如TLS 1.0版 服务端发送server random 及证书，证书中包含公钥，此时服务器也会生成session ID 客户端验证证书并取出公钥，若验证通过，生成premaster secret(同样是随机数)， 并使用公钥加密，发送给服务端. 服务端和客户端都通过协商好的cipher方法，根据client random， server random， premaster secret生成session key，为可同时加密解密的对称密钥，用于之后的会话。 1.1. 验证数字证书http://www.cnblogs.com/zery/p/5164795.html 验证证书是否在有效期内。 验证证书是否被吊销了， 验证吊销有CRL(证书吊销列表)和OCSP(在线证书检查)两种方法。 查询系统内信任的根证书， 验证证书是否是上级CA签发的，并取得CA公钥。 证书是经过CA用自己的私钥，对服务端的公钥和一些相关信息一起加密，所以用CA公钥可解密并验证服务端公钥。 2. demo2.1. https服务 https://gaboesquivel.com/blog/2014/nodejs-https-and-ssl-certificate-for-development/ 安装openssl 生成私钥和自签名数字证书（使用自己私钥而非CA私钥签名的数字证书） openssl genrsa -out key.pem openssl req -new -key key.pem -out csr.pem openssl x509 -req -days 9999 -in csr.pem -signkey key.pem -out cert.pem rm csr.pem node创建https // https://nodejs.org/docs/latest/api/https.html#https_https_createserver_options_requestlistener // https://nodejs.org/docs/latest/api/tls.html#tls_tls_createsecurecontext_options var https = require('https'); var fs = require('fs'); var pkey = fs.readFileSync('key.pem'); var pcert = fs.readFileSync('cert.pem') var options = { key: pkey, cert: pcert }; var server = https.createServer(options, function (req, res) { res.writeHead(200); res.end(\"hello world\\n\"); }).listen(443);","excerpt":"https"},{"title":"javascript","date":"2017-09-04T09:37:59.336Z","path":"FE/javascript.html","text":"1.&nbsp事件监听2.&nbsp类型检测1. 事件监听 DOM直接调用 doms[i].click= function() { .... } addEventListener方式和IE私有的attachEvent方式 try { doms[i].addEventListener('mouseover',show_color,false); doms[i].addEventListener('mouseout',hide_color,false); } catch(e) { doms[i].attachEvent('onmouseover',for_ie(doms[i],show_color)); doms[i].attachEvent('onmouseout',for_ie(doms[i],hide_color)); }2. 类型检测var isType = function (type) { return function (obj) { return toString.call(obj) == '[object ' + type + ']'; }; }; var isString = isType('String'); var isFunction = isType('Function');","excerpt":"javascript"},{"title":"kindle","date":"2017-09-04T09:37:59.336Z","path":"FE/kindle.html","text":"1.&nbsp文档传递1.1.&nbsp复制粘贴1.1.1.&nbspPC1.1.2.&nbspAndroid1.2.&nbsp邮箱发送1. 文档传递1.1. 复制粘贴1.1.1. PC个人文档文件夹下的My Kindle Content文件夹，如：C:\\Users\\yourusername\\Documents\\My Kindle Content 1.1.2. Android外置SD或内置SD卡下的kindle目录 1.2. 邮箱发送使用kindle账号对应的邮箱，如：youremail@kindle.cn, 可以通过以下链接查看：https://www.amazon.cn/mn/dcw/myx.html#/home/devices/1","excerpt":"kindle"},{"title":"lftp","date":"2017-09-04T09:37:59.336Z","path":"FE/lftp.html","text":"1.&nbsp安装使用2.&nbsp参考1. 安装使用apt-get install lftplftp IPIP替换为FTP服务器地址 login username登录，系统会提示输入密码 ls列出目录 mirror [-c] [--parallel=n] [-R] 远程目录 本地目录其中-c是断点续传参数，–parallel是多线程参数，-R是反镜像参数。 2. 参考http://blog.chinaunix.net/uid-215617-id-2213078.html","excerpt":"lftp"},{"title":"linux-authority","date":"2017-09-04T09:37:59.336Z","path":"Linux/linux-authority.html","text":"1.&nbsp概念2.&nbsp数字对照3.&nbsp参考1. 概念所有者 一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者 用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名 文件名来修改文件的所有者 文件所在组 当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp 组名 文件名来修改文件所在的组 其它组 除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组 2. 数字对照-rw------- (600) -- 只有属主有读写权限。 -rw-r--r-- (644) -- 只有属主有读写权限；而属组用户和其他用户只有读权限。 -rwx------ (700) -- 只有属主有读、写、执行权限。 -rwxr-xr-x (755) -- 属主有读、写、执行权限；而属组用户和其他用户只有读、执行权限。 -rwx--x--x (711) -- 属主有读、写、执行权限；而属组用户和其他用户只有执行权限。 -rw-rw-rw- (666) -- 所有用户都有文件读、写权限。这种做法不可取。 -rwxrwxrwx (777) -- 所有用户都有读、写、执行权限。更不可取的做法。3. 参考http://blog.chinaunix.net/uid-26960488-id-3442817.html http://blog.chinaunix.net/uid-25052030-id-174343.html http://www.cnblogs.com/123-/p/4189072.html http://blog.csdn.net/nzing/article/details/9166057","excerpt":"linux-authority"},{"title":"linux-command","date":"2017-09-04T09:37:59.336Z","path":"Linux/linux-command.html","text":"1.&nbsp常用命令1.1.&nbsp系统运行情况1.2.&nbspapt-get1.3.&nbspkill1.4.&nbspHistory1.5.&nbspcd1.6.&nbspnetstat1.7.&nbspcat1.8.&nbspchmod2.&nbsp快捷键2.1.&nbsp复制粘贴1. 常用命令1.1. 系统运行情况 进程Pid及名称：ps -e 查看总体运行及详细情况：top-M为按照内存占用大小排序 查看内存总体使用情况：free -m 查看详细内存使用情况：cat /proc/meminfo 1.2. apt-get安装： apt-get install pkgname卸载： apt-get remove pkgname完全卸载（删除配置文件）： apt-get purge pkgname1.3. killkill pidpid替换为pid号 1.4. History用于查看命令行输入历史，直接键入即可；打开记录历史命令的文件： vim ~/.bash_history复制文件到Share文件夹： cp ~/.bash_history ~/Share注意：若为FTP服务器，则FTP不支持.bash_history这种名称的文件 则需指定文件名： cp ~/.bash_history /home/ftp/data/note.txt参考：http://www.2cto.com/os/201411/348554.html 1.5. cd 进入根目录：cd / 进入当前用户的目录（/home/username,root用户为/root）：cd ~/ 退回上一层（注意空格）：cd .. 1.6. netstat 查看Mysql监听端口：netstat -an|grep 3306 1.7. cat用于查看或创建文件 查看详细内存使用情况：cat /proc/meminfo参考：http://www.2cto.com/os/201207/143561.html 1.8. chmod-R 表示递归 chmod -R 755 /home/ftp/data/Resume将/home/ftp/data/Resume下所有文件及目录递归的设置为755权限（读取执行全权，所有者可写入） 2. 快捷键2.1. 复制粘贴 终端 复制：Ctrl + Shift + C 粘贴：Ctrl + Shift + V 控制台 复制：Ctrl + Insert 或鼠标选中。 粘贴：Shift + Insert或单击鼠标滚轮。","excerpt":"linux-command"},{"title":"linux-config","date":"2017-09-04T09:37:59.336Z","path":"FE/linux-config.html","text":"1.&nbsp虚拟内存1.1.&nbsp参考2.&nbsp部署脚本2.1.&nbspphp网站2.2.&nbspnode环境2.3.&nbsp其他2.4.&nbspapt-get总安装命令2.5.&nbsp备份脚本2.5.1.&nbsp程序备份2.5.2.&nbsp数据库备份1. 虚拟内存 输入以下命令进行配置1G的交换区（虚拟内存）：``` /dev/zero是一个输入设备，你可你用它来初始化文件。该设备无穷尽地提供0，可以使用任何你需要的数目——设备提供的要多的多。他可以用于向设备或文件写入字符串0。dd if=/dev/zero of=/var/swap bs=1024 count=1048576mkswap /var/swap 600权限表示仅是属主有读写权chmod 600 /var/swapswapon /var/swap 当内存使用70%的时候开始使用虚拟内存sysctl vm.swappiness=30echo “vm.swappiness=30” &gt;&gt; /etc/sysctl.conf 使系统倾向于保留缓存echo “vm.vfs_cache_pressure=50” &gt;&gt; /etc/sysctl.conf``` 1.1. 参考http://blog.csdn.net/nzing/article/details/9166057 http://blog.itpub.net/29371470/viewspace-1250975 http://blog.sina.com.cn/s/blog_8b5bb24f01016y3o.html http://blog.sina.com.cn/s/blog_4b4de658010006m7.html 2. 部署脚本2.1. php网站安装： apt-get install apache2 mysql-server php5 php5-mysql phpmyadmin配置：[Apache部署]] [MySQL安装配置 2.2. node环境node安装 2.3. 其他 vsftpd ShadowSocks-libev搭建 Ubuntu下mongoDB安装 Ubuntu下安装github 2.4. apt-get总安装命令apt-get install apache2 mysql-server mongodb vsftpd build-essential autoconf libtool libssl-dev openssh-server openssh-client git-core php52.5. 备份脚本若在win下创建文件并编辑，需要在vim中做如下检查和修改： :set ff回车，显示fileformat=dos，重新设置下文件格式： :set ff=unix保存退出: :wq2.5.1. 程序备份##!/bin/bash ----- create restore sh file###### - save folder sf=\"/home/ftp/data/backup\" rn=${sf}\"/restore.sh\" echo \"######restore sh######\" &gt; $rn echo \"sudo apt-get update\" &gt; $rn echo \"sudo apt-get install apache2 mysql-server mongodb vsftpd build-essential autoconf libtool libssl-dev openssh-server openssh-client git-core php5\" &gt;&gt; $rn ----- backup configuration files ###### conf_files=( - backup apache2 \"/etc/apache2/sites-available/000-default.conf\" - backup mysql \"/etc/mysql/my.cnf\" - backup mongodb \"/etc/mongodb.conf\" - backup Vsftpd \"/etc/vsftpd.conf\" - backup shadowsock \"/etc/shadowsocks.json\" ) for lf in ${conf_files[@]} do cp $lf $sf ##split the str arr=(${lf//// }) length=${##arr[@]} filename=${arr[length-1]} ##backup original files echo \"cp \"${lf}\" \"${filename}\".bak\" &gt;&gt; $rn echo \"cp \"${filename}\" \"${lf} &gt;&gt; $rn done echo \"echo finish!\" &gt;&gt; $rn echo \"finish!\"2.5.2. 数据库备份##!/bin/bash ----- backup mysql###### filename=wikibackup`data +%Y-%m-%d_%H%M%S`.sql.gz mysqldump -hlocalhost -uXXX -pXXX --default-character-set=utf8 s9759044_wiki | gzip &gt;$filename mutt goumang2010@qq.com -a $filename -s “ParkBackup”","excerpt":"linux-config"},{"title":"algorithm","date":"2017-09-04T09:37:59.332Z","path":"FE/algorithm.html","text":"1.&nbsp查找1.1.&nbspkmp1.1.1.&nbspexamples1.1.1.1.&nbspjs2.&nbsp排序2.1.&nbsp快排2.1.1.&nbspexamples2.1.1.1.&nbspC++2.1.1.2.&nbspjs1. 查找1.1. kmp设： 输入字符串为haystack， 要查找的子串needle 得到needle的回溯特征nextStack： needle第一个字符的回溯位置为-1， 表示needle第2个字符不匹配时，haystack的上个位置需要与needle的-1位置对齐，即下一步要匹配haystack当前位置与needle头部。 得到needle第n个字符的回溯位置：设n-1个字符的回溯位置为k，则查看needle[k + 1]与needle[n]的值是否相等，相等则说明第n个字符的回溯位置直接就是k+1 若不想等，则继续回溯位置k的上个回溯位置j，再次匹配下个字符，以此类推。 匹配haystack： 两个游标代表haystack和needle匹配位置，均从0开始。 游标所在位置字符相等，则同时前进； 不匹配时， 若needle位置为0，则仅haystack向前。 其他情况不匹配时，设当前haystack游标位置为hi, needle游标位置为ni, 查找最后匹配位置ni - 1的回溯位置， 并将ni设为该位置的下一个位置（ni = nextStack[ni - 1] + 1），hi不变，下一步即重新开始匹配needle[ni]和haystack[hi] needle匹配了最后一个位置后停止，计算并返回hi - needle.lenth 1.1.1. examples1.1.1.1. jsvar strStr = function(haystack, needle) { // use kmp var needleLenth = needle.length; if(needleLenth === 0) { return 0; } var nextStack = { 0: -1 }; var index = 0; var hayLength = haystack.length; for(var i = 1;i &lt; needleLenth; i++) { index = nextStack[i - 1]; // 回溯到后缀匹配的最近位置，此时，后缀的下个字符与当前位置i的字符匹配或是回溯位置为-1（需要从头开始） while(index &gt;=0 &amp;&amp; needle[index + 1] !== needle[i]) { index = nextStack[index]; } // 后缀的下个字符与当前位置i的字符匹配， 将当前字符的回溯位置设为元后缀的下个字符位置 if(needle[index + 1] === needle[i]) { nextStack[i] = index + 1; } else { // 无回溯位置 nextStack[i] = -1; } } var hayIndex = 0; var needleIndex = 0; while(hayIndex&lt; hayLength &amp;&amp; needleIndex &lt; needleLenth) { if(haystack[hayIndex] === needle[needleIndex]) { hayIndex ++; needleIndex++; } else if (needleIndex === 0) { hayIndex++; } else { // 若不使用nextStack， 需要从hayIndex = hayIndex - needleIndex + 1 与needleIndex = 0重新匹配 // 使用nextStack， 则只要从hayIndex = hayIndex与needleIndex = nextStack[needleIndex - 1] + 1匹配 // 即是自动匹配了hayIndex之前的后缀与needle的前缀 needleIndex = nextStack[needleIndex - 1] + 1; } } if(needleIndex === needleLenth) { return hayIndex - needleLenth; } else { return -1; } };2. 排序2.1. 快排输入： 数组a， 排序范围start - end 定义比较大小并调换位置的函数compare 数组a仅有一个元素，返回其本身。 数组a有2个元素， 两个元素比较排序后返回。 数组a有3个元素， 两两比较排序后返回。 数组a多于3个元素，在中间位置的元素和两边元素，排序，并选取中间元素为pivot 将pivot和倒数第二个元素（a[end -1]）调换位置。 设置两个j, k游标分别从start + 1，end -2位置开始向中间移动，直到j &gt;= k, 当j移动到大于等于pivot元素，同时k移动到小于等于pivot的元素时，互换元素位置。 循环结束后，将j所在的元素（大于等于pivot）和end-1位置的pivot互换位置，此时j左侧元素都比pivot小，右侧都比pivot大。 递归排序[start, j-1] [j+1, end] 范围的元素。 2.1.1. examples2.1.1.1. C++#include \"stdafx.h\" #include &lt;vector&gt; using namespace std; namespace AlgorithmPractice { //快速排序 //定义一项操作，使得以pivot为界，将数组分为两组，后一组元素比前一组的每个元素都要大 //继续对每组进行重复这样的操作，直到分无可分（每组只剩下一个元素），即完成了整个排序 //将pivot选为两边元素和中间元素的中值 //使用递归 void QuickSort(vector&lt;int&gt; &amp; a, int start, int end) { int diff = end - start; //当有0个或1个元素时，直接返回 if (diff &lt;= 0) { return; } else { // if (diff == 1 || diff == 2) { getPivot(a, start, end); return; } } //确定锚点 //此时锚点已经放置到end-1的位置 int pivot = getPivot(a, start, end); //使用两个游标j,k在[start+1,end-2]范围内分别游走，当j&gt;=k时表示游历完成 //游标分别寻找大于和小于pivot的位置，然后交换 //当结束时，jk会分别位于第一个大于/小于pivot的元素上 int j = start + 1; int k = end - 2; while (1) { //找到第一个不符合要求的元素 //不需要担心越界，因为左右各自有比pivot小/大的数 while (a[j] &lt; pivot) { j++; } //无需考虑等号，留在原地，其会最终靠在一起 while (a[k] &gt; pivot) { k--; } if (j &gt;= k) {z break; } else { swapEle(a, j, k); } } //此时j的位置为第一个大于pivot的元素，把它和右边end-1位置上的pivot交换 swapEle(a, j, end - 1); //这样pivot恰好位于中间位置，把数组分为[start,j-1][j+1,end]两部分 //使用递归，分别进行同样的操作 QuickSort(a, start, j - 1); QuickSort(a, j + 1, end); } //交换数组中两个元素的位置 void swapEle(vector&lt;int&gt; &amp; a, int ia, int ib) { int tmp = a[ia]; a[ia] = a[ib]; a[ib] = tmp; } //确定pivot int getPivot(vector&lt;int&gt; &amp; a, int ia, int ib) { int midi = (ia + ib) / 2; //比较左边和中间，确保左边相对小 if (a[ia] &gt; a[midi]) { swapEle(a, ia, midi); } //比较左边和右边，确保左边相对小 if (a[ia] &gt; a[ib]) { swapEle(a, ia, ib); } //比较中间和右边，确保中间相对小 if (a[midi] &gt; a[ib]) { swapEle(a, midi, ib); } //此时midi处的值选为pivot，但面临的问题是： //1. pivot最终索引位置不确定 //2.可以确定的是ia，ib的元素位置都不需要再变动 //故先把pivot放于ib-1的位置，待分组完全后，再把其放到最终的中间位置 swapEle(a, midi, ib - 1); return a[ib - 1]; } }2.1.1.2. jsfunction quicksort(mangleArr, left = 0, right = mangleArr.length - 1) { if ((right - left) &lt;= 1) { switchPos(left, right, mangleArr); return mangleArr; } let _right = right; let _left = left; let _array = mangleArr; // establish two flag let mid = Math.ceil((left + right) / 2); switchPos(_left, mid, _array); switchPos(_left, _right, _array); switchPos(mid, _right, _array); let pivot = _array[mid]; switchPos(mid, _right - 1, _array, true); _right -= 2; _left++; while (true) { while (_array[_left] &lt; pivot) { _left++; } while (_array[_right] &gt; pivot) { _right--; } if (_left &gt;= _right) { break; } else { switchPos(_left, _right, _array); } } switchPos(_left, right - 1, _array, true); quicksort(_array, left, _left - 1); quicksort(_array, _left + 1, right); return _array; } function switchPos(a, b, _array, force = false) { if (_array[a] &gt; _array[b] || force) { let temp = _array[a]; _array[a] = _array[b]; _array[b] = temp; return true; } else { return false; } }","excerpt":"algorithm"},{"title":"writing","date":"2017-09-04T09:37:59.332Z","path":"uncategorized/writing.html","text":"1.&nbspQuotes1. Quotes Proud people breed sad sorrows for themselves. But if you be afraid of your touchiness, you must ask pardon, mind, when she comes in. —-By Emily Brontë","excerpt":"writing and something else"},{"title":"coach","date":"2017-09-04T09:37:59.332Z","path":"FE/coach.html","text":"1.&nbsp可用性 参考1.1.&nbspimg标签一定要添加alt属性1.1.1.&nbsp检查页面img标签的alt属性：1.2.&nbsp使用h标签来结构化你的页面1.3.&nbsp表单中的Input应有设置label1.3.1.&nbsp检查页面中input标签1.4.&nbsp使用地标来结构化你的内容1.4.1.&nbsp统计页面中的article, aside, footer, header, nav及main标签数量1.5.&nbsp不要禁止触摸缩放 参考1.5.1.&nbsp检查页面中同时具有name和content属性的meta元素1.6.&nbsp在section标签中使用h标签来增强页面结构化1.6.1.&nbsp检查页面中的section标签：1.7.&nbsp在table中使用caption和th标签1.7.1.&nbsp检查页面中的每个table标签2.&nbsp最佳实践2.1.&nbsp声明字符集(charset)2.1.1.&nbsp通过document.characterSet取得字符集2.2.&nbsp声明doctype2.2.1.&nbsp通过document.doctype取得doctype2.3.&nbsp使用更安全的https 参考2.3.1.&nbsp通过document.URL取得url2.4.&nbsp使用 HTTP/22.4.1.&nbsp通过document.URL取得url，通过以下方法取得ConnectionType2.5.&nbsp声明语言 参考2.5.1.&nbsp检查html标签下的lang属性2.6.&nbspMeta 描述 参考2.6.1.&nbsp检查页面中同时具有name和content属性的meta元素2.7.&nbsp页面标题2.7.1.&nbsp通过document.title取得标题2.8.&nbsp良好的url格式2.8.1.&nbsp通过document.URL取得url3.&nbsp性能3.1.&nbsp不要在浏览器中缩放图片3.1.1.&nbsp遍历页面中所有img标签3.2.&nbsp不要加载单独的打印样式表3.2.1.&nbsp遍历页面中所有link标签,统计media属性为print的数量3.3.&nbsp避免拖慢关键渲染路径3.3.1.&nbsp取得head中所有css文件路径3.3.2.&nbsp取得head中所有同步js文件路径3.4.&nbsp在HTTP/1上使用内联样式以加快首次渲染3.4.1.&nbsp取得head中所有css文件数量及style标签数量3.5.&nbsp避免使用多个JQuery版本3.5.1.&nbsp通过以下方法获取存储所有JQuery原型的数组3.6.&nbsp避免前端单点失败(SPOF)3.6.1.&nbsp统计页面头部所有 同步CSS和JS请求3.7.&nbsp异步加载第三方JS插件3.7.1.&nbsp统计页面头部所有同步CSS和JS请求3.8.&nbsp使用用户 Timing API 来检查性能3.8.1.&nbsp检查window.performance4.&nbspHAR性能检查4.1.&nbsp避免资源重定向4.1.1.&nbsp检查资源请求的status4.2.&nbsp通过设置缓存头来避免额外的请求4.2.1.&nbsp检查资源请求的expires4.3.&nbsp设置长的缓存时间4.3.1.&nbsp检查资源请求的expires4.4.&nbsp压缩文本内容4.4.1.&nbsp检查资源请求的编码4.5.&nbsp不要关闭一个会使用多次的连接4.5.1.&nbsp检查资源请求的连接4.6.&nbspCSS大小不该过大4.6.1.&nbsp检查css资源的大小4.7.&nbsp避免主文档重定向4.7.1.&nbsp检查documentRedirects4.8.&nbsp图标应该小且能够缓存4.8.1.&nbsp检查type为favicon的资源4.9.&nbsp避免多字体4.9.1.&nbsp检查type为font的资源4.10.&nbsp避免同域名过多请求[HTTP/1]4.10.1.&nbsp检查连接类型和domains对象4.11.&nbsp请求头不应过大[HTTP/1]4.11.1.&nbsp检查连接类型和每个资源的headerSize4.12.&nbsp总图片大小过大4.12.1.&nbsp检查type为image或svg的资源4.13.&nbsp总JS大小不应过大4.13.1.&nbsp检查type为javascript的资源4.14.&nbsp使每个CSS请求尽量小4.14.1.&nbsp检查type为css的资源4.15.&nbsp总页面大小不应该过大4.15.1.&nbsp检查页面的transferSize4.16.&nbsp不要在静态内容上使用私有头4.16.1.&nbsp遍历每个资源4.17.&nbsp避免丢失和失败的请求4.17.1.&nbsp遍历每个资源1. 可用性 参考1.1. img标签一定要添加alt属性所有的img标签都需要alt属性，这条规则没有例外. 如果没有，则请马上加上它。 1.1.1. 检查页面img标签的alt属性： 如果没有或者为空字符串，则提示：该页面有？个img标签缺少alt属性，其中？个img标签是唯一（非重复）的。 若alt属性过长（长度大于125），则提示：该页面有？ 个img标签alt属性文本过长 (长于125个字符). 1.2. 使用h标签来结构化你的页面标题使页面结构清晰，更加有逻辑. 维基百科使用标题来汇集文章，从H1到H6能清晰的向阅读者，搜索引擎等展示该页面的结构。检查页面中h1-h6标签的数量： 页面没有h标签，则提示：页面没有标题。请使用标题使你的内容更加结构化。 没有更下级的h标签，则提示：这个页面没有h?标签，标签的优先级过低。 1.3. 表单中的Input应有设置label大多数input、select和textarea元素需要一个关联的label元素来声明他们的目的. 唯一例外的是产生按钮的那些, 如重置和提交按钮. 其他的, 如 text, checkbox, password, radio (button), search 等都需要一个label元素。 1.3.1. 检查页面中input标签如果input标签的类型为text，password，radio，checkbox，search中的一种，则通过以下两种方式检查它是否有对应的label标签，并提示：表单中有？个input标签没有对应的label标签： 父元素的节点名称为LABEL，说明具有对应的label标签 input元素具有id属性，并且有label标签的for属性为该id，说明具有对应的label标签 1.4. 使用地标来结构化你的内容地标是 article, aside, footer, header, nav 或main标签. 适当的添加这些地标能够使页面更易于理解，帮助用户更家容易的操作内容。 1.4.1. 统计页面中的article, aside, footer, header, nav及main标签数量如果一个都没有，则提示：页面没有用到任何地标。 1.5. 不要禁止触摸缩放 参考移动浏览的一个关键特性就是可以放大阅读内容，缩小定位内容。 1.5.1. 检查页面中同时具有name和content属性的meta元素若其content中含有user-scalable=no或initial-scale=1.0; maximum-scale=1.0则提示：注意！页面已禁用缩放，你不应该这样做。 1.6. 在section标签中使用h标签来增强页面结构化大多数input、select和textarea元素需要一个关联的label元素来声明他们的目的. 唯一例外的是产生按钮的那些, 如重置和提交按钮. 其他的, 如 text, checkbox, password, radio (button), search 等都需要一个label元素。Section标签应该至少有一个直接子级h元素。 1.6.1. 检查页面中的section标签： 如果页面中没有section标签，则提示：页面中没有使用sections. 你应该使用它使你的内容更结构化. section标签没有h元素下级，则提示：该页面section标签下没有h标签，发生了？次. 1.7. 在table中使用caption和th标签使用caption元素给table添加一个合适的标头或摘要. 使用th 元素来表示列或行的标头. 利用它的作用范围和其他属性来理清关联。 1.7.1. 检查页面中的每个table标签检查其下是否有caption标签，以及tr标签下是否有th标签，若没有，则提示：该页面的表格没有caption元素, 请添加一个合适的标头或摘要。 2. 最佳实践2.1. 声明字符集(charset)Unicode标准 (UTF-8) 覆盖世界上大多数字符, 标点和符号，请使用它。 2.1.1. 通过document.characterSet取得字符集 如果取到的是null，则提示：该页面没有字符集。 如果你使用 Chrome/Firefox则一定是没有定义它, 如果你使用其他浏览器，则有可能是浏览器实现问题。 如果取到的不是UTF-8，则提示：你没有使用 UTF-8字符集? 2.2. 声明doctype\\&lt;!DOCTYPE&gt; 声明不是HTML标签; 它是一条给浏览器指令，指示页面采用的是哪个版本的HTML。 2.2.1. 通过document.doctype取得doctype 如果取到的是null，则提示：页面没有doctype. 请使用\\&lt;!DOCTYPE html>. 如果doctyped的name属性html(大写或小写)，并且systemId属性为空或为about:legacy-compat，则提示：珍爱生命使用HTML5 doctype 声明: \\&lt;!DOCTYPE html> 2.3. 使用更安全的https 参考页面应该总是使用HTTPS， HTTP/2也需要使用它! 你可以从https://letsencrypt.org/得到免费的 SSL/TLC 证书。 2.3.1. 通过document.URL取得url如果页面不是以https://开头，则提示：注意！该页面没有使用HTTPS. 每一个未加密的HTTP请求都将暴露用户的操作信息。 2.4. 使用 HTTP/2结合使用 HTTP/2 及 HTTPS 是一项新的最佳实践. 使用HTTPS的同时应该也使用HTTP/2 2.4.1. 通过document.URL取得url，通过以下方法取得ConnectionType 如果url包含https://但connectionType不包含h2，则提示：该页面使用HTTPS的同时没有使用HTTP/转到HTTP/2以满足最佳实践并且使站点更快。 function getHostname(url) { var a = window.document.createElement('a'); a.href = url; return a.hostname; } function getConnectionType() { // it's easy in Chrome if (window.chrome && window.chrome.loadTimes) { return window.chrome.loadTimes().connectionInfo; } // if you support resource timing v2 // it's easy kind of easy too else if (window.performance && window.performance.getEntriesByType && window.performance.getEntriesByType('resource')) { var resources = window.performance.getEntriesByType('resource'); // now we \"only\" need to know if it is v2 if (resources.length > 1 && resources[0].nextHopProtocol) { // if it's the same domain, say it's ok var host = document.domain; for (var i = 0, len = resources.length; i < len; i += 1) { if (host === getHostname(resources[i].name)) { return resources[i].nextHopProtocol; } } } } return 'unknown'; } 2.5. 声明语言 参考根据W3C的推荐标准你应该使用lang标签为每个网页声明主要语言 2.5.1. 检查html标签下的lang属性 如果取到的是null，则提示：HTML标签缺少lang定义，定义它 &lt;html lang=&quot;zh&quot;&gt; 如果根本没有html标签，则提示：注意！你的页面没有HTML标签! 2.6. Meta 描述 参考使用页面描述使其对搜索引擎友好 2.6.1. 检查页面中同时具有name和content属性的meta元素筛选name为description（不区分大小写）的meta，取其content属性: 如果没有content或内容为空，则提示：页面没有 meta 描述（元描述） 如果content长度大于155个字符，则提示：meta 描述过长. 有？个字符, 推荐最大长度为155; 2.7. 页面标题使用标题来使页面对搜索引擎友好 2.7.1. 通过document.title取得标题如果长度为0，提示页面没有标题,如果超过60个字符，提示:标题过长，超出?个字符. 推荐最大字符数为60; 2.8. 良好的url格式一个干净的url对用户和SEO会更友好. 让url可读, 避免url过长, url中有空格, 过多的请求参数,并且不要在url中加入session id 2.8.1. 通过document.URL取得url url包含?并且jsessionid在?的后面，则提示：该页面将用户的session id作为参数了,请修改它，使其通过cookies来处理session url包含不止一个&amp;，则提示： 该页面有两个以上的请求参数.你应该重新考虑，减少请求参数。 url的长度大于100，则提示： 该URL有？个字符长. 请使它小于100个字符。 url中含有空格或%20，则提示： 避免URL中含有空格，使用连字符或下划线代替。 3. 性能3.1. 不要在浏览器中缩放图片缩放图片非常容易，并且可以在不同的设备中显示的很好，然而这种做法不利于性能! 浏览器中缩放图片会占用额外的CPU时间，也将严重的降低移动端的性能。并且用户需要下载额外的数KB甚至数MB的数据。所以不要这样做，确保在服务端创建同一图片的多个版本，以满足不同客户端的需求。 3.1.1. 遍历页面中所有img标签统计所有clientWidth属性比naturalWidth属性小的值超过100的数量.如果数量不为0，则提示： 页面有?个缩放的图片缩小超过100像素. 最好不要缩放它们 3.2. 不要加载单独的打印样式表打印样式表并不常用，加载单独的打印样式表会拖慢页面性能。你可以使用@media print把打印样式包含在其他CSS文件中。 3.2.1. 遍历页面中所有link标签,统计media属性为print的数量如果数量不为0，则提示： 页面有？个打印样式表. 你应该使用@media print把打印样式包含在其他 CSS文件中 3.3. 避免拖慢关键渲染路径关键渲染路径是指浏览器渲染页面的主要路径。每个在head元素中请求的文件将会延迟页面的渲染，因为浏览器要先处理这些文件请求。避免在head中使用js (你不应该需要用js来渲染页面)，请求的文件应该与主文档同域名 (避免DNS查询)，使用内联 CSS 或服务器推送达到快速渲染和缩短渲染路径的目的。 3.3.1. 取得head中所有css文件路径遍历head中的所有link标签，筛选rel属性为stylesheet并且href不以data:开头的元素，提取其绝对路径 如果使用的是HTTP/2，而数量不为0，则提示： 确保使用服务器推送CSS来达到快速渲染 检查文件大小，如果大于14.5 kB，则提示：样式文件(url)大于TCP窗口大小 14.5 kB. 确保文件小于它以保证快速渲染. 如非使用HTTP/2，则检查文件路径是否与页面同域名，如果不是则扣分3.3.2. 取得head中所有同步js文件路径遍历head中的所有script标签，筛选不存在async属性且存在src属性的元素，提取其绝对路径 如果使用的是HTTP/2，且数量不为0，则提示： 避免在文档头部加载同步j文件,你不应该需要js文件来渲染页面 css+js数量不为0，则提示：页面头部有？ 个阻塞CSS请求和？个阻塞JS请求 3.4. 在HTTP/1上使用内联样式以加快首次渲染在互联网早期内联样式是一个丑陋的做法。但这样做能加快用户首次渲染速度.在使用HTTP/1时应该内联关键CSS，避免CSS请求阻塞渲染，之后懒加载并缓存剩余的CSS. 使用HTTP/2情况会复杂些。如果你的服务器可以做http推送，大量用户连接缓慢且需下载大块HTML. 那么使用内联是更好的选择，因为服务器上HTML内容优先级高于CSS，所以用户需要先下载HTML，再下载CSS。 3.4.1. 取得head中所有css文件数量及style标签数量 如使用HTTP/2，css文件数量和style标签数量都大于0，则提示：该页面使用HTTP/2，同时存在css文件和style标签。 如果你的服务器支持推送，确保通过服务器推送来取得CSS文件.大量用户连接较慢, 使用内联是更好的选择. 请自行测试并查看瀑布图 如使用HTTP/2，css文件数量为0，style标签数量大于0，则提示：该页面有内联样式并使用HTTP/2.如果大量用户连接较慢, 使用内联是更好的选择，否则如果你的服务器支持推送，请使用服务器推送单独的CSS文件. 如使用HTTP/2，css文件数量大于0，则提示：如果你的服务器支持推送，则确保把CSS请求放在文档头部，否则请使用内联样式 如使用HTTP/1，style标签数量为0，css文件数量大于0，则提示：该页面头部有?个CSS请求, 请内联关键样式并懒加载其余的CSS 如使用HTTP/1，css文件数量和style标签数量都大于0，则提示：该页面头部同时具有内联样式和?个CSS请求. 请仅使用内联样式以加快首次渲染速度 3.5. 避免使用多个JQuery版本在同一页面使用多个版本的JQuery会导致额外下载大量的数据，清理代码并仅是有一个版本。 3.5.1. 通过以下方法获取存储所有JQuery原型的数组数组长度大于1，则提示：该页面有？个版本的jQuery!你只需要一个版本，请移除没必要的版本. var versions = []; // check that we got a jQuery if (typeof window.jQuery == 'function') { versions.push(window.jQuery.fn.jquery); var old = window.jQuery; while (old.fn && old.fn.jquery) { old = window.jQuery.noConflict(true); if ((!window.jQuery) || (!window.jQuery.fn)) break; if (old.fn.jquery === window.jQuery.fn.jquery) { break; } versions.push(window.jQuery.fn.jquery); } } 3.6. 避免前端单点失败(SPOF)如果某个JS文件、CSS、字体没有取回或是加载缓慢（白屏），加载的页面就会在浏览器中卡住.所以不要在head标签中同步加载第三方的组件. 3.6.1. 统计页面头部所有 同步CSS和JS请求筛选其中链接域名和文档域名不同的元素如果数量不为0，则提示： 该页面头部有？个请求可能引起 SPOF. 异步加载它们或是把其移出文档头部 3.7. 异步加载第三方JS插件使用异步加载的JS切片能够加快速度，提高用户体验，避免阻塞渲染. 3.7.1. 统计页面头部所有同步CSS和JS请求通过匹配链接域名，筛选出第三方插件如果数量不为0，则提示： 该页面有？个同步第三方JS请求，把它们替换为异步请求. 3.8. 使用用户 Timing API 来检查性能用户Timing API是一个完美的方法来测量网站指定的或常规的指标. 3.8.1. 检查window.performancewindow.performance.getEntriesByType(‘mark’).length或window.performance.getEntriesByType(‘measure’).length任一一个大于0，表示浏览器支持。提示： 开始使用Timing API来测量网站指定的或常规的指标。 否则提示：NOTE: 浏览器不支持User timing 4. HAR性能检查利用从har文件中得到的数据进行检查 4.1. 避免资源重定向重定向对于用户下载资源来说是一个额外的步骤. 避免重定向使得页面加载更快并且防止移动端卡住 4.1.1. 检查资源请求的status如果存在301, 302, 303, 305, 306, 307中的一种或几种，并统计与页面域名不同的项如果存在，则提示：页面有 ?个重定向. 其中?个是来自主域名的，请修复它们 4.2. 通过设置缓存头来避免额外的请求提高页面速度的最好办法就是不要请求服务器. 在服务器响应上面设置一个缓存头可以让浏览器在设定的缓存时间内不再重复下载资源。 4.2.1. 检查资源请求的expires统计小于等于0的项目如果存在，则提示：该页面有？个请求没有设置缓存时间. 设置一个缓存时间，这样浏览器就不需要每次都下载. 这在下次进入该页面时将节省？kB 4.3. 设置长的缓存时间设置长的缓存时间 (至少30天) ，这样资源能长期存在浏览器中. 如果静态资源改变了，那么就给它重命名，这样浏览器就会重新下载. 4.3.1. 检查资源请求的expires统计小于2592000的项目如果存在，则提示：该页面有？个请求的已设置的缓存时间小于 30 天 4.4. 压缩文本内容互联网早期，浏览器不支持压缩文本内容 (gzipping) . 现在则需要压缩 HTML, JSON, Javacript, CSS and SVG这样可以减少流量、使页面更快、节省网络带宽 4.4.1. 检查资源请求的编码筛选type为’html’, ‘plain’, ‘json’, ‘javascript’, ‘css’, ‘svg’的资源，通过asset.headers.response[&#39;content-encoding&#39;]取得编码（asset是静态资源对象），统计编码不是gzip的项目如果存在，则提示：该页面有 ？个请求服务器没有压缩.压缩它们可以节省很多资源 4.5. 不要关闭一个会使用多次的连接使用keep alive标头这样就可以复用同一域名下的连接. 从前的立即关闭连接需要时再打开的说法已经不适用了 4.5.1. 检查资源请求的连接检查asset.headers.response.connection（asset是静态资源对象）是否包含close，如果有两个及以上相同域名者，则提示：该页面有？个请求未能复用相同域名的连接. 请使用keep alive复用连接 4.6. CSS大小不该过大传递大的CSS给浏览器会增加解析时间，拖慢渲染速度. 请仅发送页面所需的CSS，并移除不再使用的CSS规则 4.6.1. 检查css资源的大小筛选type为css的资源，累加它们的contentSize 大于1000000，则提示：CSS文件总大小已超过1MB，不适合再移动端显示 大于2000000，则提示：CSS文件总大小已超过2MB，请修改. transferSize超过120k或contentSize超过400k，并且contentSize大于transferSize，则提示：总CSS传输尺寸为?kB,非压缩尺寸为contentSize kB 4.7. 避免主文档重定向除非是http重定向至https，否则不要使用页面重定向 4.7.1. 检查documentRedirects同时检查url和finalUrl，若documentRedirects大于0 若url包括http:且finalUrl包含https则提示：`````` 否则提示： 主文档重定向documentRedirects 次，去除这些重定向使得页面速度更快 4.8. 图标应该小且能够缓存把图标做小，并加上长时间（大于30天）的缓存头. 4.8.1. 检查type为favicon的资源检查status，size，expires，size大于2000则提示： 图标大小大于?bytes. 这已经很大了，请尝试把它做小 4.9. 避免多字体过多的字体会拖慢渲染速度, 若字体未加载完成文字可能会闪光甚至不显示 4.9.1. 检查type为font的资源若数量大于1，则提示： 页面有 ？个字体请求.请确认是否真的需要它们 4.10. 避免同域名过多请求[HTTP/1]使用 HTTP/1时，浏览器对每个域名下的并发请求存在限制. 当达到限制后请求需要排队发出。 4.10.1. 检查连接类型和domains对象 连接类型为HTTP2，则提示：HTTP/2连接对于请求数几乎没有限制, 但这也不完全正确，取决于下载的是是么. 请检查HAR文件查看详情 检查domains中每个域名的请求数，统计超过30个请求的域名数，并提示：&#39;该页面有?个域名发起的超过 30 个请求.通过分片或迁移至HTTP/2提高性能. 4.11. 请求头不应过大[HTTP/1]使用HTTP/1时避免大量cookie和其他东西使得请求头过大，因为请求头是不压缩的. 你会发送多余的东西给用户 4.11.1. 检查连接类型和每个资源的headerSize 连接类型为HTTP2，则提示：该页面使用HTTP/2 连接，请求头已压缩, 很好 headerSize大于20000，则提示：该页面有个请求头部大于20kb. 你应该试图减少发送的cookie 4.12. 总图片大小过大避免页面中有过多的大图片. 这些图片不会影响页面的绘制，但会占用用户大量带宽. 4.12.1. 检查type为image或svg的资源累加它们的contentSize，大于700000，则提示：该页面的总图像大小超过700kB. 这是已经很大了，确保你选择了正确的图片格式并已被压缩，可以使用ImageOptim让它们变得更小. 4.13. 总JS大小不应过大大量JS意味着可能下载了很多用户并不需要的，确定页面的复杂性，和是否使用了多套JS框架? 4.13.1. 检查type为javascript的资源累加它们的contentSize和transferSize transferSize超过contentSize，则提示：总共JS传输大小为transferSize，未压缩的大小为contentSize contentSize超过500000或transferSize超过120000，则提示：总共JS已很大了，你需要精简JS contentSize超过1000000，则提示：crazy，你需要精简JS 4.14. 使每个CSS请求尽量小减小css请求尺寸，使其满足 TCP 窗口大小 14.5 kB. 这样可以下载CSS更快，从而更早的渲染页面. 4.14.1. 检查type为css的资源累加它们的transferSize，大于14500，则提示：请尝试精简CSS至14.5 kb内. 4.15. 总页面大小不应该过大避免页面传输大于2 MB (桌面端) / 1 MB (移动端)，因为这将降低页面性能并占用用户网络带宽. 4.15.1. 检查页面的transferSize 移动端大于1000000，桌面端大于2000000，则提示：页面传输大小为transferSize，你需要精简它. 4.16. 不要在静态内容上使用私有头如果在内容上设置私有头，表示该内容只针对该用户. 但静态内容可以被每个用户缓存和使用, 所以要避免设置头部私有. 4.16.1. 遍历每个资源检查asset.headers.response[‘cache-control’]，若包含private，且资源url和页面url相同 ，则提示：主页面有私有头.某些情况这是正确的，如用户登录才可访问特定内容，但若是静态共用的，请不要设置private. 4.17. 避免丢失和失败的请求页面请求资源不应返回400或500错误.这些失败的请求不应被缓存, 否则浏览器每次都会这样做. 如果这种情况发生了，表示有东西损坏了，应及时修复 4.17.1. 遍历每个资源检查资源的status，如果大于等于400,则计入统计，之后进行分组，提示：这个页面有 ?个失败的请求，请求代码为status","excerpt":"coach"},{"title":"BP","date":"2017-09-04T09:37:59.332Z","path":"FE/bp.html","text":"1.&nbsp操作流程1.1.&nbsp增加埋点1.2.&nbsp查询,修改及删除1.3.&nbsp热点分布图2.&nbsp埋点管理平台2.1.&nbspiframe加载埋点页面2.1.1.&nbsp前端2.1.2.&nbsp选择器2.1.2.1.&nbsp_cssPathStep2.1.2.2.&nbspprefixedElementClassNames2.1.2.3.&nbspDOMNodePathStep类2.1.3.&nbsp/databp/html接口2.1.4.&nbsp/databp/ajax接口2.2.&nbsp右键菜单2.3.&nbsp管理页面2.4.&nbsp热力图2.4.1.&nbspheatmap.js2.4.1.1.&nbspgetCanvas2.4.1.2.&nbsp_getBrush2.4.1.3.&nbsp_getGradient3.&nbspjs sdk3.1.&nbspBP入口3.1.1.&nbsppvLog3.1.2.&nbspgetPvData3.1.3.&nbspsend3.1.4.&nbspgetExt3.2.&nbsp工具方法3.2.1.&nbsp获取平台信息getWm3.2.2.&nbspsendRequest3.2.3.&nbspjsonToQuery3.3.&nbsp返回数据3.3.1.&nbsp客户端信息CI3.3.2.&nbsp页面信息PI3.3.3.&nbsp用户信息UI3.3.4.&nbsp特别信息SI3.3.5.&nbsp性能信息P4.&nbsp后续完善1. 操作流程目前尚处于测试阶段。 1.1. 增加埋点 管理平台地址（测试）： http://bi.test.gomeplus.com/ 使用域的账户和密码登录，并通知管理员开头相关权限。 进入数据埋点 -&gt; 可视化埋点，在埋点URL中输入需要埋点的网址，当前可用网址为预生产环境：https://www-pre.gomeplus.com/ 选择平台后，点击检索页面。 待页面加载完成后，可通过鼠标查看当前选中的元素，点击邮件，可进入该元素的埋点菜单。 在右键菜单中，对埋点信息进行增加或修改，点击保存/更新埋点后，完成埋点操作。 左键点击页面其他元素，若该元素含有链接，则可跳转到该页面，进行正常埋点。 若选择的平台与URL不符，埋点URL会自动变更为重定向后的网址。 1.2. 查询,修改及删除 进入 数据埋点 -&gt; 埋点管理，可以查看所有埋点 通过上方输入框，可以通过埋点URL、埋点名称、状态、匹配模式、平台、修改时间进行筛选。 列表中的操作列可以进行相应的操作。点击修改可以进入可视化埋点界面编辑相关的埋点信息。 点击删除、恢复将进行相应的操作。 1.3. 热点分布图 当用户点击埋点页面设置过的埋点元素时， sdk会将该行为及埋点信息进行上报。 这些信息可以在热力分布图中体现。 目前仅有pv页面点击量，uv用户访问数，可以在数据选择框中切换 取消勾选显示热力图，可以像可视化埋点一样，点击相应的链接进行页面跳转，并刷新热力图。 2. 埋点管理平台2.1. iframe加载埋点页面2.1.1. 前端 用户输入埋点URL和平台 前端验证URL是否合法，合法则将iframe的src属性置为/databp/html?m=${platform}&amp;url=${pageUrl},platform为用户选择的平台，pageUrl为用户输入的埋点URL。 iframe会向接口/databp/html发起get请求，传入以上参数。 iframe收到文档信息，进行正常渲染加载。 iframe加载完成后，jquery注入悬浮时的样式并绑定hover事件。 绑定右击事件，右击时取得选择器信息，传给弹出右键菜单。 绑定左击事件，当点击的元素或其父级有链接时，重新设置URL进行重新检索。 触发的xhr请求，会导向/databp/ajax进行动态加载。 2.1.2. 选择器使用chrome获取选择器的js操作，并进行修改。传入DOM节点node 检查node.nodeType，若非Node.ELEMENT_NODE，直接返回空字符串。 调用内部方法_cssPathStep不断检查得到node及其父级的标识，直到到达DOM最顶级（html标签） 若有任何一级检查标识出错，则终止该过程。 将取得的标识从父到子，使用&gt;连接。 2.1.2.1. _cssPathStep传入要检查的DOM节点node，是否启用优化optimized 检查node.nodeType，若非Node.ELEMENT_NODE，直接返回null。 通过getAttribute检查node的id，若存在，调用DOMNodePathStep方法，并传入nodeName#id 若id不存在，检查node.parentNode，若parent不存在或为document，表示该节点为根节点，标识唯一，直接传入nodeName，生成DOMNodePathStep对象。 id不存在，且不满足以上条件，调用prefixedElementClassNames生成prefixedOwnClassNamesArray var needsClassNames = false;var needsNthChild = false;var ownIndex = -1; 遍历node同级的所有DOM节点，确定needsClassNames及needsNthChild的最终值：若是没有同级元素，needsClassName和needsNthChild皆为false，若有同级同tagName的元素，needsClassName置为true，并比较所有同级同tagName元素的class，确定class是否唯一，若否，则标记needsNthChild为true。 如果node就是最终节点且为input元素，没有id没有class，则将标识置为input[type=”…”] needsNthChild为true，则表示node没有可以唯一标识自身的class，则根据同级标签tagName的数量确定其为tagName:first-child +…的形式。 needsNthChild为false，needsClassNames为true，表示，其有可以唯一标识自身的class，则将prefixedOwnClassNamesArray中的元素去除$，并使用.拼接起来。 把最终结果传入DOMNodePathStep构造函数，返回新的DOMNodePathStep对象。 2.1.2.2. prefixedElementClassNames存入DOM节点node 通过getAttribute得到class属性。 若class属性不存在，返回空数组。 /\\s+/g分割，通过filter(Boolean)去除可能存在的空字符串。 筛选出active类（自行添加），因为当埋点时，脚本可能自动添加active类，所以active类不能作为元素的唯一标识。 将所有类名前加上$,返回数组。 2.1.2.3. DOMNodePathStep类通过实例属性value存入传入的值，重写原型上toString方法，返回实例属性value 2.1.3. /databp/html接口 根据平台设置请求头，并确定是否为重定向页面，并发起相应页面的http(s)请求，得到页面内容。 将页面内容中，各标签href及src属性指向根域的地址替换为完整地址，从而使其iframe中可以正常加载。 注入拦截XMLHttpRequest的脚本，将所有ajax请求定向至/databp/ajax接口。 保存真实页面的cookie到后台session中，从而使页面后续的ajax请求能通过埋点页面网站后台的验证。 将重定向后真实的地址和平台注入iframe的window对象中，从而反映在前端。 将页面html文档返回给前端。 2.1.4. /databp/ajax接口接受页面中重定向的ajax请求，从而修复iframe页面中的动态加载 根据session中存储的页面cookie信息，设置相应的请求头。 向真实地址发出请求，并返回结果。 2.2. 右键菜单 加载时根据传入的页面URl和选择器，请求埋点信息接口。 显示已设置的埋点信息。 绑定drag drop事件实现拖拽。 2.3. 管理页面实现埋点列表的分页查询，修改，删除，恢复。其中修改使用Vue router跳转至可视化埋点页面。 2.4. 热力图 用户输入埋点URL和平台，在iframe中加载该页面。 请求接口，返回热力图信息。 调用heatmap.js，根据热力图信息生成热力图canvas。 绑定数据来源选择，切换canvas。 取消勾选显示热力图，即去除canvas遮罩，同可视化埋点，绑定单击事件，实现iframe页面的跳转。 绑定MutationObserver，当DOM有新节点插入时，刷新热力图，从而实现动态加载元素的热力图绘制。 2.4.1. heatmap.jsechart2的heatmap组件，作者：me@zhangwenli.com， 灵感来源于simpleheat构造函数根据默认option补全传入的option，包括： blurSize 模糊尺寸 gradientColors 渐变颜色数组 minAlpha 最小不透明度 valueScale 点位值的比例 opacity 总体不透明度 2.4.1.1. getCanvas传入数据data，长宽height,width 调用_getBrush取得笔刷。 调用_getGradient取得颜色渐变表。 建立canvas画布，根据data中的点位上用第1步得到的笔刷画圆，圆心即点位，半径为BRUSH_SIZE + this.option.blurSize, 总体透明度为data中点位对应的值。这是这些圆是黑色的且从中心到边缘渐变为透明。 通过getImageData取得canvas的data,注意每个点都有rgba四个值，所以四个值一组，遍历这些点，根据透明度在颜色渐变表上取值，即是重定义他们的颜色。 通过putImageData将修改后的数据重新写入canvas。 2.4.1.2. _getBrush var r = BRUSH_SIZE + this.option.blurSize 以2r为长宽建立canvas画布 以(-r,r)为圆心，r为半径画个黑色实心圆，此时该圆完全在画布左侧，画布上看不到该圆。 设置shadowOffsetX为2r，以及shadowBlur，这样圆的模糊阴影就会出现在画布中心。 返回画布。 2.4.1.3. _getGradient 建立canvas花布，宽度为1，高度为256 调用canvas的createLinearGradient，配合addColorStop，将颜色列表中的颜色均分渐变 画一个填满画布的矩形，并以上步定义的渐变进行填充。 通过getImageData得到数据并返回。 3. js sdk 通过domReady在DOM加载完毕后调用pvLog记录并发送pv信息，调用getSelector动态埋点信息。 通过UA判断页面不是WebView，并且host在限定的范围内，在文档上绑定click或是touchstart事件： 遍历e.target及其上级元素，检测其标签上是否有bp-data属性，取出其值转为对象data。 若是a标签，则将href属性加入data中。 检测e.target是否匹配动态埋点的元素，若匹配，若匹配取出其动态埋点信息和埋点id，混入data。 通过send上报data. 监听window的error事件，报告错误和三层堆栈信息。 3.1. BP入口3.1.1. pvLog收集平台信息,拼接getPvData所收集的信息组,连同上报的地址构建get请求的url，调用工具方法sendRequest进行发送。 3.1.2. getPvData收集客户端信息,页面信息PI,用户信息UI,性能信息,特别信息SI返回组合后的字符串，如：CI=screen_size:1366x768|color_depth:24...&amp;PI=pagename:%E5%9B|referrer:|is_homepage:unkown|dom_count:660...&amp;UI=phpsid:61g1pa6cilc9ps7fod1gu5cbn3|ssid:892199852910.1479808626068|is_new:0...&amp;P=sdate:-|load_time:2816...&amp;SI=last_time:1480671035|active_no:-|page_id:A001...&amp;source= 3.1.3. send调用getExt获取扩展信息，调用工具方法jsonToQuery格式化传入的data，连同上报的地址构建get请求的url，调用工具方法sendRequest进行发送。 3.1.4. getExt收集页面信息PI,性能信息P,平台信息,用户信息UI并组合为字符串 3.2. 工具方法3.2.1. 获取平台信息getWm通过创建TouchEvent事件来判断是否为移动端，记录形式为：wm=m或wm=www 3.2.2. sendRequest通过UA判断客户端不是PhantomJS，并且window.location.host在限定的列表中，则var img = new Image();img.src = url; 3.2.3. jsonToQuery将js对象转换为query字符串，注意该方法并未调用encodeURIComponent对字符串进行转义，所以需要时手动进行转义。 3.3. 返回数据3.3.1. 客户端信息CI 屏幕尺寸:screen_size通过window.screen.width/height获取，如screen_size:1366x768 屏幕色深:color_depth通过window.screen.colorDepth获取，如color_depth:24 appCode通过navigator.appCodeName获取，如app_code:Mozilla appName通过navigator.appName获取，如app_name:MSIE或app_name:Netscape CPU信息:cpu通过navigator.cpuClass或oscpu获取，如cpu:x86 平台信息:platform通过navigator.platform获取，如platform:Win32 网络连接类型:networknavigator.connection.type获取，对于IE10以前的IE，通过document.body.addBehavior(&quot;#default#clientCaps&quot;);然后取得document.body.connectionType获取，如：network:- 系统语言:language通过navigator.systemLanguage或language获取，如language:zh-CN 时区:timezone通过new Date().getTimezoneOffset() / 60取得，如：timezone:-8 Flash版本:flash_ver遍历navigator.plugins数组，找到name为Shockwave Flash的项，截取description中的版本信息。对于IE10以下，则是从10开始往下遍历flash版本号，试验是否能成功new ActiveXObject(‘ShockwaveFlash.ShockwaveFlash.rev’)来确定flash版本。如:flash_ver:23.0 r0 浏览器UA:ua通过encodeURIComponent编码navigator.userAgent，如：ua:Mozilla%2F5.0%20(Windows%20NT%2010.0%3B%20Win64%3B%20x64)%20AppleWebKit%2F537.36%20(KHTML%2C%20like%20Gecko)%20Chrome%2F54.0.2840.99%20Safari%2F537.36 3.3.2. 页面信息PI 页面title:pagenameencodeURIComponent(document.title || &#39;-&#39;) 页面引用:referrer通过document.referrer得到跳转或打开到当前页面的那个页面的URI，若为空字符串，或通过/^[^\\?&amp;#]*.swf([\\?#])?/判断该页面为flash页面，则截取win.location.href中ref到&amp;之间的字符串作为结果。否则直接返回encodeURIComponent编码后的referrer，如：referrer:https%3A%2F%2Fgroup.gomeplus.com%2Ftopic%2F58085f7d4b70a437327ab705.html%3Fcsid%3D150000001002 当前页是否为浏览器默认首页:is_homepage若是IE10以下的IE浏览器，通过document.body.addBehavior(&quot;#default#homePage&quot;);,而后通过document.body.isHomePage(win.location.href)判断。除此之外，置为is_homepage:unkown 页面DOM数:dom_count通过document.getElementsByTagName(&quot;*&quot;).length取得,如： dom_count:542 页面iframe数:iframe_count通过document.getElementsByTagName(&quot;iframe&quot;).length取得,如： iframe_count:0 当前页面的url:urlencodeURIComponent(window.location.href), 如：url:https%3A%2F%2Fwww.gomeplus.com%2F 当前网站环境:env测试当前url的host中是否包含dev，test，pre，有则置为相应环境，没有则置为pro，如env:pro 3.3.3. 用户信息UI phpsid通过在cookie中取得mx_wap_gomeplusid或mx_pc_gomeplusid并返回，如phpsid:h1cmcj37euhqru7d3v33fjvff6 唯一用户标记:ssid若cookie中不存在ssid的cookie，则设置一个随机字符串作为ssid，设置5年的cookie，并返回，如ssid:87418208056.1480669727100,该值前面是11位数，后面为当前时间值 7天是否访问过此页面:is_new检查cookie中是否有isnew的值，若存在，则返回is_new:0,否则设置其期限为7天的随机值。 用户id:uid获取window.userId并返回，如：uid:0 店铺id:shop_idwindow.BPConfig.shop_id,如shop_id:0 商品id:produce_idwindow.BPConfig.produce_id,如produce_id:0 圈子id:group_idwindow.groupId, 如group_id:0 话题id:topic_idwindow.topicId, 如topic_id:0 频道id:channelwindow.BPConfig.channel，如channel:0 3.3.4. 特别信息SI 获取plasttime:last_timewindow.BPConfig.serverTime存在，则设置cookie中plasttime为为该时间，否则设置为当前时间，期限都是1年，并返回如last_time:1480675047 获取active_no属性:active_nowindow.active_no, 如active_no:- 获取页面id:page_idwindow.page_id, 如page_id:- 获取页面name:page_namewindow.page_name, 如page_name:- 3.3.5. 性能信息P 页面服务器时间:sdatewindow.BPConfig.serverTime 页面加载结束时间:load_timeloadTime - startTime,loadTime为页面load事件触发时记录的时间，startTime = win.BPConfig.startTime 页面节点加载完成时间:ready_timereadyTime - startTime,readyTime为jquery的ready触发时记录时间，大多数情况比load要早，一般在DOMContentLoaded时被触发。 页面header加载时间：first_screen_timeheadEndTime - startTime, headEndTime = win.BPConfig.headEndTime js sdk版本:version直接写在源文件中 4. 后续完善 协调加入模拟登录 更多可视化效果","excerpt":"埋点管理平台前端构建及js SDK"},{"title":"bootstrap","date":"2017-09-04T09:37:59.332Z","path":"FE/bootstrap.html","text":"1.&nbsp模态框1. 模态框//包含vue字符 &lt;modal :show.sync=\"showEditRecordModal\" effect=\"fade\"&gt; &lt;div slot=\"modal-header\" class=\"modal-header\"&gt; &lt;h4 class=\"modal-title\"&gt;修改数据&lt;/h4&gt; &lt;/div&gt; &lt;div slot=\"modal-body\" class=\"modal-body\"&gt; &lt;form id=\"editdata\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-12\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;名称 &lt;span style=\"color:red\"&gt;*&lt;/span&gt;&lt;/label&gt; &lt;input type = \"text\" name = \"name\" class = \"form-control\" data-msg-required = \"不能为空\" v-model = \"currentRecord.name\" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-12\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;联系人 &lt;span style=\"color:red;\"&gt;*&lt;/span&gt;&lt;/label&gt; &lt;input type = \"text\" name = \"contact\" class = \"form-control\" data-msg-required = \"不能为空\" v-model = \"currentRecord.contact\" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-12\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;手机号 &lt;span style=\"color:red;\"&gt;*&lt;/span&gt;&lt;/label&gt; &lt;input type=\"text\" name=\"phone\" class=\"form-control\" data-rule-mobile=\"true\" data-msg-required=\"请输入手机号\" data-msg-mobile=\"请输入正确格式\" v-model=\"currentRecord.phone\" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-12\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;邮箱&lt;/label&gt; &lt;input type = \"email\" name = \"email\" class = \"form-control\" data-rule-email = \"true\" data-msg-required = \"请输入email地址\" data-msg-email = \"请输入正确的email地址\" v-model = \"currentRecord.email\" required&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-lg-12\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;备注&lt;/label&gt; &lt;textarea class=\"form-control\" id=\"comment\" name=\"description\"&gt;{{ currentRecord.description }}&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;div slot=\"modal-footer\" class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-default\" @click='editRecord_abort'&gt;中止&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-danger\" @click='editRecord_save'&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/modal&gt;","excerpt":"bootstrap"},{"title":"autorivet","date":"2017-09-04T09:37:59.332Z","path":"FE/autorivet.html","text":"1.1.&nbsp设备操作1.1.1.&nbsp基本操作1.1.1.1.&nbsp开机方法1.1.1.2.&nbsp刀具的复位和校准1.1.1.3.&nbsp关机方法1.1.2.&nbsp生产操作1.1.2.1.&nbsp装钉站操作1.1.2.2.&nbsp更换注胶1.1.2.3.&nbspCNC操作1.1.3.&nbsp高级操作1.1.3.1.&nbsp录钉操作1.1.3.2.&nbsp打精度1.2.&nbsp产品准备1.2.1.&nbsp工装1.2.1.1.&nbsp工装#工装列表|工装列表1.2.1.2.&nbsp工装#工装数模|工装数模1.2.1.3.&nbsp工装#工装品种表|工装品种表1.2.1.4.&nbsp工装说明1.2.2.&nbsp试片1.2.2.1.&nbsp试片#规范要求|规范要求1.2.2.2.&nbsp试片#试片托架|试片托架1.2.3.&nbspTVA状态1.2.4.&nbspProcess编程1.2.5.&nbspNC程序1.2.5.1.&nbspNC代码含义1.2.5.2.&nbsp生成及获取1.2.6.&nbsp产品质量要求1.2.6.1.&nbsp铆钉要求1.2.6.2.&nbsp高锁要求1.2.7.&nbsp工艺文件1.3.&nbsp设备分析1.3.1.&nbsp工具分析1.3.1.1.&nbsp下铆头分析1.3.2.&nbsp图纸识别1.3.3.&nbspCNC1.3.4.&nbsp备件清单1.3.5.&nbsp工时效率计算1.4.&nbsp自动化工具开发1.4.1.&nbspSACI_SEARCH1.4.1.1.&nbsp查询模块|零组件、图纸查询模块1.4.2.&nbspAutorivetTeamWork1.4.2.1.&nbsp更新日志1.4.2.2.&nbsp操作通知1.4.3.&nbspNC_Tools1.4.3.1.&nbspMD5校验NC程序1.4.4.&nbspCATIA_Tools1.4.4.1.&nbspTVA_Tools1.4.5.&nbspfileManager1.4.6.&nbspNCSimu1.5.&nbsp其他工作1.5.1.&nbsp工具与材料1.5.2.&nbsp会议纪要1.5.2.1.&nbspS4设备1.1. 设备操作 设备操作使用手册：http://192.168.3.32/INFO/MATERIAL/47/操作及维护手册/中文/vol1end-操作手册.pdf S2设备使用手册] 设备维护手册：http://192.168.3.32/INFO/MATERIAL/47/操作及维护手册/中文/vol2Aend20130109_钻铆机维护手册.pdf S2设备维护手册] 1.1.1. 基本操作1.1.1.1. 开机方法1.1.1.2. 刀具的复位和校准1.1.1.3. 关机方法1.1.2. 生产操作1.1.2.1. 装钉站操作1.1.2.2. 更换注胶1.1.2.3. CNC操作1.1.3. 高级操作1.1.3.1. 录钉操作1.1.3.2. 打精度1.2. 产品准备1.2.1. 工装1.2.1.1. 工装#工装列表|工装列表1.2.1.2. 工装#工装数模|工装数模1.2.1.3. 工装#工装品种表|工装品种表1.2.1.4. 工装说明1.2.2. 试片1.2.2.1. 试片#规范要求|规范要求1.2.2.2. 试片#试片托架|试片托架1.2.3. TVA状态 Test|链接到test 1.2.4. Process编程1.2.5. NC程序1.2.5.1. NC代码含义 M、T、G代码对照表 NC程序命名规则 1.2.5.2. 生成及获取1.2.6. 产品质量要求1.2.6.1. 铆钉要求1.2.6.2. 高锁要求1.2.7. 工艺文件 [//192.168.3.32/aspsite/AutorivetFiles 自动钻铆全部工艺文件] AOI编写 1.3. 设备分析1.3.1. 工具分析1.3.1.1. 下铆头分析1.3.2. 图纸识别 机械图纸 电气图纸 1.3.3. CNC M、T、G代码对照表 1.3.4. 备件清单1.3.5. 工时效率计算1.4. 自动化工具开发1.4.1. SACI_SEARCH1.4.1.1. 查询模块|零组件、图纸查询模块 查询模块|业务代码 1.4.2. AutorivetTeamWork1.4.2.1. 更新日志1.4.2.2. 操作通知1.4.3. NC_Tools1.4.3.1. MD5校验NC程序 MD5校验NC程序#需求分析|需求分析 MD5校验NC程序#业务代码|业务代码 MD5校验NC程序#操作者使用方法|操作者使用方法 1.4.4. CATIA_Tools产品坐标与钻铆机坐标 1.4.4.1. TVA_Tools修复TVA 1.4.5. fileManager1.4.6. NCSimu该工具尚在规划中，使用Unity3D作为引擎，读取NC代码，并进行碰撞仿真。 1.5. 其他工作1.5.1. 工具与材料 超声测厚 1.5.2. 会议纪要1.5.2.1. S4设备S4设计评审","excerpt":"autorivet"},{"title":"async","date":"2017-09-04T09:37:59.332Z","path":"FE/async.html","text":"1.&nbsp事件发布/订阅2.&nbspPromise/Deferred3.&nbsp流程控制库3.1.&nbspasync1. 事件发布/订阅// 订阅 emitter.on(\"event1\", function (message) { console.log(message); }); // 发布 emitter.emit('event1', \"I am message!\");使用哨兵 var after = function (times, callback) { var count = 0, results = {}; return function (key, value) { results[key] = value; count++; if (count === times) { callback(results); } }; }; var done = after(times, render);2. Promise/DeferredPromise状态转换，通过then来进行顺序管理 var Promise = function () { EventEmitter.call(this); }; util.inherits(Promise, EventEmitter); Promise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) { if (typeof fulfilledHandler === 'function') { // 利用once()方法，保证成功回调只执行一次 this.once('success', fulfilledHandler); } if (typeof errorHandler === 'function') { // 利用once()方法，保证异常回调只执行一次 this.once('error', errorHandler); } if (typeof progressHandler === 'function') { this.on('progress', progressHandler); } return this; };不变的部分是Deffred var promise1 = readFile(\"foo.txt\", \"utf-8\"); var promise2 = readFile(\"bar.txt\", \"utf-8\"); var deferred = new Deferred(); deferred.all([promise1, promise2]).then(function (results) { // TODO }, function (err) { // TODO });3. 流程控制库3.1. async 串行执行async.series([ function (callback) { fs.readFile('file1.txt', 'utf-8', callback); }, function (callback) { fs.readFile('file2.txt', 'utf-8', callback); } ], function (err, results) { // results =&gt; [file1.txt, file2.txt] }); 并行执行async.parallel([ function (callback) { fs.readFile('file1.txt', 'utf-8', callback); }, function (callback) { fs.readFile('file2.txt', 'utf-8', callback); } ], function (err, results) { // results =&gt; [file1.txt, file2.txt] }); 依赖处理async.waterfall([ function (callback) { fs.readFile('file1.txt', 'utf-8', function (err, content) { callback(err, content); }); }, function (arg1, callback) { // arg1 =&gt; file2.txt fs.readFile(arg1, 'utf-8', function (err, content) { callback(err, content); }); }, function(arg1, callback){ // arg1 =&gt; file3.txt fs.readFile(arg1, 'utf-8', function (err, content) { callback(err, content); }); } ], function (err, result) { // result =&gt; file4.txt });","excerpt":"async"},{"title":"apache","date":"2017-09-04T09:37:59.332Z","path":"Server/apache.html","text":"1.&nbspApache安装2.&nbspApache配置2.1.&nbsp多域名配置3.&nbsp模块启用4.&nbspApache重启1. Apache安装apt-get install apache2Apache2与Apache区别见：http://baike.baidu.com/link?url=0F0sTBs-qUk9KpPhuE50fge5TzDRFJqVUnVRHV3u84-iukNURiAeZf1Jpn7DPEQ1eraxinPkuquTs3qkfRVQJ_ 2. Apache配置编辑apache配置文件： vim /etc/apache2/sites-available/000-default.conf,实际上该文件被软连接到/etc/apache2/sites-enabled目录中，而该目录的配置文件被包含在/etc/apache2/apache2.conf，从而使得Apache启动时生效。 2.1. 多域名配置 在httpd.conf中，确认Include conf/extra/httpd-vhosts.conf未被注释 在httpd.conf中，增加要监听的端口号，如Listen 8880 在httpd.conf中，将相关设置变更为如下： &lt;Directory /&gt; # Options Indexes FollowSymLinks # 允许索引目录 # 不允许索引目录 Options FollowSymLinks # 允许.htaccess覆写配置 AllowOverride All Order allow,deny Allow from all # Require all denied # 拒绝所有 &lt;/Directory&gt; 编辑apache/conf/extra中的httpd-vhosts.conf，增加相关设置 &lt;VirtualHost *:8880&gt; ServerAdmin webmaster@dummy-host.example.com DocumentRoot \"H:\\yourpath\" ServerName localhost ServerAlias localhost ErrorLog \"logs/yoursite.log\" CustomLog \"logs/dummy-host.example.com-access.log\" common &lt;Directory \"H:\\yourpath\"&gt; Options FollowSymLinks AllowOverride None Order allow,deny Allow from all &lt;/Directory&gt; &lt;/VirtualHost&gt; 重启apache 3. 模块启用但配置文件中涉及其他模块如rewrite时，需要启用该模块，即是在/etc/apache2/mods-available文件夹中将rewrite.load软连接至mods-enabled文件夹至： ln -s /etc/apache2/mods-available/rewrite.load /etc/apache2/mods-enabled/rewrite.load4. Apache重启service apache2 restart或： /etc/init.d/apache2 restart","excerpt":"apache"},{"title":"CSS","date":"2017-09-04T09:37:59.332Z","path":"FE/css.html","text":"1.&nbsp教程1.1.&nbsp编写1.2.&nbsp引入1.3.&nbsp选择器1.3.1.&nbsp样式匹配1.3.2.&nbsp伪元素2.&nbsp布局2.1.&nbsp定位2.1.1.&nbsp水平居中2.1.2.&nbsp垂直居中2.2.&nbsp单列布局2.3.&nbsp二列&amp;三列布局2.3.1.&nbsp浮动布局2.3.2.&nbsp绝对定位布局2.3.3.&nbsp圣杯布局2.3.4.&nbsp双飞翼布局2.3.5.&nbspflex布局3.&nbsp概念3.1.&nbsp盒子模型3.1.1.&nbspbox-sizing3.2.&nbsp属性值的级联和继承3.2.1.&nbsp几个值3.2.2.&nbsp继承3.2.3.&nbsp@import3.2.4.&nbsp级联3.2.4.1.&nbsp选择器权重3.2.5.&nbsp其他3.3.&nbspBFC3.3.1.&nbsp触发条件3.3.2.&nbsp应用3.4.&nbsp边距折叠3.4.1.&nbsp折叠条件3.4.2.&nbsp折叠结果3.4.3.&nbsp结论3.5.&nbspMedia types3.6.&nbspclearance4.&nbsp技巧4.1.&nbsp文字省略1. 教程1.1. 编写http://www.w3school.com.cn/example/csse_examples.asp CSS语句由选择器和声明组成 1.2. 引入&lt;LINK rel=\"stylesheet\" href=\"bach.css\" type=\"text/css\"&gt;注意src与href区别，src用于替换当前元素，href是链接,href是并行处理,src串行处理 &lt;script src=\"javascripts/resume.js\"&gt;&lt;/script&gt;1.3. 选择器http://www.w3school.com.cn/cssref/css_selectors.asp em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 http://www.w3.org/TR/2011/REC-CSS2-20110607/selector.html 1.3.1. 样式匹配 E[foo~=”warning”]属性中以空格分隔的，包含warning单词 E[lang|=”en”]属性中以连字符-分隔的，包含en单词 DIV.warning等同于 DIV[class~=”warning”]用法同jade E#myid用法同jade E + F匹配在E旁边的F 1.3.2. 伪元素 :first-line第一行，只能应用于块级元素 :first-letter 第一个字母 :before and :after用于插入内容，在p元素note类前插入”Note: “http://www.w3.org/TR/2011/REC-CSS2-20110607/generate.htmlp.note:before { content: \"Note: \" } 2. 布局https://zhuanlan.zhihu.com/p/25565751 2.1. 定位2.1.1. 水平居中 行内元素：对父元素设置text-align:center; https://codepen.io/goumang2010/pen/EXWbzm 定宽块状元素: 设置左右margin值为auto; https://codepen.io/goumang2010/pen/ZyeagO 不定宽块状元素: 设置子元素为display:inline,然后在父元素上设置text-align:center; 通用方案: 对子元素设置position: relative; left: 50%;margin-left: 宽度一半 https://codepen.io/goumang2010/pen/PjpEwL 通用方案: flex布局，对父元素设置display:flex;justify-content:center; https://codepen.io/goumang2010/pen/bRqabX 2.1.2. 垂直居中 父元素一定，子元素为单行内联文本：设置父元素行高line-height等于父元素的height https://codepen.io/goumang2010/pen/eRvygW 父元素一定，子元素为多行内联文本：设置父元素的display:table-cell，再设置vertical-align:middle； https://codepen.io/goumang2010/pen/gRmomJ 块状元素:设置子元素position:absolute 并设置top、bottom为0，父元素要设置定位为static以外的值，margin:auto; https://codepen.io/goumang2010/pen/weJpPa 通用方案: flex布局，给父元素设置{display:flex; align-items:center;}。 2.2. 单列布局 同宽： https://codepen.io/goumang2010/pen/owZeoa 不同宽： https://codepen.io/goumang2010/pen/gRmxzY 2.3. 二列&amp;三列布局二列布局的特征是侧栏固定宽度，主栏自适应宽度。三列布局的特征是两侧两列固定宽度，中间列自适应宽度。 2.3.1. 浮动布局设置两个侧栏分别向左向右浮动，中间列通过外边距给两个侧栏腾出空间，中间列的宽度根据浏览器窗口自适应。 两栏： https://codepen.io/goumang2010/pen/GEWvwR 三栏：https://codepen.io/goumang2010/pen/dRvzja 2.3.2. 绝对定位布局 两栏： https://codepen.io/goumang2010/pen/zzZdVL 三栏： https://codepen.io/goumang2010/pen/RgpZdb 2.3.3. 圣杯布局 主面板设置宽度为100%，主面板与两个侧栏都设置浮动，常见为左浮动，这时两个侧栏会被主面板挤下去。 通过负边距将浮动的侧栏拉上来，左侧栏的负边距为100%，刚好是窗口的宽度，因此会从主面板下面的左边跑到与主面板对齐的左边 右侧栏此时浮动在主面板下面的左边，设置负边距为负的自身宽度刚好浮动到主面板对齐的右边 为了避免侧栏遮挡主面板内容，在外层设置左右padding值为左右侧栏的宽度，给侧栏腾出空间，此时主面板的宽度减小 使用相对布局，调整两个侧栏到相应的位置。使其不遮挡主面板的内容 https://codepen.io/goumang2010/pen/yXMzOK 当面板的main内容部分比两边的子面板宽度小的时候，布局就会乱掉。可以通过设置main的min-width属性或使用双飞翼布局避免问题。 2.3.4. 双飞翼布局双飞翼布局在圣杯布局上做了改进，在main元素上加了一层div（main-wrap）, 并设置margin,由于两侧栏的负边距都是相对于main-wrap而言，main的margin值变化便不会影响两个侧栏，因此省掉了对两侧栏设置相对布局的步骤。 https://codepen.io/goumang2010/pen/gRmGGg 2.3.5. flex布局https://codepen.io/goumang2010/pen/ZyeXjV 3. 概念http://www.w3.org/TR/2011/REC-CSS2-20110607/#minitoc 3.1. 盒子模型3.1.1. box-sizinghttp://www.cnblogs.com/zhaoran/archive/2013/05/24/3097482.html content-box，border和padding不计算入width之内 padding-box，padding计算入width内 border-box，border和padding计算入width之内，其实就是怪异模式 https://codepen.io/goumang2010/pen/OgpOvB 3.2. 属性值的级联和继承http://www.w3.org/TR/2011/REC-CSS2-20110607/cascade.html 3.2.1. 几个值 Specified values指定值：如果有明确的指定值，则运用，否则寻找继承，没有继承则使用默认值 Computed values计算值：转化指定值中相对数值； Used values使用值：考虑计算值依赖关系后形成结果； Actual values实际值：考虑实际硬件情况，所渲染出的值； 3.2.2. 继承 继承遵循文档树并且不会被匿名盒子打破； 根节点的值将被视为初始值； 3.2.3. @import在css中引用其他的css @import url(\"fineprint.css\") print; @import url(\"bluish.css\") projection, tv;3.2.4. 级联 找 target media type 找声明 权重排序 3.2.4.1. 选择器权重a b c d 逐级比较覆盖 a非选择器为1(内联style)，否则为0 b ID的数量 c 属性和伪类的数量 d 元素和伪元素的数量* {} /* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */ li {} /* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */ li:first-line {} /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */ ul li {} /* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */ ul ol+li {} /* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */ h1 + *[rel=up]{} /* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */ ul ol li.red {} /* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */ li.red.level {} /* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */ #x34y {} /* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */ style=\"\" /* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */ 3.2.5. 其他html的非css的属性往往会被UA置于样式表的头部，而可能被样式表之后的内容所覆盖 3.3. BFChttp://web.jobbole.com/84808/http://www.imooc.com/article/9723 在BFC下，内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘），即使存在浮动也是如此。 BFC的区域不会与其外的float box重叠。 计算BFC的高度时，浮动元素也参与计算。 内部元素的布局不会影响外部元素。 3.3.1. 触发条件 浮动元素，float 除 none 以外的值 绝对定位元素，position的值不为relative和static（absolute，fixed） display为以下其中之一的值inline-block, table-cell, table-caption, flex，inline-flex overflow 除了 visible 以外的值（hidden，auto，scroll） 3.3.2. 应用 清除浮动（防止塌陷）：https://codepen.io/goumang2010/pen/wegYPp 自适应两栏布局： https://codepen.io/goumang2010/pen/mwRQmL 解决与子元素边距折叠。 3.4. 边距折叠https://www.w3.org/TR/CSS2/box.html#collapsing-margins 3.4.1. 折叠条件 常规文档流，（非float和绝对定位）的块级盒子,并且处于同一个BFC当中。 没有线盒，没有空隙，没有padding和border将他们分隔开 都属于垂直方向上相邻的外边距，可以是下面任意一种情况： 元素的margin-top与其第一个常规文档流的子元素的margin-top 元素的margin-bottom与其下一个常规文档流的兄弟元素的margin-top height为auto的元素的margin-bottom与其最后一个常规文档流的子元素的margin-bottom 高度为0并且最小高度也为0，不包含常规文档流的子元素，并且自身没有建立新的BFC的元 3.4.2. 折叠结果 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 3.4.3. 结论https://codepen.io/goumang2010/pen/jwyQjb 创建了新的BFC的元素与它的子元素的外边距不会折叠 浮动元素不与任何元素的外边距产生折叠（包括其父元素和子元素） 绝对定位元素不与任何元素的外边距产生折叠（要求常规文档流） inline-block元素不与任何元素的外边距产生折叠（要求块级盒子） 一个常规文档流元素的margin-bottom与它下一个常规文档流的兄弟元素的margin-top会产生折叠，除非它们之间存在间隙（clearance）。 一个常规文档流元素的margin-top 与其第一个常规文档流的子元素的margin-top产生折叠，条件为父元素不包含 padding 和 border ，子元素不包含 clearance。 一个 ‘height’ 为 ‘auto’ 并且 ‘min-height’ 为 ‘0’的常规文档流元素的 margin-bottom 会与其最后一个常规文档流子元素的 margin-bottom 折叠，条件为父元素不包含 padding 和 border ，子元素的 margin-bottom 不与包含 clearance 的 margin-top 折叠。 一个不包含border-top、border-bottom、padding-top、padding-bottom的常规文档流元素，并且其 ‘height’ 为 0 或 ‘auto’， ‘min-height’ 为 ‘0’，其里面也不包含行盒(line box)，其自身的 margin-top 和 margin-bottom 会折叠。 3.5. Media typesRelationship between media groups and media typesMedia Types Media Groups&nbsp; continuous/paged visual/audio/speech/tactile grid/bitmap interactive/staticbraillecontinuoustactilegridbothembossedpagedtactilegridstatichandheldbothvisual, audio, speechbothbothprintpagedvisualbitmapstaticprojectionpagedvisualbitmapinteractivescreencontinuousvisual, audiobitmapbothspeechcontinuousspeechN/Abothttycontinuousvisualgridbothtvbothvisual, audiobitmapboth 3.6. clearancehttps://codepen.io/goumang2010/pen/owBJza 闭合浮动元素的clearance = 浮动元素上下边距高度 + 浮动元素height +浮动元素的上下边框高度+浮动元素的上下内边距高度。 4. 技巧4.1. 文字省略https://codepen.io/goumang2010/pen/eRvGoa","excerpt":"All about CSS, including selector, layout, position"},{"title":"Ajax","date":"2017-09-04T09:37:59.332Z","path":"FE/ajax.html","text":"1.&nbsp原生写法1.1.&nbspget1.2.&nbsppost2.&nbspJquery3.&nbsp跨域写法1. 原生写法http://sjpsega.iteye.com/blog/1729350 function createXMLHTTPRequest() { //1.创建XMLHttpRequest对象 //这是XMLHttpReuquest对象无部使用中最复杂的一步 //需要针对IE和其他类型的浏览器建立这个对象的不同方式写不同的代码 var xmlHttpRequest; if (window.XMLHttpRequest) { //针对FireFox，Mozillar，Opera，Safari，IE7，IE8 xmlHttpRequest = new XMLHttpRequest(); //针对某些特定版本的mozillar浏览器的BUG进行修正 if (xmlHttpRequest.overrideMimeType) { xmlHttpRequest.overrideMimeType(\"text/xml\"); } } else if (window.ActiveXObject) { //针对IE6，IE5.5，IE5 //两个可以用于创建XMLHTTPRequest对象的控件名称，保存在一个js的数组中 //排在前面的版本较新 var activexName = [ \"MSXML2.XMLHTTP\", \"Microsoft.XMLHTTP\" ]; for ( var i = 0; i &lt; activexName.length; i++) { try { //取出一个控件名进行创建，如果创建成功就终止循环 //如果创建失败，回抛出异常，然后可以继续循环，继续尝试创建 xmlHttpRequest = new ActiveXObject(activexName[i]); if(xmlHttpRequest){ break; } } catch (e) { } } } return xmlHttpRequest; }1.1. get function get(){ var req = createXMLHTTPRequest(); if(req){ req.open(\"GET\", \"http://test.com/?keywords=手机\", true); req.onreadystatechange = function(){ if(req.readyState == 4){ if(req.status == 200){ alert(\"success\"); }else{ alert(\"error\"); } } } req.send(null); } }1.2. post function post(){ var req = createXMLHTTPRequest(); if(req){ req.open(\"POST\", \"http://test.com/\", true); req.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded; charset=gbk;\"); req.send(\"keywords=手机\"); req.onreadystatechange = function(){ if(req.readyState == 4){ if(req.status == 200){ alert(\"success\"); }else{ alert(\"error\"); } } } } }2. Jquery $.ajax({ url: 'addnote',// 跳转到 action data: { noteText: note.text(), ifkeychanged: $('#keepkey').attr(\"checked\"), }, type: 'post', cache: false, // dataType: 'json', success: function (data) { showQR(data); }, error: function () { alert(\"通信异常！\"); } });3. 跨域写法// 参照： /*! qwest 4.4.5 (https://github.com/pyrsmk/qwest) */ const jsonToQuery = function (a) { const add = function (s, k, v) { v = typeof v === 'function' ? v() : v === null ? '' : v === undefined ? '' : v; s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v); }; const buildParams = function (prefix, obj, s) { let i; let len; let key; if (Object.prototype.toString.call(obj) === '[object Array]') { for (i = 0, len = obj.length; i &lt; len; i++) { buildParams(prefix + '[' + (typeof obj[i] === 'object' ? i : '') + ']', obj[i], s); } } else if (obj &amp;&amp; obj.toString() === '[object Object]') { for (key in obj) { if (obj.hasOwnProperty(key)) { if (prefix) { buildParams(prefix + '[' + key + ']', obj[key], s, add); } else { buildParams(key, obj[key], s, add); } } } } else if (prefix) { add(s, prefix, obj); } else { for (key in obj) { add(s, key, obj[key]); } } return s; }; return buildParams('', a, []).join('&amp;').replace(/%20/g, '+'); }; const JSONParse = function () { if (window.JSON) { return JSON.parse; } else { return function (jsonstr) { return (new Function(\"return\" + jsonstr))(); }; } }(); const win = typeof window !== 'undefined' ? window : self; // Get XMLHttpRequest object let xdr; let getXHR = win.XMLHttpRequest ? function () { return new win.XMLHttpRequest(); } : function () { return new win.ActiveXObject('Microsoft.XMLHTTP'); }; let xhr2 = (getXHR().responseType === ''); function Xget(url, data, options) { this.headers = { Accept: '*/*', 'Cache-Control': '' }; this.callback = options.callback; this.errHandler = options.errHandler || function (msg) { console.log(`error: ${msg}`); }; // Prepare URL this.url = url + '?' + jsonToQuery(data); this.options = { _async: true, timeout: 30000, attempts: 2 }; this.attempts = 0; this.aborted = false; // timeout id this.timeoutid = null; // Guess if we're dealing with a cross-origin request let i = url.match(/\\/\\/(.+?)\\//); this.crossOrigin = i &amp;&amp; (i[1] ? i[1] !== location.host : false); } Xget.prototype.abort = function () { if (!this.aborted) { if (this.xhr &amp;&amp; this.xhr.readyState !== 4) { // https://stackoverflow.com/questions/7287706/ie-9-javascript-error-c00c023f this.xhr.abort(); } this.aborted = true; } }; Xget.prototype.handleResponse = function (xhr = this.xhr) { clearTimeout(this.timeoutid); // Verify if the request has not been previously aborted if (this.aborted) { return; } // Handle response try { // Process response if (xhr.responseType === 'json') { if ('response' in xhr &amp;&amp; xhr.response === null) { throw 'The request response is empty'; } this.response = xhr.response; } else { this.response = JSONParse(xhr.responseText); } // Late status code verification to allow passing data when, per example, a 409 is returned // --- https://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request if ('status' in xhr &amp;&amp; !/^2|1223/.test(xhr.status)) { throw xhr.status + ' (' + xhr.statusText + ')'; } // Fulfilled this.callback(this.response); } catch (e) { // Rejected this.handleError(e); } }; Xget.prototype.handleTimeout = function () { if (!this.aborted) { if (!this.options.attempts || ++this.attempts !== this.options.attempts) { this.xhr.abort(); this.send(); } else { this.handleError({ message: 'Timeout (' + this.url + ')' }); } } }; Xget.prototype.handleError = function (e) { console.log(e); let message = e &amp;&amp; e.message; if (!this.aborted) { message = typeof message === 'string' ? message : 'Connection aborted'; this.abort(); this.errHandler(message); } }; Xget.prototype.send = function ({ method = 'get', url = this.url, options = this.options, headers = this.headers } = {}) { // Get XHR object let xhr = getXHR(); if (this.crossOrigin &amp;&amp; win.XDomainRequest) { xhr = new XDomainRequest(); // CORS with IE8/9 xdr = true; } // Open connection if (xdr) { xhr.open(method, url); } else { xhr.open(method, url, options._async); } this.xhr = xhr; // Set headers if (!xdr) { for (var i in headers) { if (headers[i]) { xhr.setRequestHeader(i, headers[i]); } } } // Plug response handler if (xhr2 || xdr) { xhr.onload = () =&gt; { this.handleResponse.apply(this); }; xhr.onerror = () =&gt; { this.handleError.apply(this); }; // http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/ if (xdr) { xhr.onprogress = function () {}; } } else { xhr.onreadystatechange = () =&gt; { if (xhr.readyState === 4) { this.handleResponse.apply(this); } }; } // Plug timeout if (options._async) { if ('timeout' in xhr) { xhr.timeout = options.timeout; xhr.ontimeout = () =&gt; { this.handleTimeout.apply(this); }; } else { this.timeoutid = setTimeout(() =&gt; { this.handleTimeout.apply(this); }, options.timeout); } // http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/ } else if (xdr) { xhr.ontimeout = function () {}; } // Send request if (xdr) { // https://developer.mozilla.org/en-US/docs/Web/API/XDomainRequest setTimeout(function () { xhr.send(null); }, 0); } else { xhr.send(null); } }; export default Xget;","excerpt":"ajax写法"},{"title":"VPS","date":"2017-09-04T09:37:59.332Z","path":"FE/VPS.html","text":"1.&nbspVPS连接1.1.&nbspMAC1.2.&nbspWindows1.2.1.&nbsp使用putty1.3.&nbspWebSocket2.&nbspVPS选择2.1.&nbsp厂家2.1.1.&nbsphttps://www.vultr.com/pricing/ vultr2.1.2.&nbsphttps://bandwagonhost.com/ 搬瓦工]2.1.3.&nbsphttp://www.host1plus.com/vps-hosting/ host1plus2.1.4.&nbsphttps://hostus.us/openvz-vps.html hostus2.1.5.&nbsphttp://virmach.com/ virmach2.1.6.&nbsphttps://www.alpharacks.com/ AlphaRacks2.1.7.&nbsphttps://www.digitalocean.com/pricing/ Digital Ocean2.1.8.&nbsphttps://www.linode.com/ linode2.2.&nbsp比对及选择2.2.1.&nbsp速度2.2.2.&nbsp配置2.2.3.&nbsp价格2.2.4.&nbsp选择2.3.&nbsp参考资料1. VPS连接1.1. MAC使用iTerm，用ssh登录 1.2. Windows1.2.1. 使用puttyhttp://www.chiark.greenend.org.uk/~sgtatham/putty/download.html使用putty工具，输入地址后，保存配置（为了下次打开不需要重新输入），点击openpem文件使用puttyGen来进行转化 1.3. WebSocket利用VPS服务商提供的功能，但显示效果一般不好 2. VPS选择2.1. 厂家2.1.1. https://www.vultr.com/pricing/ vultr5刀=1CPU 788MB 15GBSSD 1000GB前2个月免费 2.1.2. https://bandwagonhost.com/ 搬瓦工]4.99刀=1CPU 512MB 20GBSSD 1000GB 2.1.3. http://www.host1plus.com/vps-hosting/ host1plus4.75刀=1CPU 765MB 60GBSSD 1000GB 2.1.4. https://hostus.us/openvz-vps.html hostus美国机房7.95刀每季度=1CPU 788MB 15GBSSD 500GB 2.1.5. http://virmach.com/ virmach官网访问速度慢5刀=2CPU 512MB 20GBSSD 1000GB 2.1.6. https://www.alpharacks.com/ AlphaRacks官网访问速度极慢5刀=1CPU 512MB 70GBSSD 1500GB 2.1.7. https://www.digitalocean.com/pricing/ Digital Ocean5刀=1CPU 512MB 20GBSSD 1000GB 2.1.8. https://www.linode.com/ linode赠送50刀10刀=1CPU 1024MB 24GBSSD 2000GB 2.2. 比对及选择2.2.1. 速度作为日常学习折腾用，优先为亚洲机房 2.2.2. 配置以以下重要程度进行排序：内存大小&gt;SSD&gt;CPU核数 2.2.3. 价格预算在每月10刀内，性价比最优 2.2.4. 选择综合以上，选择现有赠送50刀活动的vultr作为第一个练手的VPS 2.3. 参考资料https://www.zhihu.com/question/20800554 https://www.zhihu.com/question/21438383","excerpt":"VPS"},{"title":"VM","date":"2017-09-04T09:37:59.332Z","path":"FE/VM.html","text":"1.&nbsp磁盘格式转换1.1.&nbspGHO -&gt; VMDK2.&nbsp转化为虚拟机2.1.&nbspWin7及以下1. 磁盘格式转换1.1. GHO -&gt; VMDK使用ghost将分区直接转化为VMDK 2. 转化为虚拟机2.1. Win7及以下 使用ghost将分区直接转化为VMDK 复制备份C:\\Windows\\System32\\drivers 虚拟机安装相同系统版本的Ghost系统 拷贝虚拟机Ghost系统的C:\\Windows\\System32\\drivers 打开VMDK，获取C:\\Windows\\System32\\drivers所有权及更改权限，使用虚拟机的文件替换之. 若系统版本不同，则仅补充新的文件，不可覆盖。 修复VMDK的引导，并启动。 启动后，若有功能不正常，用备份的C:\\Windows\\System32\\drivers替换之，跳过正在使用的文件，这样就把加载失败的驱动替换回了原驱动。","excerpt":"虚拟机相关"},{"title":"SSH","date":"2017-09-04T09:37:59.332Z","path":"FE/SSH.html","text":"1.&nbsp登录2.&nbsp下载上传2.1.&nbspWindows2.1.1.&nbsp使用pscp2.1.2.&nbsprz,sz1. 登录如 ssh -l username -p 24334 10.34.3.442. 下载上传下载文件： scp root@45.32.16.114:/etc/nginx/sites-available/default /Users/lizhongning/OneDrive/backup上传文件 scp /Users/lizhongning/OneDrive/backup/default ubuntu@54.213.133.73:/etc/nginx/sites-available/2.1. Windows2.1.1. 使用pscphttp://www.chiark.greenend.org.uk/~sgtatham/putty/download.html 下载文件 pscp -i privatekey.ppk -r user@111.111.11.11:Dictory D:/2.1.2. rz,sz 在linux上安装ZModem yum install lrzsz windows上安装支持ZModem的客户端，如SecureCRT，xshell等，putty和git bash不行 在ssh客户端中使用sz rz命令 sz tar.sh rz 文件都指当前linux目录下","excerpt":"SSH"},{"title":"JSON","date":"2017-09-04T09:37:59.332Z","path":"FE/JSON.html","text":"1.&nbspJson对象转为object2.&nbspJson字符串转为object3.&nbspObject/Json对象转为字符串1. Json对象转为object//使用Jquery$.parseJSON() 2. Json字符串转为objectJSON.parse() 3. Object/Json对象转为字符串JSON.stringify()","excerpt":"JSON"},{"title":"CDN","date":"2017-09-04T09:37:59.332Z","path":"FE/CDN.html","text":"1.&nbspjs1.1.&nbsp百度1.2.&nbspbootcdn2.&nbspcss2.1.&nbsp新浪1. js1.1. 百度http://cdn.code.baidu.com/ Jquery：http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js bootstrap：http://apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js 1.2. bootcdnhttp://www.bootcdn.cn/ 2. css2.1. 新浪http://lib.sinaapp.com/ BootStrap（3.00）：http://lib.sinaapp.com/js/bootstrap/v3.0.0/css/bootstrap.min.css","excerpt":"CDN"},{"title":"wiki","date":"2017-09-04T09:37:59.328Z","path":"uncategorized/wiki.html","text":"Please wait for translation…","excerpt":"How to build this wiki"}]}