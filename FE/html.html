<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>html | Chuune Wiki</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="//cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-shim.min.js"></script>
  <script src="//apps.bdimg.com/libs/html5shiv/3.7/html5shiv.min.js"></script>
  <link rel="shortcut icon" type="image/png" href="favicon.png"/>
  <link rel="stylesheet" href="/css/index.css">
</head>

  <body>
  <header class="header-page">
    <div class="header-content">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <h1 class="header-logo">
        <a class="no-style header-link" href="
        
          /zh-cn
        
        ">Chuune Wiki</a>
      </h1>
      <div class="menu">
        <a class="no-style header-link" href="/zh-cn/archives">索引</a>
        <a class="no-style header-link" target="_blank" href="https://github.com/goumang2010/hexo-wiki/edit/master/source/_posts/zh-cn/html.md">编辑</a>
        <a class="no-style header-link" href="/readme">README</a>
        <a class="no-style header-link" target="_blank" href="https://github.com/goumang2010/hexo-wiki">GitHub</a>
      </div>
      <div id="header-search-div" class="header-search-div">
        <input id="header-search-input" class="header-search-input" type="text" placeholder="搜索"/>
        <div id="header-search-box" class="header-search-box"><ul id="header-search-list"></ul></div>
      </div>
      <div class="header-lang-select-wrap header-link menu">
        <label>
        
          简体中文
        
        </label>
        <select id="header-lang-select" class="header-lang-select">
        
          
            <option
              value=""
              selected
            >
              简体中文
            </option>
          
            <option
              value=""
              
            >
              English
            </option>
          
        
        </select>
      </div>
    </div>
 <nav id="mobile-nav">
    <a class="no-style header-link" href="
    
      /zh-cn
    
    ">首页</a>
	<a href="/zh-cn/archives">索引</a>
	<a target="_blank" href="https://github.com/goumang2010/hexo-wiki/edit/master/source/_posts/zh-cn/html.md">编辑</a>
	<a href="/readme">README</a>
	<a target="_blank" href="https://github.com/goumang2010/hexo-wiki">GitHub</a>
</nav>
</header>

  <section class="container">
  <h2>html</h2>
  html
  <article class="markdown-body article">
  <p><a href="https://github.com/slashhuang/translation/blob/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6" target="_blank" rel="external">https://github.com/slashhuang/translation/blob/master/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6</a></p>
<p><a href="http://domenicodefelice.blogspot.sg/2015/08/how-browsers-work.html" target="_blank" rel="external">http://domenicodefelice.blogspot.sg/2015/08/how-browsers-work.html</a></p>
<div class="toc"><ul><li class="level-1"><a href="#1."><span class="tocnumber">1.</span>&nbsp<span class="toctext">原理</span></a><ul><li class="level-2"><a href="#1.1."><span class="tocnumber">1.1.</span>&nbsp<span class="toctext">两个模块</span></a></li><li class="level-2"><a href="#1.2."><span class="tocnumber">1.2.</span>&nbsp<span class="toctext">四个阶段</span></a><ul><li class="level-3"><a href="#1.2.1."><span class="tocnumber">1.2.1.</span>&nbsp<span class="toctext">解析dom和cssom</span></a></li><li class="level-3"><a href="#1.2.2."><span class="tocnumber">1.2.2.</span>&nbsp<span class="toctext">渲染render tree</span></a></li><li class="level-3"><a href="#1.2.3."><span class="tocnumber">1.2.3.</span>&nbsp<span class="toctext">layout(flow/reflow)阶段</span></a></li><li class="level-3"><a href="#1.2.4."><span class="tocnumber">1.2.4.</span>&nbsp<span class="toctext">paint阶段</span></a></li></ul></li><li class="level-2"><a href="#1.3."><span class="tocnumber">1.3.</span>&nbsp<span class="toctext">reflow和repaint优化</span></a><ul><li class="level-3"><a href="#1.3.1."><span class="tocnumber">1.3.1.</span>&nbsp<span class="toctext">是什么触发了reflow和repaint？</span></a></li><li class="level-3"><a href="#1.3.2."><span class="tocnumber">1.3.2.</span>&nbsp<span class="toctext">reflow和repaint哪个性能开销更大？</span></a></li><li class="level-3"><a href="#1.3.3."><span class="tocnumber">1.3.3.</span>&nbsp<span class="toctext">如何优化css和html以减少reflow？</span></a></li><li class="level-3"><a href="#1.3.4."><span class="tocnumber">1.3.4.</span>&nbsp<span class="toctext">优化javascript</span></a></li><li class="level-3"><a href="#1.3.5."><span class="tocnumber">1.3.5.</span>&nbsp<span class="toctext">同步布局与布局垃圾</span></a></li><li class="level-3"><a href="#1.3.6."><span class="tocnumber">1.3.6.</span>&nbsp<span class="toctext">requestAnimationFrame</span></a></li><li class="level-3"><a href="#1.3.7."><span class="tocnumber">1.3.7.</span>&nbsp<span class="toctext">虚拟dom库</span></a></li></ul></li></ul></li><li class="level-1"><a href="#2."><span class="tocnumber">2.</span>&nbsp<span class="toctext">html parser</span></a><ul><li class="level-2"><a href="#2.1."><span class="tocnumber">2.1.</span>&nbsp<span class="toctext">http</span></a></li><li class="level-2"><a href="#2.2."><span class="tocnumber">2.2.</span>&nbsp<span class="toctext">css</span></a></li></ul></li></ul></div><h1 id="1."><a href="#1." class="headerlink" title="原理"></a>1. 原理</h1><h2 id="1.1."><a href="#1.1." class="headerlink" title="两个模块"></a>1.1. 两个模块</h2><p>浏览器的两个主模块</p>
<ol>
<li>rendering engine 渲染引擎或者称为布局引擎(layout engine)</li>
<li>javascript解析器</li>
</ol>
<p>火狐使用Gecko(由mozilla发明)，Safari和谷歌的chrome都使用webkit引擎。<br>谷歌的chrome在版本27之后使用Blink引擎。</p>
<h2 id="1.2."><a href="#1.2." class="headerlink" title="四个阶段"></a>1.2. 四个阶段</h2><p>渲染引擎的工作:<br>从基本的html css js 开始渲染整个屏幕的网页，粗浅的经过四个阶段</p>
<ol>
<li>解析html为dom树，解析css为cssom。</li>
<li>把dom和cssom结合起来生成渲染树render tree</li>
<li>布局render tree，计算几何形状</li>
<li>把render tree展示到屏幕上</li>
</ol>
<p>以上四步同时并多次执行</p>
<p>由于浏览器会尝试尽快展示内容，所以内容有时会在样式还没有加载的时候展示出来。<br>这就是经常发生的FOCU(flash of unstyled content)问题。</p>
<h3 id="1.2.1."><a href="#1.2.1." class="headerlink" title="解析dom和cssom"></a>1.2.1. 解析dom和cssom</h3><ul>
<li>在这个阶段，引擎html parser开始解析html，解析出来的结果会成为一棵dom树。html和dom并不是1:1的关系，dom树的根节点是<html>元素</html></li>
<li>dom树的目的至少有2个：1. 作为下个阶段render tree的输入。 2. 成为网页和脚本的接口。(如 getElementById)</li>
<li>当所有的html解析完成，整个document被标记可交互的，它的状态显示为完成。<ul>
<li>defer脚本会被执行</li>
<li>load event会被执行</li>
</ul>
</li>
</ul>
<h3 id="1.2.2."><a href="#1.2.2." class="headerlink" title="渲染render tree"></a>1.2.2. 渲染render tree</h3><p>dom节点和cssom会合并渲染新的树状图。它的结构和dom树类似，但不是完全一样:只有可见元素才会在这棵树中(以下称为tree);例如head，script标签都不会在树中，所有拥有display:none样式的节点也不会在树中。<br>整个结构是按照它们的渲染顺序可视化的树状图，每个节点都存储着应用在它上面的css属性。<br>这些节点在不同的浏览器中被称为不同的:</p>
<ul>
<li>webkit称它为renderers</li>
<li>firefox称它为frames</li>
<li>有些时候节点也直接称为boxes。</li>
</ul>
<h3 id="1.2.3."><a href="#1.2.3." class="headerlink" title="layout(flow/reflow)阶段"></a>1.2.3. layout(flow/reflow)阶段</h3><p>一个节点的图形位置和尺寸，有时在css样式表中规定，有时不在。不管如何，它们都必须被计算，以便所有的节点能正确的渲染。浏览器会从根节点遍历render tree, 进行图形计算，这时相关的在css中使用的单元都转化成pixels。</p>
<h3 id="1.2.4."><a href="#1.2.4." class="headerlink" title="paint阶段"></a>1.2.4. paint阶段</h3><p>这个阶段也被称为”绘制”(painting)或repainting，所有的节点被遍历，从root开始，调用paint的方法。</p>
<h2 id="1.3."><a href="#1.3." class="headerlink" title="reflow和repaint优化"></a>1.3. reflow和repaint优化</h2><p>有重要的两点：</p>
<ul>
<li>整个过程很耗费性能(阻塞式)</li>
<li>它们可以重新被触发</li>
</ul>
<p>reflows和repaints不可避免，但是降低它们的频率可以提升我们网站的加载速度</p>
<h3 id="1.3.1."><a href="#1.3.1." class="headerlink" title="是什么触发了reflow和repaint？"></a>1.3.1. 是什么触发了reflow和repaint？</h3><ul>
<li>javascript操作页面<ul>
<li>dom操作(增加或者移除dom)</li>
<li>样式表操作(增加或者移除样式规则)</li>
</ul>
</li>
<li>用户操作(例如):<ul>
<li>a标签的鼠标悬浮效果</li>
<li>滚动页面</li>
<li>input标签中输入文字</li>
<li>resize窗口</li>
</ul>
</li>
</ul>
<p>浏览器会尽可能少的对改变做出响应，因此reflow及repaint可以是全局的，也可以是增量的。<br>reflow和repaint不必同时发生，例如:</p>
<ul>
<li>如果只是改变元素的颜色，那么只会触发repaint</li>
<li>如果改变一个元素的位置，将会触发reflow和repaint</li>
</ul>
<h3 id="1.3.2."><a href="#1.3.2." class="headerlink" title="reflow和repaint哪个性能开销更大？"></a>1.3.2. reflow和repaint哪个性能开销更大？</h3><p>我们必须考虑到浏览器将会使用大量缓存来避免重新计算。</p>
<ul>
<li>一个repaint需要浏览器遍历元素来决定哪些是可见的，哪些事必须展示的</li>
<li>一个reflow重新计算元素的几何状态(geometry)，会递归的(recursively)reflow它的子元素，有时还包括它的相邻元素(siblings)</li>
<li>一个reflow将会触发repaint来更新网页</li>
</ul>
<h3 id="1.3.3."><a href="#1.3.3." class="headerlink" title="如何优化css和html以减少reflow？"></a>1.3.3. 如何优化css和html以减少reflow？</h3><ul>
<li>css越是简洁，reflow越快</li>
<li>dom的层级越多，reflow的性能开销越大</li>
<li>有些元素的display模式比其他的性能开销更大<ul>
<li>行内样式会产生一个更深层次的reflow(further reflow)</li>
<li>有自动的单元宽度的\<table\>性能开销大，因为浏览器需要更多的步骤计算单元格的尺寸</table\></li>
<li>使用flexbox布局性能开销大，因为flex元素的图形能在解析的时候发生改变</li>
</ul>
</li>
</ul>
<h3 id="1.3.4."><a href="#1.3.4." class="headerlink" title="优化javascript"></a>1.3.4. 优化javascript</h3><p>优化优化css和html的重要程度不如javascript， 如下例所示：</p>
<pre><code class="hljs js">    <span class="hljs-keyword">var</span> foo = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'foobar'</span>);
    foo.style.color = <span class="hljs-string">'blue'</span>;
    <span class="hljs-keyword">var</span> margin = <span class="hljs-built_in">parseInt</span>(foo.style.marginTop);
    foo.style.marginTop = (margin + <span class="hljs-number">10</span>) + <span class="hljs-string">'px'</span>;</code></pre><p>由于reflow和repaint在性能开销上很大，浏览器会累积你在同一个时间片段(timeframe)里的所有的dom操作，进入队列(queue)，批量处理它们，我们来分析上面那段代码:</p>
<ul>
<li>在改变颜色属性后，这个操作被放在累积队列里面(accumulating queue),然后我们寻找元素的style。这个操作会强制一个提前的repaint。<br>当我们改变dom的元素的时候，元素被标记为脏的(dirty)，有时它的children也会被标记为脏的(dirty)，意味着至少它的一个子元素要reflow。<br>interval之后，所有的被标记为脏的元素会重新reflow和repaint。<br>请求一个标记为脏的元素的属性，会触发浏览器的提前reflow。</li>
</ul>
<h3 id="1.3.5."><a href="#1.3.5." class="headerlink" title="同步布局与布局垃圾"></a>1.3.5. 同步布局与布局垃圾</h3><p>针对dom的交替读写操作会引发布局垃圾=—性能杀手<br>我们如何避免垃圾？</p>
<ul>
<li>重新组合对dom读写的命令</li>
<li>缓存已计算的样式</li>
<li>不要使用style来改变样式，选择用css</li>
<li>在dom之外操作元素， document fragments</li>
<li>尽可能将有动画的元素position设置为fixed或者absolute，这样更新这些元素的geometry的时候不会影响其他元素</li>
<li>只在有必要的时候将元素展示出来</li>
<li>使用window.requestAnimationFrame()</li>
<li>使用虚拟dom库</li>
</ul>
<h3 id="1.3.6."><a href="#1.3.6." class="headerlink" title="requestAnimationFrame"></a>1.3.6. requestAnimationFrame</h3><p>window.requestAnimationFrame()允许我们在下一次reflow的时候执行代码（每个元素读取属性不会单独触发reflow），这个很有用，因为它允许我们交叉读写，同时以最优顺序执行它们，eg:</p>
<pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doubleHeight</span><span class="hljs-params">(element)</span> </span>{
    <span class="hljs-keyword">var</span> currentHeight = element.clientHeight;
    element.style.height = (currentHeight * <span class="hljs-number">2</span>) + <span class="hljs-string">'px'</span>;
}
all_my_elements.<span class="hljs-keyword">forEach</span>(doubleHeight);</code></pre><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doubleHeight</span>(<span class="hljs-params">element</span>) </span>{
    <span class="hljs-keyword">var</span> currentHeight = element.clientHeight;
    <span class="hljs-built_in">window</span>.requestAnimationFrame(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        element.style.height = (currentHeight * <span class="hljs-number">2</span>) + <span class="hljs-string">'px'</span>;
    });
}
all_my_elements.forEach(doubleHeight);</code></pre><p>使用settimeout(fn,0)粗略的获得相同的结果，因为settimeout通常会在下次reflow的时候执行</p>
<h3 id="1.3.7."><a href="#1.3.7." class="headerlink" title="虚拟dom库"></a>1.3.7. 虚拟dom库</h3><p>优势：</p>
<pre><code class="hljs ">-<span class="ruby"> 聚集操作
</span>-<span class="ruby"> 应用启发式方法
</span>-<span class="ruby"> 缓存值
</span>-<span class="ruby"> 在合适的时候操作DOM， 避免布局垃圾</span></code></pre><h1 id="2."><a href="#2." class="headerlink" title="html parser"></a>2. html parser</h1><ul>
<li>html解析器是个可重入的解析器(这意味着它可接受动态输入)，这让第一阶段的解析更加的复杂。</li>
<li>为何html解析器是可重入的？<ul>
<li>当浏览器解析到script标签的时候，js代码是立刻执行的</li>
<li>js可以修改html，例如通过(document.write)</li>
</ul>
</li>
<li><p>html解析是同步的(synchronous)，当解析器到达script标签的时候：</p>
<ul>
<li>html解析器停止解析（非async defer）</li>
<li>如果是外部脚本，就从外部网络获取脚本代码</li>
<li>将控制权交给js引擎，执行js代码</li>
<li>恢复html解析器的解析</li>
<li><p>这也是script标签移到页面底部的原因</p>
<p>在Gecko和webkit,当引擎被获取和执行脚本所阻塞的时候，会开启第二个进程(thread)开始解析文档(document)寻找外部的资源进行加载，它不会修改dom,但是会开始获取外部的资源。</p>
</li>
</ul>
</li>
<li><p>css是阻塞的, 因为：</p>
<ul>
<li>js有可能会寻求未被解析的css信息</li>
<li><p>浏览器会保持渲染进程直到cssom建立起来</p>
<p>所以：</p>
</li>
<li>script脚本放在页面底部</li>
<li>将样式表按照media type和media query区分，这样有助于我们将css资源标记成非阻塞渲染的资源，非阻塞的资源还是会被浏览器下载，只是优先级较低。</li>
</ul>
</li>
</ul>
<h2 id="2.1."><a href="#2.1." class="headerlink" title="http"></a>2.1. http</h2><p>很多浏览器能够同时下载超过2个的资源，在2014 RFC2616发布的http/1.1 中移除了2个连接的限制。根据browserscope.org的测试，现在主流的浏览器基本能达到同时发送6个http请求，ie11能够达到13个。<br>若是http2， 则没有必要优化连接数</p>
<h2 id="2.2."><a href="#2.2." class="headerlink" title="css"></a>2.2. css</h2><p>所有的样式表都会被解析成cssom对象模型(就和dom树一样展现结构)。<br>每一个页面element都会被许多css规则匹配， 匹配顺序：origin =&gt; weight =&gt; specificity=&gt; order of definition</p>
<ul>
<li>origin: <ul>
<li>作者自定义</li>
<li>浏览器使用者定义</li>
<li>userAgent 定义</li>
</ul>
</li>
<li>weight<ul>
<li>normal weight</li>
<li>!important weight</li>
</ul>
</li>
<li>specificity，即是css选择器的权重(a,b,c,d)的规则决定。<ul>
<li>a : 值为1(当样式放在style属性中的时候)，0为其它情况</li>
<li>b : id在样式规则中出现的次数 eg:#slide #hello p的值就是2</li>
<li>c : class，伪类，和属性在样式中出现的次数 eg:input[type=email]值就是2</li>
<li>d : 标签个数(tag names)和伪类元素出现的次数</li>
</ul>
</li>
</ul>
<p>css规则会根据特定的选择器，分别加入对应的hash表中，当浏览器试图寻找哪个样式表加载到元素上的时候，它没必要查看所有的规则，而只需要查看哈希表。实际上，写css只需匹配最右边的(rightmost)的选择器，这个选择器称为主选择器(key selector)。由于浏览器是由右向左解析，所以以下例子中选择#container2 a时，将会先选择所有a元素，再筛选父级中含有#container2的元素。</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”container1”</span>&gt;</span>
    … thousands of <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span> elements here …
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span> … <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
    … thousands of <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span> elements here …
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">”container2”</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">class</span>=<span class="hljs-string">”a-class”</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>所以改为#container2 .a-class或.a-class更有效率。将$(‘#container .class-name’)改为$(‘.class-name’, ‘#container’)可以很好的性能。前者会先去寻找.class-name然后再沿着dom树寻找#container元素,后者会先找到#container，然后再沿着子树寻找.class-name的元素。</p>
 
</section>

  <section class="footer">
  <div class="container">
    <span class="footer-item">Text is available under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></span>
    <span class="footer-item">Created by <a href="null">ZN</a></span>
    <span class="footer-item">Powered by <a href="https://hexo.io">Hexo</a></span>
    <span class="footer-item">Themed by <a href="https://github.com/xcatliu/hexo-theme-wiki-i18n">wiki-i18n</a></span>
    <span class="footer-item">Hosted by <a href="https://pages.github.com/">GitHub Pages</a></span>
  </div>
</section>

  <script>
  window.HEXO_DATA = {
    config: {"title":"Chuune Wiki","subtitle":"Write something","description":null,"author":"ZN","language":["zh-cn","en","default"],"timezone":null,"url":"http://yoursite.com","root":"/","permalink":":category/:title.html","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":lang/:title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":false,"auto_detect":true,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":1000,"pagination_dir":"page","theme":"wiki-i18n","deploy":{"type":"git","repo":"git@github.com:goumang2010/hexo-wiki.git","branch":"gh-pages","message":null},"author_link":null,"github":"https://github.com/goumang2010/hexo-wiki","index_generator":{"per_page":10,"order_by":"-date"},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true},"jsonContent":{"meta":false,"pages":true,"posts":{"title":true,"date":true,"path":true,"text":true,"raw":false,"content":false,"slug":false,"updated":false,"comments":false,"link":false,"permalink":false,"excerpt":true,"categories":false,"tags":false}},"archive_generator":{"per_page":1000,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":1000},"tag_generator":{"per_page":1000},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}},
  };
</script>

  <script src="/js/dist/custom.min.js?v=57207705166"> </script>


  </body>
</html>
