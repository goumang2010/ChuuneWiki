<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>http | Chuune Wiki</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="//cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-shim.min.js"></script>
  <script src="//apps.bdimg.com/libs/html5shiv/3.7/html5shiv.min.js"></script>
  <link rel="shortcut icon" type="image/png" href="favicon.png"/>
  <link rel="stylesheet" href="/css/index.css">
</head>

  <body>
  <header class="header-page">
    <div class="header-content">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <h1 class="header-logo">
        <a class="no-style header-link" href="
        
          /zh-cn
        
        ">Chuune Wiki</a>
      </h1>
      <div class="menu">
        <a class="no-style header-link" href="/zh-cn/archives">索引</a>
        <a class="no-style header-link" target="_blank" href="https://github.com/goumang2010/hexo-wiki/edit/master/source/_posts/zh-cn/http.md">编辑</a>
        <a class="no-style header-link" href="/readme">README</a>
        <a class="no-style header-link" target="_blank" href="https://github.com/goumang2010/hexo-wiki">GitHub</a>
      </div>
      <div id="header-search-div" class="header-search-div">
        <input id="header-search-input" class="header-search-input" type="text" placeholder="搜索"/>
        <div id="header-search-box" class="header-search-box"><ul id="header-search-list"></ul></div>
      </div>
      <div class="header-lang-select-wrap header-link menu">
        <label>
        
          简体中文
        
        </label>
        <select id="header-lang-select" class="header-lang-select">
        
          
            <option
              value=""
              selected
            >
              简体中文
            </option>
          
            <option
              value=""
              
            >
              English
            </option>
          
        
        </select>
      </div>
    </div>
 <nav id="mobile-nav">
    <a class="no-style header-link" href="
    
      /zh-cn
    
    ">首页</a>
	<a href="/zh-cn/archives">索引</a>
	<a target="_blank" href="https://github.com/goumang2010/hexo-wiki/edit/master/source/_posts/zh-cn/http.md">编辑</a>
	<a href="/readme">README</a>
	<a target="_blank" href="https://github.com/goumang2010/hexo-wiki">GitHub</a>
</nav>
</header>

  <section class="container">
  <h2>http</h2>
  http
  <article class="markdown-body article">
  <div class="toc"><ul><li class="level-1"><a href="#1."><span class="tocnumber">1.</span>&nbsp<span class="toctext">报文</span></a><ul><li class="level-2"><a href="#1.1."><span class="tocnumber">1.1.</span>&nbsp<span class="toctext">格式</span></a></li><li class="level-2"><a href="#1.2."><span class="tocnumber">1.2.</span>&nbsp<span class="toctext">状态码</span></a><ul><li class="level-3"><a href="#1.2.1."><span class="tocnumber">1.2.1.</span>&nbsp<span class="toctext">examples</span></a></li></ul></li><li class="level-2"><a href="#1.3."><span class="tocnumber">1.3.</span>&nbsp<span class="toctext">examples</span></a><ul><li class="level-3"><a href="#1.3.1."><span class="tocnumber">1.3.1.</span>&nbsp<span class="toctext">一个客户端的post请求报文</span></a></li><li class="level-3"><a href="#1.3.2."><span class="tocnumber">1.3.2.</span>&nbsp<span class="toctext">显示请求报文</span></a></li></ul></li></ul></li><li class="level-1"><a href="#2."><span class="tocnumber">2.</span>&nbsp<span class="toctext">缓存</span></a><ul><li class="level-2"><a href="#2.1."><span class="tocnumber">2.1.</span>&nbsp<span class="toctext">缓存存储策略</span></a></li><li class="level-2"><a href="#2.2."><span class="tocnumber">2.2.</span>&nbsp<span class="toctext">缓存过期策略</span></a><ul><li class="level-3"><a href="#2.2.1."><span class="tocnumber">2.2.1.</span>&nbsp<span class="toctext">没有max-age或Expires时的策略</span></a></li></ul></li><li class="level-2"><a href="#2.3."><span class="tocnumber">2.3.</span>&nbsp<span class="toctext">缓存对比策略</span></a><ul><li class="level-3"><a href="#2.3.1."><span class="tocnumber">2.3.1.</span>&nbsp<span class="toctext">为何使用Etag</span></a></li></ul></li><li class="level-2"><a href="#2.4."><span class="tocnumber">2.4.</span>&nbsp<span class="toctext">examples</span></a><ul><li class="level-3"><a href="#2.4.1."><span class="tocnumber">2.4.1.</span>&nbsp<span class="toctext">no cache server</span></a></li><li class="level-3"><a href="#2.4.2."><span class="tocnumber">2.4.2.</span>&nbsp<span class="toctext">公共缓存一年</span></a></li></ul></li></ul></li></ul></div><h1 id="1."><a href="#1." class="headerlink" title="报文"></a>1. 报文</h1><h2 id="1.1."><a href="#1.1." class="headerlink" title="格式"></a>1.1. 格式</h2><p><img src="/images/http-1.png" alt=""></p>
<h2 id="1.2."><a href="#1.2." class="headerlink" title="状态码"></a>1.2. 状态码</h2><p><img src="/images/http-2.png" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:left">code</th>
<th style="text-align:left">状态信息</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">100</td>
<td style="text-align:left">Continue</td>
<td style="text-align:left">初始的请求已经接受，客户应当继续发送请求的其余部分。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:left">101</td>
<td style="text-align:left">Switching Protocols</td>
<td style="text-align:left">服务器将遵从客户的请求转换到另外一种协议（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:left">200</td>
<td style="text-align:left">OK</td>
<td style="text-align:left">一切正常，对GET和POST请求的应答文档跟在后面。</td>
</tr>
<tr>
<td style="text-align:left">201</td>
<td style="text-align:left">Created</td>
<td style="text-align:left">服务器已经创建了文档，Location头给出了它的URL。</td>
</tr>
<tr>
<td style="text-align:left">202</td>
<td style="text-align:left">Accepted</td>
<td style="text-align:left">已经接受请求，但处理尚未完成。</td>
</tr>
<tr>
<td style="text-align:left">203</td>
<td style="text-align:left">Non-Authoritative Information</td>
<td style="text-align:left">文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝（HTTP 1.1新）。</td>
</tr>
<tr>
<td style="text-align:left">204</td>
<td style="text-align:left">No Content</td>
<td style="text-align:left">没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。</td>
</tr>
<tr>
<td style="text-align:left">205</td>
<td style="text-align:left">Reset Content</td>
<td style="text-align:left">没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（HTTP 1.1新）。</td>
</tr>
<tr>
<td style="text-align:left">206</td>
<td style="text-align:left">Partial Content</td>
<td style="text-align:left">客户发送了一个带有Range头的GET请求，服务器完成了它（HTTP 1.1新）。</td>
</tr>
<tr>
<td style="text-align:left">300</td>
<td style="text-align:left">Multiple Choices</td>
<td style="text-align:left">客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。</td>
</tr>
<tr>
<td style="text-align:left">301</td>
<td style="text-align:left">Moved Permanently</td>
<td style="text-align:left">客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。</td>
</tr>
<tr>
<td style="text-align:left">302</td>
<td style="text-align:left">Found</td>
<td style="text-align:left">类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求<a href="http://host/~user（缺少了后面的斜杠），有的服务器" target="_blank" rel="external">http://host/~user（缺少了后面的斜杠），有的服务器</a> 返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见307。</td>
</tr>
<tr>
<td style="text-align:left">303</td>
<td style="text-align:left">See Other</td>
<td style="text-align:left">类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（HTTP 1.1新）。</td>
</tr>
<tr>
<td style="text-align:left">304</td>
<td style="text-align:left">Not Modified</td>
<td style="text-align:left">客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告 诉客户，原来缓冲的文档还可以继续使用。</td>
</tr>
<tr>
<td style="text-align:left">305</td>
<td style="text-align:left">Use Proxy</td>
<td style="text-align:left">客户请求的文档应该通过Location头所指明的代理服务器提取（HTTP 1.1新）。</td>
</tr>
<tr>
<td style="text-align:left">307</td>
<td style="text-align:left">Temporary Redirect</td>
<td style="text-align:left">和302 （Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定 向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只 能跟随对GET请求的重定向。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:left">400</td>
<td style="text-align:left">Bad Request</td>
<td style="text-align:left">请求出现语法错误。</td>
</tr>
<tr>
<td style="text-align:left">401</td>
<td style="text-align:left">Unauthorized</td>
<td style="text-align:left">客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填 写合适的Authorization头后再次发出请求。</td>
</tr>
<tr>
<td style="text-align:left">403</td>
<td style="text-align:left">Forbidden</td>
<td style="text-align:left">资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。</td>
</tr>
<tr>
<td style="text-align:left">404</td>
<td style="text-align:left">Not Found</td>
<td style="text-align:left">无法找到指定位置的资源。这也是一个常用的应答。</td>
</tr>
<tr>
<td style="text-align:left">405</td>
<td style="text-align:left">Method Not Allowed</td>
<td style="text-align:left">请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:left">406</td>
<td style="text-align:left">Not Acceptable</td>
<td style="text-align:left">指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容（HTTP 1.1新）。</td>
</tr>
<tr>
<td style="text-align:left">407</td>
<td style="text-align:left">Proxy Authentication Required</td>
<td style="text-align:left">类似于401，表示客户必须先经过代理服务器的授权。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:left">408</td>
<td style="text-align:left">Request Timeout</td>
<td style="text-align:left">在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:left">409</td>
<td style="text-align:left">Conflict</td>
<td style="text-align:left">通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:left">410</td>
<td style="text-align:left">Gone</td>
<td style="text-align:left">所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而 404表示由于未知的原因文档不可用。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:left">411</td>
<td style="text-align:left">Length Required</td>
<td style="text-align:left">服务器不能处理请求，除非客户发送一个Content-Length头。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:left">412</td>
<td style="text-align:left">Precondition Failed</td>
<td style="text-align:left">请求头中指定的一些前提条件失败（HTTP 1.1新）。</td>
</tr>
<tr>
<td style="text-align:left">413</td>
<td style="text-align:left">Request Entity Too Large</td>
<td style="text-align:left">目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（HTTP 1.1新）。</td>
</tr>
<tr>
<td style="text-align:left">414</td>
<td style="text-align:left">Request URI Too Long</td>
<td style="text-align:left">URI太长（HTTP 1.1新）。</td>
</tr>
<tr>
<td style="text-align:left">416</td>
<td style="text-align:left">Requested Range Not Satisfiable</td>
<td style="text-align:left">服务器不能满足客户在请求中指定的Range头。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:left">500</td>
<td style="text-align:left">Internal Server Error</td>
<td style="text-align:left">服务器遇到了意料不到的情况，不能完成客户的请求。</td>
</tr>
<tr>
<td style="text-align:left">501</td>
<td style="text-align:left">Not Implemented</td>
<td style="text-align:left">服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求。</td>
</tr>
<tr>
<td style="text-align:left">502</td>
<td style="text-align:left">Bad Gateway</td>
<td style="text-align:left">服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。</td>
</tr>
<tr>
<td style="text-align:left">503</td>
<td style="text-align:left">Service Unavailable</td>
<td style="text-align:left">服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。</td>
</tr>
<tr>
<td style="text-align:left">504</td>
<td style="text-align:left">Gateway Timeout</td>
<td style="text-align:left">由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（HTTP 1.1新）</td>
</tr>
<tr>
<td style="text-align:left">505</td>
<td style="text-align:left">HTTP Version Not Supported</td>
<td style="text-align:left">服务器不支持请求中所指明的HTTP版本。（HTTP 1.1新）</td>
</tr>
</tbody>
</table>
<h3 id="1.2.1."><a href="#1.2.1." class="headerlink" title="examples"></a>1.2.1. examples</h3><p><a href="https://nodejs.org/docs/latest/api/http.html#http_http_status_codes" target="_blank" rel="external">https://nodejs.org/docs/latest/api/http.html#http_http_status_codes</a></p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(http.STATUS_CODES, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>));</code></pre><h2 id="1.3."><a href="#1.3." class="headerlink" title="examples"></a>1.3. examples</h2><h3 id="1.3.1."><a href="#1.3.1." class="headerlink" title="一个客户端的post请求报文"></a>1.3.1. 一个客户端的post请求报文</h3><pre><code class="hljs ">POST/servlet/default.jsp HTTP/<span class="hljs-number">1.1</span> !<span class="hljs-comment">--- 这是一个POST方法请求行，指出了所附加的消息的URL和所用的HTTP版本为1.1</span>
<span class="hljs-keyword">Accept</span>-Language:zh-cn,zh !<span class="hljs-comment">--- 指定客户端可以接受的语言</span>
<span class="hljs-keyword">Accept</span>-Charset:GB2312,utf-<span class="hljs-number">8</span> !<span class="hljs-comment">--- 指定客户端可以接受的字符集为GB2312和utf-8</span>
<span class="hljs-keyword">Accept</span>:text/html,application/xhtml+xml,application/xml !<span class="hljs-comment">--- 指定客户端浏览器支持的MIME类型分别是text/html、application/xhtml+xml、application/xml</span>
<span class="hljs-keyword">Accept</span>-Encoding:gzip,deflate !<span class="hljs-comment">--- 指定客户端浏览器支持的压缩编码格式为gzip和deflate</span>
User-Agent:Mozilla/<span class="hljs-number">5.0</span> !<span class="hljs-comment">--- 指定客户端使用的浏览器为Mozilla 5.0版本</span>
Host:www.<span class="hljs-number">51</span>cto.com !<span class="hljs-comment">--- 指定客户端要访问的服务器域名为www.51cto.com</span>
Connection:Keep-Alive !<span class="hljs-comment">--- 指定采用持续连接方式</span>
（这里有一个空行）
user=winda＆pwd=<span class="hljs-number">1234</span> !<span class="hljs-comment">--- 此行为向服务器提交的用户账户为winda，密码为1234</span></code></pre><h3 id="1.3.2."><a href="#1.3.2." class="headerlink" title="显示请求报文"></a>1.3.2. 显示请求报文</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = require(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> testServer = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> <span class="hljs-comment">{
    res.end('just a test');
}</span>).<span class="hljs-title">listen</span><span class="hljs-params">(3000)</span>;</span>
testServer.<span class="hljs-keyword">on</span>(<span class="hljs-string">'connection'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(socket)</span> <span class="hljs-comment">{
    socket.pipe(process.stdout);
}</span>);</span></code></pre><p>使用curl 请求</p>
<pre><code class="hljs bash"><span class="hljs-attribute">curl</span> -d <span class="hljs-string">"param1=value1&amp;param2=value2"</span> <span class="hljs-string">"http://localhost:3000/"</span></code></pre><p>显示：</p>
<pre><code class="hljs bash"><span class="hljs-keyword">POST</span> <span class="hljs-string">/</span> HTTP/1.1
<span class="hljs-attribute">User-Agent</span>: curl/7.35.0
<span class="hljs-attribute">Host</span>: localhost:3000
<span class="hljs-attribute">Accept</span>: */*
<span class="hljs-attribute">Content-Length</span>: 27
<span class="hljs-attribute">Content-Type</span>: application/x-www-form-urlencode</code></pre><h1 id="2."><a href="#2." class="headerlink" title="缓存"></a>2. 缓存</h1><p><a href="http://www.tuicool.com/articles/zUZnUre" target="_blank" rel="external">http://www.tuicool.com/articles/zUZnUre</a><br><a href="https://my.oschina.net/leejun2005/blog/369148" target="_blank" rel="external">https://my.oschina.net/leejun2005/blog/369148</a></p>
<h2 id="2.1."><a href="#2.1." class="headerlink" title="缓存存储策略"></a>2.1. 缓存存储策略</h2><p>Cache-Control 头里的 Public、Private、no-cache、max-age 、no-store 他们都是用来指明响应内容是否可以被客户端存储的，其中前4个都会缓存文件数据（关于 no-cache 应理解为“不建议使用本地缓存”，其仍然会缓存数据到本地），后者 no-store 则不会在客户端缓存任何响应数据。</p>
<h2 id="2.2."><a href="#2.2." class="headerlink" title="缓存过期策略"></a>2.2. 缓存过期策略</h2><p>max-age决定， no-cache视为Cache-Control：max-age=0 ，Cache-Control中的maxAge等同Expires：当前客户端时间 + maxAge， 但Expires和Cache-Control中的max-age同时存在时，以Cache-Control为准。<br>缓存过期后，请求发出时会请求服务器，服务器会根据情况返回200或304。</p>
<h3 id="2.2.1."><a href="#2.2.1." class="headerlink" title="没有max-age或Expires时的策略"></a>2.2.1. 没有max-age或Expires时的策略</h3><p>以Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期</p>
<h2 id="2.3."><a href="#2.3." class="headerlink" title="缓存对比策略"></a>2.3. 缓存对比策略</h2><p>If-Modified-Since（由之前服务端设置的Last-Modified决定）、If-None-Match（由之前服务端设置的Etag决定）</p>
<h3 id="2.3.1."><a href="#2.3.1." class="headerlink" title="为何使用Etag"></a>2.3.1. 为何使用Etag</h3><p>Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间<br>如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存<br>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</p>
<h2 id="2.4."><a href="#2.4." class="headerlink" title="examples"></a>2.4. examples</h2><h3 id="2.4.1."><a href="#2.4.1." class="headerlink" title="no cache server"></a>2.4.1. no cache server</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> testServer = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
    res.writeHead(<span class="hljs-number">200</span>, {
        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span>,
        <span class="hljs-string">'Cache-Control'</span>: <span class="hljs-string">'private, no-cache, no-store, must-revalidate'</span>,
        <span class="hljs-string">'Expires'</span>: <span class="hljs-string">'-1'</span>,
        <span class="hljs-string">'Pragma'</span>: <span class="hljs-string">'no-cache'</span> <span class="hljs-comment">// for http1.0 equivalent to Cache-Control</span>
    });
    res.end(<span class="hljs-string">'just test'</span>);
}).listen(<span class="hljs-number">3000</span>);</code></pre><p>使用express：</p>
<pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-keyword">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> app = express();
app.<span class="hljs-keyword">use</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span> </span>{
    res.header(<span class="hljs-string">'Cache-Control'</span>, <span class="hljs-string">'private, no-cache, no-store, must-revalidate'</span>);
    res.header(<span class="hljs-string">'Expires'</span>, <span class="hljs-string">'-1'</span>);
    res.header(<span class="hljs-string">'Pragma'</span>, <span class="hljs-string">'no-cache'</span>);
    next();
})
app.all(<span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res, next)</span> </span>{
    res.end(<span class="hljs-string">'just test'</span>)
})
<span class="hljs-keyword">const</span> server = app.listen(<span class="hljs-number">3000</span>);</code></pre><h3 id="2.4.2."><a href="#2.4.2." class="headerlink" title="公共缓存一年"></a>2.4.2. 公共缓存一年</h3><pre><code class="hljs js"><span class="hljs-keyword">const</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">'http'</span>);
<span class="hljs-keyword">const</span> testServer = http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>{
    res.writeHead(<span class="hljs-number">200</span>, {
        <span class="hljs-string">'Content-Type'</span>: <span class="hljs-string">'text/plain'</span>,
        <span class="hljs-string">'Cache-Control'</span>: <span class="hljs-string">'public, max-age=31557600'</span>
    });
    res.end(<span class="hljs-string">'just test'</span>);
}).listen(<span class="hljs-number">3000</span>);</code></pre> 
</section>

  <section class="footer">
  <div class="container">
    <span class="footer-item">Text is available under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></span>
    <span class="footer-item">Created by <a href="null">ZN</a></span>
    <span class="footer-item">Powered by <a href="https://hexo.io">Hexo</a></span>
    <span class="footer-item">Themed by <a href="https://github.com/xcatliu/hexo-theme-wiki-i18n">wiki-i18n</a></span>
    <span class="footer-item">Hosted by <a href="https://pages.github.com/">GitHub Pages</a></span>
  </div>
</section>

  <script>
  window.HEXO_DATA = {
    config: {"title":"Chuune Wiki","subtitle":"Write something","description":null,"author":"ZN","language":["zh-cn","en","default"],"timezone":null,"url":"http://yoursite.com","root":"/","permalink":":category/:title.html","permalink_defaults":null,"source_dir":"source","public_dir":"public","tag_dir":"tags","archive_dir":"archives","category_dir":"categories","code_dir":"downloads/code","i18n_dir":":lang","skip_render":null,"new_post_name":":lang/:title.md","default_layout":"post","titlecase":false,"external_link":true,"filename_case":0,"render_drafts":false,"post_asset_folder":false,"relative_link":false,"future":true,"highlight":{"enable":false,"auto_detect":true,"line_number":false,"tab_replace":null},"default_category":"uncategorized","category_map":null,"tag_map":null,"date_format":"YYYY-MM-DD","time_format":"HH:mm:ss","per_page":1000,"pagination_dir":"page","theme":"wiki-i18n","deploy":{"type":"git","repo":"git@github.com:goumang2010/hexo-wiki.git","branch":"gh-pages","message":null},"ignore":[],"author_link":null,"github":"https://github.com/goumang2010/hexo-wiki","index_generator":{"per_page":10,"order_by":"-date"},"marked":{"gfm":true,"pedantic":false,"sanitize":false,"tables":true,"breaks":true,"smartLists":true,"smartypants":true},"jsonContent":{"meta":false,"pages":true,"posts":{"title":true,"date":true,"path":true,"text":true,"raw":false,"content":false,"slug":false,"updated":false,"comments":false,"link":false,"permalink":false,"excerpt":true,"categories":false,"tags":false}},"archive_generator":{"per_page":1000,"yearly":true,"monthly":true,"daily":false},"category_generator":{"per_page":1000},"tag_generator":{"per_page":1000},"server":{"port":4000,"log":false,"ip":"0.0.0.0","compress":false,"header":true}},
  };
</script>

  <script src="/js/dist/custom.min.js?v=53683818334"> </script>


  </body>
</html>
